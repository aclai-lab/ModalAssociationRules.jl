
"""
    const ARule = Tuple{Itemset,Itemset}

An association rule represents a *frequent* and *meaningful* co-occurrence relationship of
the form "X ⇒ Y", between two [`Itemset`](@ref)s X and Y, where X ∩ Y = ∅, respectively
called [`antecedent`](@ref) and [`consequent`](@ref).

# Interface
- applymask(rule::ARule, miner::AbstractMiner)
- SmallItemset(rule::ARule)
- Itemset(rule::ARule)
- content(rule::ARule)
- antecedent(rule::ARule{IT}) where {IT}
- consequent(rule::ARule{IT}) where {IT}
- Base.:(==)(rule1::ARule, rule2::ARule)
- Base.convert(::Type{Itemset}, arule::ARule)
- Base.convert(::Type{SmallItemset}, arule::ARule)
- Base.hash(arule::ARule, h::UInt)

!!! note
    Extracting all the [`ARule`](@ref) "hidden" in the data is the main purpose of
    association rule mining (ARM).

    Given an itemset Z containing atleast two [`Item`](@ref)s (|Z| ≥ 2), it can be
    partitioned in two (sub)itemsets X and Y; trying all the possible binary partitioning
    of Z is a systematic way to generate [`ARule`](@ref)s.

    The general framework always followed by ARM techniques is to, firstly, generate all the
    frequent itemsets considering a set of [`MeaningfulnessMeasure`](@ref) specifically
    tailored to work with [`Itemset`](@ref)s.

    Thereafter, all the association rules are generated by testing all the combinations of
    frequent itemsets against another set of [`MeaningfulnessMeasure`](@ref), this time
    designed to capture how interesting a rule is.

See also [`antecedent`](@ref), [`consequent`](@ref), [`gconfidence`](@ref),
[`Itemset`](@ref), [`lconfidence`](@ref), [`MeaningfulnessMeasure`](@ref).
"""
struct ARule{IT<:AbstractItemset}
    antecedent::IT
    consequent::IT

    function ARule(antecedent::IT, consequent::IT) where {IT<:AbstractItemset}
        intersection = intersect(antecedent, consequent)
        if !(intersection |> length == 0)
            throw(ArgumentError("Invalid rule. " *
                "Antecedent and consequent share the following items: $(intersection)."
            ))
        end

        new{IT}(antecedent, consequent)
    end

    function ARule(doublet::Tuple{IT,IT}) where {IT<:AbstractItemset}
        ARule(first(doublet), last(doublet))
    end
end

function applymask(rule::ARule, miner::AbstractMiner)
    _antecedent = antecedent(rule)
    _consequent = consequent(rule)

    return Itemset(
        applymask(_antecedent |> mask, miner),
        applymask(_consequent |> mask, miner)
    )
end

SmallItemset(rule::ARule) = convert(SmallItemset, rule)
Itemset(rule::ARule) = convert(Itemset, rule)

"""
    content(rule::ARule)::Tuple{Itemset,Itemset}

Getter for the content of an [`ARule`](@ref), that is, both its [`antecedent`](@ref) and
its [`consequent`](@ref).

See also [`antecedent`](@ref), [`ARule`](@ref), [`consequent`](@ref), [`Itemset`](@ref).
"""
content(rule::ARule)::Tuple{Itemset,Itemset} = (rule.antecedent, rule.consequent)

"""
    antecedent(rule::ARule)::Itemset

Getter for `rule`'s antecedent.

See also [`antecedent`](@ref), [`ARule`](@ref), [`Itemset`](@ref).
"""
antecedent(rule::ARule{IT}) where {IT} = rule.antecedent

"""
    consequent(rule::ARule)::Itemset

Getter for `rule`'s consequent.

See also [`consequent`](@ref), [`ARule`](@ref), [`Itemset`](@ref).
"""
consequent(rule::ARule{IT}) where {IT} = rule.consequent

"""
    function Base.:(==)(rule1::ARule, rule2::ARule)

Antecedent (consequent) [`Item`](@ref)s ordering could be different between the two
[`ARule`](@ref), but they are essentially the same rule.

See also [`antecedent`](@ref), [`ARule`](@ref), [`consequent`](@ref).
"""
function Base.:(==)(rule1::ARule, rule2::ARule)
    _antecedent1 = antecedent(rule1)
    _consequent1 = consequent(rule1)

    _antecedent2 = antecedent(rule2)
    _consequent2 = consequent(rule2)

    # first antecedent must be included in the second one,
    # same when considering the consequent;
    # if this is true and lengths are the same, then the two parts coincides.
    return intersect(_antecedent1, _antecedent2) == _antecedent1 &&
        intersect(_consequent1, _consequent2) == _consequent1
end

"""
    function Base.convert(::Type{Itemset}, arule::ARule)::Itemset

Convert an [`ARule`](@ref) to an [`Itemset`](@ref) by merging its [`antecedent`](@ref)
and consequent [`consequent`](@ref).

See also [`antecedent`](@ref), [`ARule`](@ref), [`consequent`](@ref), [`Itemset`](@ref).
"""
function Base.convert(::Type{Itemset}, arule::ARule)::Itemset
    return Itemset(vcat(antecedent(arule), consequent(arule)))
end

"""
    function Base.convert(::Type{SmallItemset}, arule::ARule)::Itemset

Convert an [`ARule`](@ref) to a [`SmallItemset`](@ref) by merging its [`antecedent`](@ref)
and consequent [`consequent`](@ref).

See also [`antecedent`](@ref), [`ARule`](@ref), [`consequent`](@ref), [`Itemset`](@ref).
"""
function Base.convert(::Type{SmallItemset}, arule::ARule)::SmallItemset
    return union(antecedent(arule), consequent(arule))
end

function Base.hash(arule::ARule, h::UInt)
    # the previous version was sort(arule |> antecedent)
    # but sort is already guaranteed from insertion
    _antecedent = arule |> antecedent
    _consequent = arule |> consequent
    return hash(vcat(_antecedent, _consequent), h)
end

function Base.show(io::IO, arule::ARule{IT}) where {IT}
    _antecedent = arule |> antecedent |> mask
    _consequent = arule |> consequent |> mask

    print(io, "$(_antecedent) => $(_consequent)")
end

function Base.show(io::IO, arule::ARule{IT}, miner::AbstractMiner) where {IT}
    _antecedentstr = applymask(arule |> antecedent, miner) |> syntaxstring
    _consequentstr = applymask(arule |> consequent, miner) |> syntaxstring

    print(io, "$(_antecedentstr) => $(_consequentstr)");
end
