# Apriori and FPGrowth comparison on multiple parametrizations
using Test

using ModalAssociationRules
using SoleData
using SoleData: VariableMin, VariableMax
using StatsBase

import ModalAssociationRules.children

if Threads.nthreads() == 1
    printstyled("Skipping check on parallel ModalFP-Growth." *
        "\nDid you forget to set -t?\n", color=:light_yellow)
end

# algorithms to be tested
ALGORITHMS = [apriori, fpgrowth, eclat]
printstyled("Testing: $([a |> string for a in ALGORITHMS])", color=:green)

############################################################################################
# Toy data to parametrize experiments

# load NATOPS dataset and convert it to a Logiset
X_df, y = load_NATOPS();
X_df_1_have_command = X_df[1:30, :]
X_df_short = ((x)->x[1:4]).(X_df)
X1 = scalarlogiset(X_df_short)

X_df_1_have_command = X_df[1:30, :]
X_1_have_command = scalarlogiset(X_df_1_have_command)

# make a vector of item, that will be the initial state of the mining machine
manual_p = Atom(ScalarCondition(VariableMin(1), >, -0.5))
manual_q = Atom(ScalarCondition(VariableMin(2), <=, -2.2))
manual_r = Atom(ScalarCondition(VariableMin(3), >, -3.6))

manual_lp = box(IA_L)(manual_p)
manual_lq = diamond(IA_L)(manual_q)
manual_lr = box(IA_L)(manual_r)

manual_items = Vector{Item}([
    manual_p, manual_q, manual_r, manual_lp, manual_lq, manual_lr])

manual_v2 = [
    Atom(ScalarCondition(VariableMin(4), >=, 1))
    Atom(ScalarCondition(VariableMin(4), >=, 1.8))
    Atom(ScalarCondition(VariableMin(5), >=, -0.5))
    Atom(ScalarCondition(VariableMax(6), >=, 0))
]
manual_v2_modal = vcat(
    manual_v2,
    (manual_v2)[1] |> diamond(IA_L)
) |> Vector{Item}

############################################################################################

# Driver

EXPERIMENTKEYS = (
    :data,
    :items,
    :itemsetmeasures,
    :rulemeasures,
    :expkwargs
);

EXPERIMENTVALUES = (
    (
        X1,
        Vector{Item}([manual_p, manual_q, manual_lp, manual_lq]),
        [(gsupport, 0.1, 0.1)],
        [(gconfidence, 0.2, 0.2)],
        ()
    ),

    (
        X1,
        Vector{Item}([manual_p, manual_q, manual_r]),
        [(gsupport, 0.5, 0.7)],
        [(gconfidence, 0.7, 0.7)],
        ()
    ),

    (
        X1,
        Vector{Item}([manual_lp, manual_lq, manual_lr]),
        [(gsupport, 0.8, 0.8)],
        [(gconfidence, 0.7, 0.7)],
        ()
    ),

    (
        X1,
        Vector{Item}([manual_q, manual_r, manual_lp, manual_lr]),
        [(gsupport, 0.4, 0.4)],
        [(gconfidence, 0.7, 0.7)],
        Dict(:itemset_policies => Function[])
    ),

    (
        X_1_have_command,
        manual_v2_modal,
        [(gsupport, 0.1, 0.1)],
        [(gconfidence, 0.1, 0.1)],
        ()
    ),

    (
        X_1_have_command,
        manual_v2_modal,
        [(gsupport, 0.5, 0.5)],
        [
            (gconfidence, 0.5, 0.5),
            (glift, 0.5, 0.5),          # [-∞,+∞]
            (gconviction, 1.0, 1.0),    # [0,+∞]
            (gleverage, -0.25, -0.25),  # [-0.25,0.25]
        ],
        ()
    ),

    (
        X1,
        Vector{Item}([manual_p, manual_q, manual_lp, manual_lq]),
        [(gsupport, 0.1, 0.1)],
        [(gconfidence, 0.0, 0.0)],
        ()
    )
);

EXPERIMENTS = [
    NamedTuple{EXPERIMENTKEYS}(values)
    for values in (EXPERIMENTVALUES)
];

for (nth,exp) in enumerate(EXPERIMENTS)
    miners = Miner[
        Miner(
            exp.data |> deepcopy,
            algo,
            exp.items,
            exp.itemsetmeasures,
            exp.rulemeasures;
            exp.expkwargs...
        )
        for algo in ALGORITHMS
    ]

    printstyled("Running experiment $(nth)\n", color=:green)
    Commons.compare(miners; verbose=true)
end

############################################################################################
# Other, manual tests

_MANUALEXP = EXPERIMENTS[5]
fpgrowth_miner = Miner(
    _MANUALEXP.data |> deepcopy,
    fpgrowth,
    _MANUALEXP.items,
    _MANUALEXP.itemsetmeasures,
    _MANUALEXP.rulemeasures;
    _MANUALEXP.expkwargs...
)
mine!(fpgrowth_miner)

arule = fpgrowth_miner |> arules |> first
@test_nowarn arule_analysis(arule, fpgrowth_miner; io=devnull, verbose=true)
@test_nowarn convert(Itemset, arule)

@test frame(fpgrowth_miner) isa SoleLogics.FullDimensionalFrame
@test allworlds(fpgrowth_miner) |> first isa SoleLogics.Interval
@test SoleLogics.frame(fpgrowth_miner) |> SoleLogics.nworlds == 1326

@test haskey(ModalAssociationRules._lconfidence_logic(
    arule, data(fpgrowth_miner), 1, fpgrowth_miner), :measure)
@test haskey(ModalAssociationRules._gconfidence_logic(
    arule, data(fpgrowth_miner), 0.1, fpgrowth_miner), :measure)

# to certainly trigger a specific generated by @gmeas macro
@test_nowarn gconfidence(arule, data(fpgrowth_miner), 0.1, fpgrowth_miner)
@test_nowarn gconfidence(arule, data(fpgrowth_miner), 0.1, fpgrowth_miner)

my_bulldozer = Bulldozer(fpgrowth_miner, 1)
@test_nowarn datalock(my_bulldozer)
@test_nowarn memolock(my_bulldozer)
@test_nowarn miningstatelock(my_bulldozer)

@test_nowarn miningstate!(my_bulldozer, :myfield, Dict(42 => 24))
@test miningstate(my_bulldozer, :myfield, 42) == 24
