var documenterSearchIndex = {"docs":
[{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"CurrentModule = SoleRules","category":"page"},{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"Pages = [\"data-structures.md\"]","category":"page"},{"location":"data-structures/#data-structures","page":"Built-in data structures","title":"Built in data structures","text":"","category":"section"},{"location":"data-structures/#FPTree","page":"Built-in data structures","title":"FPTree","text":"","category":"section"},{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"FPTree\n\ncontent(fptree::FPTree)\ncontent!(fptree::FPTree, item::Union{Nothing,Item})\n\nparent(fptree::FPTree)\nparent!(fptree::FPTree, parentfpt::Union{Nothing,FPTree})\n\nchildren(fptree::FPTree)\nchildren!(fptree::FPTree, child::FPTree)\n\nBase.count(fptree::FPTree)\ncount!(fptree::FPTree, newcount::Int64)\naddcount!(fptree::FPTree, deltacount::Int64)\n\ncontributors(fptree::FPTree)\ncontributors!(fptree::FPTree, contribution::WorldMask)\naddcontributors!(fptree::FPTree, contribution::WorldMask)\n\nlink(fptree::FPTree)\nlink!(from::FPTree, to::FPTree)\nfollow(fptree::FPTree)\n\nislist(fptree::FPTree)\nretrieveall(fptree::FPTree)\n\nBase.push!(fptree::FPTree, itemset::Itemset, ninstance::Int64, miner::Miner; htable::Union{Nothing,HeaderTable}=nothing)\n","category":"page"},{"location":"data-structures/#SoleRules.FPTree","page":"Built-in data structures","title":"SoleRules.FPTree","text":"mutable struct FPTree\n    content::Union{Nothing,Item}        # Item contained in this node (nothing if root)\n\n    parent::Union{Nothing,FPTree}       # parent node\n    const children::Vector{FPTree}      # children nodes\n\n    count::Int64                        # number of equal Items this node represents\n\n    # how many times lsupp(content) does overpass\n    # the corresponding threshold for each world\n    const contributors::WorldMask\n\n    link::Union{Nothing,FPTree}         # link to another FPTree root\nend\n\nFundamental data structure used in FP-Growth algorithm. Essentialy, an FPTree is a prefix tree where a root-leaf path represent an Itemset.\n\nConsider the Itemsets sorted by gsupport of their items. An FPTree is such that the common Items-prefix shared by different Itemsets is not stored multiple times.\n\nThis implementation generalizes the propositional logic case scenario to modal logic; given two Itemsets sharing a Item prefix, the worlds in which they are true is accumulated.\n\ninfo: Info\nDid you notice? One FPTree structure contains all the information needed to construct an EnhancedItemset. This is crucial to generate new FPTree during fpgrowth algorithm, via building ConditionalPatternBase iteratively while avoiding visiting the dataset over and over again.\n\nSee also EnhancedItemset, fpgrowth, gsupport, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#SoleRules.content-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.content","text":"content(fptree::FPTree)::Union{Nothing,Item}\n\nGetter for the Item (possibly empty) wrapped by fptree.\n\nSee also content!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.content!-Tuple{FPTree, Union{Nothing, Formula}}","page":"Built-in data structures","title":"SoleRules.content!","text":"content!(fptree::FPTree, item::Union{Nothing,Item})\n\nSetter for fptree's content (the wrapped item).\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.parent-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.parent","text":"parent(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for the parent FPTrees of fptree.\n\nSee also FPTree, parent!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.parent!-Tuple{FPTree, Union{Nothing, FPTree}}","page":"Built-in data structures","title":"SoleRules.parent!","text":"parent!(fptree::FPTree, item::Union{Nothing,FPTree})\n\nSetter for fptree's parent FPTree.\n\nSee also FPTree, parent.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.children-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.children","text":"children(fptree::FPTree)::Vector{FPTree}\n\nGetter for the list of children FPTrees of fptree.\n\nSee also children!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.children!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"SoleRules.children!","text":"children!(fptree::FPTree, child::FPTree)\n\nAdd a new FPTree to fptree's children vector.\n\nwarning: Warning\nThis method forces the new children to be added: it is a caller's responsability to check whether child is not already a children of fptree and, if so, handle the case. This check is performed, for example, in Base.push!.\n\nnote: Note\nThis method already sets the new children parent to fptree itself.\n\nSee also Base.push!, children, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.count-Tuple{FPTree}","page":"Built-in data structures","title":"Base.count","text":"Base.count(fptree::FPTree)::Int64\n\nGetter for the fptree internal counter. Essentially, it represents the number of overlappings Item which ended up in fptree node during the building process of the tree itself.\n\nSee also count!, FPTree, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.count!-Tuple{FPTree, Int64}","page":"Built-in data structures","title":"SoleRules.count!","text":"count!(fptree::FPTree, newcount::Int64)\n\nSetter for fptree's internal counter to a fixed value newcount.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.addcount!-Tuple{FPTree, Int64}","page":"Built-in data structures","title":"SoleRules.addcount!","text":"addcount!(fptree::FPTree, newcount::Int64)\n\nAdd newcount to fptree's internal counter.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.contributors-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.contributors","text":"contributors(fptree::FPTree)::WorldMask\n\nGetter for the fptree contributors array.\n\nConsider the Contributors definition. In the specific case of an FPTree, the contributors array is simply a vector of integers which answers the following question for each i-th world of a generic instance: given a local support threshold t, how many times is lsupp(content) >= t ?\n\nEssentially, it represents the number of overlappings Item which ended up in fptree node during the building process of the tree itself.\n\nSee also Contributors, contributors!, FPTree, Item, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.contributors!-Tuple{FPTree, Vector{Int64}}","page":"Built-in data structures","title":"SoleRules.contributors!","text":"contributors!(fptree::FPTree, contribution::WorldMask)\n\nSetter for fptree's internal contributors mask to contribution WorldMask.\n\nSee also contributors, FPTree, WorldMask.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.addcontributors!-Tuple{FPTree, Vector{Int64}}","page":"Built-in data structures","title":"SoleRules.addcontributors!","text":"addcontributors!(fptree::FPTree, contribution::WorldMask) =\n\nAdd the contribution WorldMask to fptree's internal contributors mask.\n\nSee also contributors, FPTree, WorldMask.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.link-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.link","text":"link(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for fptree's next brother FPTree. fptree's brotherhood is the set of all the FPTree whose content is exactly fptree.content.\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.link!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"SoleRules.link!","text":"function link!(from::FPTree, to::FPTree)\n\nEstablish a link between two FPTrees. If the starting tree is already linked with something, the already existing link are followed until a new \"empty-linked\" FPTree is found.\n\nSee also follow, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.follow-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.follow","text":"function follow(fptree::FPTree)::Union{Nothing,FPTree}\n\nFollow fptree link to (an internal node of) another FPTree.\n\nSee also FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.islist-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.islist","text":"islist(fptree::FPTree)::Bool\n\nReturn true if every subtree in fptree has exactly 0 or 1 children.\n\nSee also FPTree\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.retrieveall-Tuple{FPTree}","page":"Built-in data structures","title":"SoleRules.retrieveall","text":"function retrieveall(fptree::FPTree)::Itemset\n\nReturn all the unique Items appearing in fptree.\n\nSee also FPTree, Item, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.push!-Tuple{FPTree, Vector{Formula}, Int64, Miner}","page":"Built-in data structures","title":"Base.push!","text":"function Base.push!(\n    fptree::FPTree,\n    itemset::Itemset,\n    ninstance::Int64,\n    miner::Miner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\nfunction Base.push!(\n    fptree::FPTree,\n    itemset::EnhancedItemset,\n    ninstance::Int64,\n    miner::Miner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\nBase.push!(\n    fptree::FPTree,\n    enhanceditemsets::ConditionalPatternBase,\n    miner::Miner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\nPush one or more Itemsets/EnhancedItemset to an FPTree. If an HeaderTable is provided, it is leveraged to develop internal links.\n\nwarning: Warning\nTo optimally leverage the compression capabilities of FPTrees, the Itemsets provided should be sorted decreasingly by gsupport. By default, to improve performances, this check is not performed inside this method.\n\nSee also EnhancedItemset, FPTree, gsupport, HeaderTable, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#HeaderTable","page":"Built-in data structures","title":"HeaderTable","text":"","category":"section"},{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"HeaderTable\n\nitems(htable::HeaderTable)\nlink(htable::HeaderTable)\n\nfollow(htable::HeaderTable, item::Item)\nlink!(htable::HeaderTable, fptree::FPTree)\n\nchecksanity!(htable::HeaderTable, miner::Miner)\nBase.reverse(htable::HeaderTable)","category":"page"},{"location":"data-structures/#SoleRules.HeaderTable","page":"Built-in data structures","title":"SoleRules.HeaderTable","text":"struct HeaderTable\n    items::Vector{Item}\n    link::Dict{Item,Union{Nothing,FPTree}}\nend\n\nUtility data structure used to fastly access FPTree internal nodes.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#SoleRules.items-Tuple{HeaderTable}","page":"Built-in data structures","title":"SoleRules.items","text":"items(htable::HeaderTable)::Vector{Item}\n\nGetter for the Items loaded inside htable.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.link-Tuple{HeaderTable}","page":"Built-in data structures","title":"SoleRules.link","text":"link(htable::HeaderTable)\nlink(htable::HeaderTable, item::Item)\n\nGetter for the link structure wrapped by htable, or one of its specific entry.\n\nThe link structure is, essentially, a dictionary associating an Item to a specific FPTree.\n\nSee also FPTree, HeaderTable, Item, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.follow-Tuple{HeaderTable, Formula}","page":"Built-in data structures","title":"SoleRules.follow","text":"function follow(htable::HeaderTable, item::Item)::Union{Nothing,FPTree}\n\nFollow htable link to (an internal node of) a FPTree.\n\nSee also FPTree, HeaderTable, Item, link, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.link!-Tuple{HeaderTable, FPTree}","page":"Built-in data structures","title":"SoleRules.link!","text":"function link!(htable::HeaderTable, fptree::FPTree)\n\nEstablish a link towards fptree, following the entry in htable corresponding to the content of fptree.\n\nSee also content, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#SoleRules.checksanity!-Tuple{HeaderTable, Miner}","page":"Built-in data structures","title":"SoleRules.checksanity!","text":"function checksanity!(htable::HeaderTable, miner::Miner)::Bool\n\nCheck if htable internal state is correct, that is, its items are sorted decreasingly by global support. If items are already sorted, return true; otherwise, sort them and return false.\n\nSee also Miner, gsupport, HeaderTable, items.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.reverse-Tuple{HeaderTable}","page":"Built-in data structures","title":"Base.reverse","text":"Base.reverse(htable::HeaderTable)\n\nIterator on htable wrapped Items, in reverse order.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleRules","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In this introductory section you will learn about the main building blocks of SoleRules.jl.  Also if a good picture about association rule mining (ARM, from now onwards) is given during the documentation, to make the most out of this documentation we suggest to read the following articles:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"association rule mining introduction and Apriori algorithm\nFPGrowth algorithm","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Those up above introduce two important algorithms, which are also built-in in this package. Moreover, the latter one is the state-of-the-art in the field of ARM.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Further on in the documentation, the potential of SoleRules.jl will emerge: this package's raison d'être is to generalize the already existing ARM algorithms to modal logics, which are more expressive than propositional one and computationally less expensive than first order logic. If you are new to Sole.jl and you want to learn more about modal logic, please have a look at SoleLogics.jl for a general overview on the topic, or follow this documentation and return to this link if needed.","category":"page"},{"location":"getting-started/#Core-definitions","page":"Getting started","title":"Core definitions","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"One Item is just a logical formula, which can be interpreted by a certain model. At the moment, here, we don't care about how models are represented by Sole.jl under the hood, or how interpretation algorithm works: what matters is that Items are manipulated by ARM algorithms, which try to find which conjunctions between items are most statistically significant.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Item\nItemset","category":"page"},{"location":"getting-started/#SoleRules.Item","page":"Getting started","title":"SoleRules.Item","text":"const Item = SoleLogics.Formula\n\nFundamental type in the context of association rule mining. An Item is a logical formula, which can be SoleLogics.checked on models.\n\nThe purpose of association rule mining (ARM) is to discover interesting relations between Items, regrouped in Itemsets, to generate association rules (ARule).\n\nInterestingness is established through a set of MeaningfulnessMeasure.\n\nSee also SoleLogics.check, gconfidence, lsupport, MeaningfulnessMeasure, SoleLogics.Formula.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.Itemset","page":"Getting started","title":"SoleRules.Itemset","text":"const Itemset = Vector{Item}\n\nCollection of unique Items.\n\nGiven a MeaningfulnessMeasure meas and a threshold to be overpassed, t, then an itemset itemset is said to be meaningful with respect to meas if and only if meas(itemset) > t. Alternatively to meaningful, it is said to be frequent.\n\nGenerally speaking, meaningfulness (or interestingness) of an itemset is directly correlated to its frequency in the data: intuitively, when a pattern is recurrent in data, then it is candidate to be interesting.\n\nEvery association rule mining algorithm aims to find frequent itemsets by applying meaningfulness measures such as local and global support, respectively lsupport and gsupport.\n\nFrequent itemsets are then used to generate association rules (ARule).\n\nSee also ARule, gsupport, Item, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Notice that one Itemset could be a set, but actually it is a vector: this is because, often, ARM algorithms need to establish an order between items in itemsets to work efficiently. To convert an Itemset in its conjunctive normla form we simply call toformula.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"toformula","category":"page"},{"location":"getting-started/#SoleRules.toformula","page":"Getting started","title":"SoleRules.toformula","text":"toformula(itemset::Itemset)\n\nConjunctive normal form of the Items contained in itemset.\n\nSee also Item, Itemset, SoleLogics.LeftmostConjunctiveForm\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Enough about Itemsets. Our final goal is to produce association rules. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"ARule\ncontent(rule::ARule)\nantecedent(rule::ARule)\nconsequent(rule::ARule)","category":"page"},{"location":"getting-started/#SoleRules.ARule","page":"Getting started","title":"SoleRules.ARule","text":"const ARule = Tuple{Itemset,Itemset}\n\nAn association rule represents a strong and meaningful co-occurrence relationship between two Itemsets whose intersection is empty.\n\nGenerating all the ARule \"hidden\" in the data is the main purpose of ARM.\n\nThe general framework always followed by ARM techniques is to, firstly, generate all the frequent itemsets considering a set of MeaningfulnessMeasure specifically tailored to work with Itemsets. Thereafter, all the association rules are generated by testing all the combinations of frequent itemsets against another set of MeaningfulnessMeasure, this time designed to capture how \"reliable\" a rule is.\n\nSee also gconfidence, Itemset, lconfidence, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.content-Tuple{ARule}","page":"Getting started","title":"SoleRules.content","text":"content(rule::ARule)::Tuple{Itemset,Itemset}\n\nGetter for the content of an ARule, that is, both its antecedent and its consequent.\n\nSee also antecedent, ARule, consequent, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.antecedent-Tuple{ARule}","page":"Getting started","title":"SoleRules.antecedent","text":"antecedent(rule::ARule)::Itemset\n\nGetter for rule's antecedent.\n\nSee also antecedent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.consequent-Tuple{ARule}","page":"Getting started","title":"SoleRules.consequent","text":"consequent(rule::ARule)::Itemset\n\nGetter for rule's consequent.\n\nSee also consequent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When you want to consider a generic entity obtained through an association rule mining algorithm (frequent itemsets and, of course, association rules) just use the following type.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"ARMSubject","category":"page"},{"location":"getting-started/#SoleRules.ARMSubject","page":"Getting started","title":"SoleRules.ARMSubject","text":"ARMSubject = Union{ARule,Itemset}\n\nMemoizable types for association rule mining (ARM).\n\nSee also GmeasMemo, GmeasMemoKey, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Measures","page":"Getting started","title":"Measures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We cannot establish when a ARMSubject is interesting just by looking at its shape: we need meaningfulness measures. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Threshold\nMeaningfulnessMeasure\nislocalof(::Function, ::Function)\nisglobalof(::Function, ::Function)","category":"page"},{"location":"getting-started/#SoleRules.Threshold","page":"Getting started","title":"SoleRules.Threshold","text":"const Threshold = Float64\n\nThreshold value for meaningfulness measures.\n\nSee also gconfidence, gsupport, lconfidence, lsupport.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.MeaningfulnessMeasure","page":"Getting started","title":"SoleRules.MeaningfulnessMeasure","text":"const MeaningfulnessMeasure = Tuple{Function, Threshold, Threshold}\n\nIn the classic propositional case scenario where each instance of a dataset is composed of just a single world (it is a propositional interpretation), a meaningfulness measure is simply a function which measures how many times a property of an Itemset or an ARule is respected across all instances of the dataset.\n\nIn the context of modal logic, where the instances of a dataset are relational objects, every meaningfulness measure must capture two aspects: how much an Itemset or an ARule is meaningful inside an instance, and how much the same object is meaningful across all the instances.\n\nFor this reason, we can think of a meaningfulness measure as a matryoshka composed of an external global measure and an internal local measure. The global measure tests for how many instances a local measure overpass a local threshold. At the end of the process, a global threshold can be used to establish if the global measure is actually meaningful or not. (Note that this generalizes the propositional logic case scenario, where it is enough to just apply a measure across instances.)\n\nTherefore, a MeaningfulnessMeasure is a tuple composed of a global meaningfulness measure, a local threshold and a global threshold.\n\nSee also gconfidence, gsupport, lconfidence, lsupport.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.islocalof-Tuple{Function, Function}","page":"Getting started","title":"SoleRules.islocalof","text":"islocalof(::Function, ::Function)::Bool\n\nTwin method of isglobalof.\n\nTrait to indicate that a local meaningfulness measure is used as subroutine in a global measure.\n\nFor example, islocalof(lsupport, gsupport) is true, and isglobalof(gsupport, lsupport) is false.\n\nwarning: Warning\nWhen implementing a custom meaningfulness measure, make sure to implement both traits if necessary. This is fundamental to guarantee the correct behavior of some methods, such as getlocalthreshold.\n\nSee also getlocalthreshold, gsupport, isglobalof, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.isglobalof-Tuple{Function, Function}","page":"Getting started","title":"SoleRules.isglobalof","text":"isglobalof(::Function, ::Function)::Bool\n\nTwin trait of islocalof.\n\nSee also getlocalthreshold, gsupport, islocalof, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The following are little data structures which will return useful later, when you will read about how a dataset is \"mined\", looking for ARMSubjects.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"LmeasMemoKey\nLmeasMemo\nGmeasMemoKey\nGmeasMemo","category":"page"},{"location":"getting-started/#SoleRules.LmeasMemoKey","page":"Getting started","title":"SoleRules.LmeasMemoKey","text":"const LmeasMemoKey = Tuple{Symbol,ARMSubject,Int64}\n\nKey of a LmeasMemo dictionary. Represents a local meaningfulness measure name (as a Symbol), a ARMSubject, and the number of a dataset instance where the measure is applied.\n\nSee also LmeasMemo, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.LmeasMemo","page":"Getting started","title":"SoleRules.LmeasMemo","text":"const LmeasMemo = Dict{LmeasMemoKey,Threshold}\n\nAssociation between a local measure of a ARMSubject on a specific dataset instance, and its value.\n\nSee also LmeasMemoKey, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.GmeasMemoKey","page":"Getting started","title":"SoleRules.GmeasMemoKey","text":"const GmeasMemoKey = Tuple{Symbol,ARMSubject}\n\nKey of a GmeasMemo dictionary. Represents a global meaningfulness measure name (as a Symbol) and a ARMSubject.\n\nSee also GmeasMemo, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.GmeasMemo","page":"Getting started","title":"SoleRules.GmeasMemo","text":"const GmeasMemo = Dict{GmeasMemoKey,Threshold}\n\nAssociation between a global measure of a ARMSubject on a dataset, and its value.\n\nThe reference to the dataset is not explicited here, since GmeasMemo is intended to be used as a memoization structure inside Miner objects, and the latter already knows the dataset they are working with.\n\nSee also GmeasMemoKey, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"What follows is a list of the already built-in meaningfulness measures. In the hands-on section you will learn how to implement your own measure.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"lsupport(itemset::Itemset, logi_instance::LogicalInstance; miner::Union{Nothing,Miner}=nothing)\ngsupport(itemset::Itemset, X::SupportedLogiset, threshold::Threshold; miner::Union{Nothing,Miner} = nothing)\nlconfidence(rule::ARule, logi_instance::LogicalInstance; miner::Union{Nothing,Miner} = nothing)\ngconfidence(rule::ARule, X::SupportedLogiset, threshold::Threshold; miner::Union{Nothing,Miner} = nothing)","category":"page"},{"location":"getting-started/#SoleRules.lsupport-Tuple{Vector{Formula}, SoleLogics.LogicalInstance}","page":"Getting started","title":"SoleRules.lsupport","text":"function lsupport(\n    itemset::Itemset,\n    logi_instance::LogicalInstance;\n    miner::Union{Nothing,Miner}=nothing\n)::Float64\n\nCompute the local support for the given itemset in the given logi_instance.\n\nLocal support is the ratio between the number of worlds in a LogicalInstance where and Itemset is true and the total number of worlds in the same instance.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also Miner, LogicalInstance, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.gsupport-Tuple{Vector{Formula}, SupportedLogiset, Float64}","page":"Getting started","title":"SoleRules.gsupport","text":"function gsupport(\n    itemset::Itemset,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,Miner} = nothing\n)::Float64\n\nCompute the global support for the given itemset on a logiset X, considering threshold as the threshold for the local support called internally.\n\nGlobal support is the ratio between the number of LogicalInstances in a SupportedLogiset for which the local support, lsupport, is greater than a Threshold, and the total number of instances in the same logiset.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also Miner, LogicalInstance, Itemset, SupportedLogiset, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.lconfidence-Tuple{ARule, SoleLogics.LogicalInstance}","page":"Getting started","title":"SoleRules.lconfidence","text":"function lconfidence(\n    rule::ARule,\n    logi_instance::LogicalInstance;\n    miner::Union{Nothing,Miner} = nothing\n)::Float64\n\nCompute the local confidence for the given rule in the given logi_instance.\n\nLocal confidence is the ratio between lsupport of an ARule on a LogicalInstance and the lsupport of the antecedent of the same rule.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also antecedent, ARule, Miner, LogicalInstance, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.gconfidence-Tuple{ARule, SupportedLogiset, Float64}","page":"Getting started","title":"SoleRules.gconfidence","text":"function gconfidence(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,Miner} = nothing\n)::Float64\n\nCompute the global confidence for the given rule on a logiset X, considering threshold as the threshold for the global support called internally.\n\nGlobal confidence is the ratio between gsupport of an ARule on a SupportedLogiset and the gsupport of the antecedent of the same rule.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also antecedent, ARule, Miner, gsupport, SupportedLogiset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Mining-structures","page":"Getting started","title":"Mining structures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we are ready to start mining. To do so, we need to create a Miner object. We just need to specify which dataset we are working with, together with a mining function, a vector of initial Items, and the `MeaningfulnessMeasures to establish ARMSubject interestingness.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Miner\n\ndataset(miner::Miner)\nalgorithm(miner::Miner)\nitems(miner::Miner)\n\nitem_meas(miner::Miner)\nrule_meas(miner::Miner)\ngetlocalthreshold(miner::Miner, meas::Function)\nsetlocalthreshold(miner::Miner, meas::Function, threshold::Threshold)\ngetglobalthreshold(miner::Miner, meas::Function)\nsetglobalthreshold(miner::Miner, meas::Function, threshold::Threshold)","category":"page"},{"location":"getting-started/#SoleRules.Miner","page":"Getting started","title":"SoleRules.Miner","text":"struct Miner{\n    D<:AbstractDataset,\n    F <:Function,\n    I<:Item,\n    IM<:MeaningfulnessMeasure,\n    RM<:MeaningfulnessMeasure\n}\n    X::D                            # target dataset\n    algorithm::F                    # algorithm used to perform extraction\n    items::Vector{I}\n\n                                    # meaningfulness measures\n    item_constrained_measures::Vector{IM}\n    rule_constrained_measures::Vector{RM}\n\n    freqitems::Vector{Itemset}      # collected frequent itemsets\n    arules::Vector{ARule}           # collected association rules\n\n    lmemo::LmeasMemo                # local memoization structure\n    gmemo::GmeasMemo                # global memoization structure\n\n    powerups::Powerup               # mining algorithm powerups (see documentation)\n    info::Info                      # general informations\nend\n\nMachine learning model interface to perform association rules extraction.\n\nExamples\n\njulia> using SoleRules\njulia> using SoleData\n\n# Load NATOPS DataFrame\njulia> X_df, y = load_arff_dataset(\"NATOPS\");\n\n# Convert NATOPS DataFrame to a Logiset\njulia> X = scalarlogiset(X_df)\n\n# Prepare some propositional atoms\njulia> p = Atom(ScalarCondition(UnivariateMin(1), >, -0.5))\njulia> q = Atom(ScalarCondition(UnivariateMin(2), <=, -2.2))\njulia> r = Atom(ScalarCondition(UnivariateMin(3), >, -3.6))\n\n# Prepare modal atoms using later relationship - see [`SoleLogics.IntervalRelation`](@ref))\njulia> lp = box(IA_L)(p)\njulia> lq = diamond(IA_L)(q)\njulia> lr = boxlater(r)\n\n# Compose a vector of items, regrouping the atoms defined before\njulia> manual_alphabet = Vector{Item}([p, q, r, lp, lq, lr])\n\n# Create an association rule miner wrapping `fpgrowth` algorithm - see [`fpgrowth`](@ref);\n# note that meaningfulness measures are not explicited and, thus, are defaulted as in the\n# call below.\njulia> miner = Miner(X, fpgrowth(), manual_alphabet)\n\n# Create an association rule miner, expliciting global meaningfulness measures with their\n# local and global thresholds, both for [`Itemset`](@ref)s and [`ARule`](@ref).\njulia> miner = Miner(X, fpgrowth(), manual_alphabet,\n    [(gsupport, 0.1, 0.1)], [(gconfidence, 0.2, 0.2)])\n\n# Consider the dataset and learning algorithm wrapped by `miner` (resp., `X` and `fpgrowth`)\n# Mine the frequent itemsets, that is, those for which item measures are large enough.\n# Then iterate the generator returned by [`mine`](@ref) to enumerate association rules.\njulia> for arule in SoleRules.mine(miner)\n    println(miner)\nend\n\nSee also  ARule, apriori, MeaningfulnessMeasure, Itemset, GmeasMemo, LmeasMemo.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.dataset-Tuple{Miner}","page":"Getting started","title":"SoleRules.dataset","text":"dataset(miner::Miner)::AbstractDataset\n\nGetter for the dataset wrapped by miners.\n\nSee SoleBase.AbstractDataset, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.algorithm-Tuple{Miner}","page":"Getting started","title":"SoleRules.algorithm","text":"algorithm(miner::Miner)::Function\n\nGetter for the mining algorithm loaded into miner.\n\nSee Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.items-Tuple{Miner}","page":"Getting started","title":"SoleRules.items","text":"items(miner::Miner)\n\nGetter for the items of Items loaded into miner.\n\nSee Item, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.item_meas-Tuple{Miner}","page":"Getting started","title":"SoleRules.item_meas","text":"item_meas(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nReturn the MeaningfulnessMeasures tailored to work with Itemsets, loaded inside miner.\n\nSee  Itemset, MeaningfulnessMeasure, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.rule_meas-Tuple{Miner}","page":"Getting started","title":"SoleRules.rule_meas","text":"rule_meas(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nReturn the MeaningfulnessMeasures tailored to work with ARules, loaded inside miner.\n\nSee Miner, ARule, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.getlocalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"SoleRules.getlocalthreshold","text":"getlocalthreshold(miner::Miner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work locally (that is, analyzing \"the inside\" of a dataset's instances) in miner.\n\nSee Miner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.setlocalthreshold-Tuple{Miner, Function, Float64}","page":"Getting started","title":"SoleRules.setlocalthreshold","text":"setlocalthreshold(miner::Miner, meas::Function, threshold::Threshold)\n\nSetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work locally (that is, analyzing \"the inside\" of a dataset's instances) in miner.\n\nSee Miner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.getglobalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"SoleRules.getglobalthreshold","text":"getglobalthreshold(miner::Miner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work globally (that is, measuring the behavior of a specific local-measure across all dataset's instances) in miner.\n\nSee Miner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.setglobalthreshold-Tuple{Miner, Function, Float64}","page":"Getting started","title":"SoleRules.setglobalthreshold","text":"setglobalthreshold(miner::Miner, meas::Function, threshold::Threshold)\n\nSetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work globally (that is, measuring the behavior of a specific local-measure across all dataset's instances) in miner.\n\nSee Miner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"After a Miner ends mining, frequent Itemsets and ARule are accessibles through the getters below.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"freqitems(miner::Miner)\narules(miner::Miner)","category":"page"},{"location":"getting-started/#SoleRules.freqitems-Tuple{Miner}","page":"Getting started","title":"SoleRules.freqitems","text":"freqitems(miner::Miner)\n\nReturn all frequent Itemsets mined by miner.\n\nSee also Itemset, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.arules-Tuple{Miner}","page":"Getting started","title":"SoleRules.arules","text":"arules(miner::Miner)\n\nReturn all the ARules mined by miner.\n\nSee also ARule, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"localmemo(miner::Miner)\nlocalmemo!(miner::Miner, key::LmeasMemoKey, val::Threshold)\nglobalmemo(miner::Miner)\nglobalmemo!(miner::Miner, key::GmeasMemoKey, val::Threshold)","category":"page"},{"location":"getting-started/#SoleRules.localmemo-Tuple{Miner}","page":"Getting started","title":"SoleRules.localmemo","text":"localmemo(miner::Miner)::LmeasMemo\nlocalmemo(miner::Miner, key::LmeasMemoKey)\n\nReturn the local memoization structure inside miner, or a specific entry if a LmeasMemoKey is provided.\n\nSee also Miner, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.localmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject, Int64}, Float64}","page":"Getting started","title":"SoleRules.localmemo!","text":"localmemo!(miner::Miner, key::LmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the local memoization structure wrapped by miner.\n\nSee also Miner, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.globalmemo-Tuple{Miner}","page":"Getting started","title":"SoleRules.globalmemo","text":"globalmemo(miner::Miner)::GmeasMemo\nglobalmemo(miner::Miner, key::GmeasMemoKey)\n\nReturn the global memoization structure inside miner, or a specific entry if a GmeasMemoKey is provided.\n\nSee also Miner, GmeasMemo, GmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.globalmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject}, Float64}","page":"Getting started","title":"SoleRules.globalmemo!","text":"globalmemo!(miner::Miner, key::GmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the global memoization structure wrapped by miner.\n\nSee also Miner, GmeasMemo, GmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The info field in Miner is a dictionary used to store extra informations about the miner, such as statistics about mining. Currently, since the package is still being developed, the info field only contains a flag indicating whether the miner has been used for mining or no.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"info(miner::Miner)\ninfo!(miner::Miner, key::Symbol, val)\nhasinfo(miner::Miner, key::Symbol)","category":"page"},{"location":"getting-started/#SoleRules.info-Tuple{Miner}","page":"Getting started","title":"SoleRules.info","text":"info(miner::Miner)::Powerup\ninfo(miner::Miner, key::Symbol)\n\nGetter for the entire additional informations field inside a miner, or one of its specific entries.\n\nSee also Miner, Powerup.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.info!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"SoleRules.info!","text":"info!(miner::Miner, key::Symbol, val)\n\nSetter for the content of a specific field of miner's info.\n\nSee also hasinfo, info, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.hasinfo-Tuple{Miner, Symbol}","page":"Getting started","title":"SoleRules.hasinfo","text":"hasinfo(miner::Miner, key::Symbol)\n\nReturn whether miner additional informations field contains an entry key.\n\nSee also Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When writing your own mining algorithm, or when mining with a particular kind of dataset, you might need to specialize the Miner, keeping, for example, custom meta data and data structures. To specialize a Miner, you can fill a Powerup structure to fit your needs.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Powerup\npowerups(miner::Miner)\npowerups!(miner::Miner, key::Symbol, val)\nhaspowerup(miner::Miner, key::Symbol)\ninitpowerups(::Function, ::AbstractDataset)","category":"page"},{"location":"getting-started/#SoleRules.Powerup","page":"Getting started","title":"SoleRules.Powerup","text":"const Powerup = Dict{Symbol,Any}\n\nAdditional informations associated with an ARMSubject that can be used to specialize a Miner, augmenting its capabilities.\n\nTo understand how to specialize a Miner, see haspowerup, initpowerups, 'powerups`, powerups!.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleRules.powerups-Tuple{Miner}","page":"Getting started","title":"SoleRules.powerups","text":"powerups(miner::Miner)::Powerup\npowerups(miner::Miner, key::Symbol)\n\nGetter for the entire powerups structure currently loaded in miner, or a specific powerup.\n\nSee also haspowerup, initpowerups, Miner, Powerup.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.powerups!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"SoleRules.powerups!","text":"powerups!(miner::Miner, key::Symbol, val)\n\nSetter for the content of a specific field of miner's powerups.\n\nSee also haspowerup, initpowerups, Miner, Powerup.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.haspowerup-Tuple{Miner, Symbol}","page":"Getting started","title":"SoleRules.haspowerup","text":"haspowerup(miner::Miner, key::Symbol)\n\nReturn whether miner powerups field contains an entry key.\n\nSee also Miner, Powerup, powerups.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.initpowerups-Tuple{Function, AbstractDataset}","page":"Getting started","title":"SoleRules.initpowerups","text":"initpowerups(::Function, ::AbstractDataset)\n\nThis defines how Miner's powerup field is filled to optimize the mining.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To conclude this section, this is how to start mining.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"mine(miner::Miner)\napply(miner::Miner, X::AbstractDataset)","category":"page"},{"location":"getting-started/#SoleRules.mine-Tuple{Miner}","page":"Getting started","title":"SoleRules.mine","text":"mine(miner::Miner)\n\nSynonym for SoleRules.apply(miner, dataset(miner)).\n\nSee also ARule, Itemset, SoleRules.apply.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleRules.apply-Tuple{Miner, AbstractDataset}","page":"Getting started","title":"SoleRules.apply","text":"apply(miner::Miner, X::AbstractDataset)\n\nExtract association rules in the dataset referenced by miner, saving the interesting Itemsets inside miner. Then, return a generator of ARules.\n\nSee also ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = SoleRules","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"utilities/#man-utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The following utilities often involve performing some combinatoric trick between Itemsets and ARules, and  might be useful to avoid reinventing the wheel.","category":"page"},{"location":"utilities/#Items-and-Itemsets","page":"Utilities","title":"Items and Itemsets","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"combine\ngrow_prune\ncoalesce_contributors(itemset::Itemset, miner::Miner; lmeas::Function=lsupport)","category":"page"},{"location":"utilities/#SoleRules.combine","page":"Utilities","title":"SoleRules.combine","text":"combine(itemsets::Vector{<:Itemset}, newlength::Integer)\n\nReturn a generator which combines Itemsets from itemsets into new itemsets of length newlength by taking all combinations of two itemsets and joining them.\n\nSee also Itemset.\n\n\n\n\n\ncombine(variable::Vector{<:Item}, fixed::Vector{<:Item})\n\nReturn a generator of Itemset, which iterates the combinations of Items in variable and prepend them to fixed vector.\n\nSee also Item, Itemset.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SoleRules.grow_prune","page":"Utilities","title":"SoleRules.grow_prune","text":"grow_prune(candidates::Vector{Itemset}, frequents::Vector{Itemset}, k::Integer)\n\nReturn a generator, which yields only the candidates for which every (k-1)-length subset is in frequents.\n\nwarning: Warning\nGenerated Itemsets could contain repetitions.\n\nSee also Itemset.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SoleRules.coalesce_contributors-Tuple{Vector{Formula}, Miner}","page":"Utilities","title":"SoleRules.coalesce_contributors","text":"coalesce_contributors(\n    itemset::Itemset,\n    miner::Miner;\n    lmeas::Function=lsupport\n)\n\nConsider all the contributors of an ARMSubject on all the instances. Return their sum and a boolean value, indicating whether the resulting contributors overpasses the local support threshold enough times.\n\nSee also ARMSubject, contributors, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Association-rules","page":"Utilities","title":"Association rules","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"arules_generator(itemsets::Vector{Itemset}, miner::Miner)","category":"page"},{"location":"utilities/#SoleRules.arules_generator-Tuple{Vector{Vector{Formula}}, Miner}","page":"Utilities","title":"SoleRules.arules_generator","text":"arules_generator(itemsets::Vector{Itemset}, miner::Miner)\n\nGenerates association rules from the given collection of itemsets and miner. Iterates through the powerset of each itemset to generate meaningful ARule.\n\nTo establish the meaningfulness of each association rule, check if it meets the global constraints specified in rule_meas(miner), and yields the rule if so.\n\nSee also ARule, Miner, Itemset, rule_meas.\n\n\n\n\n\n","category":"method"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"CurrentModule = SoleRules","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Pages = [\"modal-generalization.md\"]","category":"page"},{"location":"modal-generalization/#man-modal-generalization","page":"Mining with modal logic","title":"Association rule mining with modal logic","text":"","category":"section"},{"location":"modal-generalization/#New-building-blocks","page":"Mining with modal logic","title":"New building blocks","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"WorldMask\nEnhancedItemset\nConditionalPatternBase","category":"page"},{"location":"modal-generalization/#SoleRules.WorldMask","page":"Mining with modal logic","title":"SoleRules.WorldMask","text":"const WorldMask = Vector{Int64}\n\nVector whose i-th position stores how many times a certain MeaningfulnessMeasure applied on a specific Itemsets is true on the i-th world of multiple instances.\n\nIf a single instance is considered, then this acts as a bit mask.\n\nFor example, if we consider 5 instances, each of which containing 3 worlds, then the worlds mask of an itemset could be [5,2,0], meaning that the itemset is always true on the first world of every instance. If we consider the second world, the same itemset is true on it only on two instances. If we consider the third world, then the itemset is never true.\n\nSee also Contributors, Itemset, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#SoleRules.EnhancedItemset","page":"Mining with modal logic","title":"SoleRules.EnhancedItemset","text":"const EnhancedItemset = Vector{Tuple{Item,Int64,WorldMask}}\n\n\"Enhanced\" representation of an Itemset, in which each Item is associated to a counter and a specific WorldMask.\n\nConsider an Item called item. The first counter keeps the value of gsupport applied on item itself. The second counter counts on which worlds item is true.\n\nIntuitively, this type is useful to represent and manipulate collections of items when we want to avoid iterating an entire dataset multiple times when extracting frequent Itemset.\n\ninfo: Info\nTo give you a better insight into where this type of data is used, this is widely used behind the scenes in the implementation of fpgrowth, which is the state of art algorithm to perform ARM.\n\nSee also fpgrowth, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#SoleRules.ConditionalPatternBase","page":"Mining with modal logic","title":"SoleRules.ConditionalPatternBase","text":"const ConditionalPatternBase = Vector{EnhancedItemset}\n\nCollection of EnhancedItemset. This is useful to manipulate certain data structures when looking for frequent Itemsets, such as FPTree.\n\nThis is used to implement fpgrowth algorithm as described here.\n\nSee also EnhancedItemset, fpgrowth, FPTree.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#Modal-logic-in-action","page":"Mining with modal logic","title":"Modal logic in action","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Contributors\n@equip_contributors\nisequipped\ncontributors\ncontributors!","category":"page"},{"location":"modal-generalization/#SoleRules.Contributors","page":"Mining with modal logic","title":"SoleRules.Contributors","text":"Structure for storing association between a local measure, applied on a certain ARMSubject on a certain LogicalInstance, and a vector of integers representing the worlds for which the measure is greater than a certain threshold.\n\nThis type is intended to be used inside a Miner info named tuple, to support the execution of, for example, fpgrowth algorthm.\n\nSee also LmeasMemoKey, WorldMask\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#SoleRules.contributors","page":"Mining with modal logic","title":"SoleRules.contributors","text":"contributors(fptree::FPTree)::WorldMask\n\nGetter for the fptree contributors array.\n\nConsider the Contributors definition. In the specific case of an FPTree, the contributors array is simply a vector of integers which answers the following question for each i-th world of a generic instance: given a local support threshold t, how many times is lsupp(content) >= t ?\n\nEssentially, it represents the number of overlappings Item which ended up in fptree node during the building process of the tree itself.\n\nSee also Contributors, contributors!, FPTree, Item, lsupport.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#SoleRules.contributors!","page":"Mining with modal logic","title":"SoleRules.contributors!","text":"contributors!(miner::Miner, key::LmeasMemoKey, mask::WorldMask)\n\nSet a miner's contributors entry.\n\nSee also Miner, LmeasMemoKey, @equip_contributors, WorldMask.\n\n\n\n\n\ncontributors!(fptree::FPTree, contribution::WorldMask)\n\nSetter for fptree's internal contributors mask to contribution WorldMask.\n\nSee also contributors, FPTree, WorldMask.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleRules","category":"page"},{"location":"#SoleRules","page":"Home","title":"SoleRules","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleRules, a Julia package for mining (modal) association rules in SoleRules.jl. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleRules.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleRules\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SoleRules.jl lives in the context of Sole.jl, an open-source framework for symbolic machine learning, originally designed for machine learning based on modal logics (see Eduard I. Stan's PhD thesis 'Foundations of Modal Symbolic Learning' here).","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleBase.jl\nSoleLogics.jl\nMultiData.jl\nSoleModels.jl\nSoleData.jl\nSoleFeatures.jl \nSolePostHoc.jl","category":"page"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"CurrentModule = SoleRules","category":"page"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Pages = [\"hands-on.md\"]","category":"page"},{"location":"hands-on/#hands-on","page":"Hands on","title":"Hands-on","text":"","category":"section"},{"location":"hands-on/#A-little-recap...","page":"Hands on","title":"A little recap...","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Write here a little lesson here, maybe with a jupyter notebook like @giopaglia did.","category":"page"},{"location":"hands-on/#Implementing-a-new-meaningfulness-measure","page":"Hands on","title":"Implementing a new meaningfulness measure","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Local and global lift.","category":"page"},{"location":"hands-on/#Writing-a-new-mining-algorithm","page":"Hands on","title":"Writing a new mining algorithm","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Write a new mining algorithm (eclat)","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"CurrentModule = SoleRules","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Pages = [\"algorithms.md\"]","category":"page"},{"location":"algorithms/#algorithms","page":"Available algorithms","title":"Available algorithms","text":"","category":"section"},{"location":"algorithms/#Candidate-generation-based","page":"Available algorithms","title":"Candidate generation based","text":"","category":"section"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"apriori(;fulldump::Bool=true, verbose::Bool=true)","category":"page"},{"location":"algorithms/#TreeProjection-based","page":"Available algorithms","title":"TreeProjection based","text":"","category":"section"},{"location":"algorithms/#FPGrowth","page":"Available algorithms","title":"FPGrowth","text":"","category":"section"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"fpgrowth(;fulldump::Bool=true, verbose::Bool=true)","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on two data structures, FPTree and HeaderTable. To know more about them and their, please refer to the documentation here data-structures.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on the following two routines.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"patternbase(item::Item, htable::HeaderTable, miner::Miner)\nprojection(pbase::ConditionalPatternBase; miner::Union{Nothing,Miner}=nothing)","category":"page"},{"location":"algorithms/#SoleRules.patternbase-Tuple{Formula, HeaderTable, Miner}","page":"Available algorithms","title":"SoleRules.patternbase","text":"patternbase(item::Item, htable::HeaderTable, miner::Miner)::ConditionalPatternBase\n\nRetrieve the ConditionalPatternBase of fptree based on item.\n\nThe conditional pattern based on a FPTree is the set of all the paths from the tree root to nodes containing item (not included). Each of these paths is represented by an EnhancedItemset, where each Item is associated with a WorldMask, given by the minimum of its contributors and the ones of item.\n\nThe EnhancedItemsets in the returned ConditionalPatternBase are sorted decreasingly by gsupport.\n\nSee also Miner, ConditionalPatternBase, contributors, EnhancedItemset, fpgrowth, FPTree, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#SoleRules.projection-Tuple{Vector{Vector{Tuple{Formula, Int64, Vector{Int64}}}}}","page":"Available algorithms","title":"SoleRules.projection","text":"function projection(\n    pbase::ConditionalPatternBase;\n    miner::Union{Nothing,Miner}=nothing\n)\n\nReturn respectively a FPTree and a HeaderTable starting from pbase. It is reccomended to also provide a Miner to guarantee the generated header table internal state is OK, that is, its items are sorted decreasingly by gsupport.\n\nSee also ConditionalPatternBase, FPTree, gsupport, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Also, FPGrowth requires the Miner to remember the Contributors associated with the extracted frequent itemsets. To add this functionality, we can define a new dispatch of initpowerups: it is automatically considered to enrich the miner, while building it together with fpgrowth as mining algorithm.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"initpowerups(::typeof(fpgrowth), ::AbstractDataset)","category":"page"},{"location":"algorithms/#SoleRules.initpowerups-Tuple{typeof(fpgrowth), AbstractDataset}","page":"Available algorithms","title":"SoleRules.initpowerups","text":"initpowerups(::typeof(fpgrowth), ::AbstractDataset)::NamedTuple\n\nPowerups suite for FP-Growth algorithm.\n\nWhen initializing a Miner with fpgrowth algorithm, this defines how miner's powerup field is filled to optimize the mining.\n\nSee also haspowerup, powerup.\n\n\n\n\n\n","category":"method"}]
}
