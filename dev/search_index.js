var documenterSearchIndex = {"docs":
[{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"CurrentModule = ModalAssociationRules","category":"page"},{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"Pages = [\"data-structures.md\"]","category":"page"},{"location":"data-structures/#data-structures","page":"Built-in data structures","title":"Built in data structures","text":"","category":"section"},{"location":"data-structures/#FPTree","page":"Built-in data structures","title":"FPTree","text":"","category":"section"},{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"FPTree\n\ncontent(fptree::FPTree)\ncontent!(fptree::FPTree, item::Union{Nothing,Item})\n\nparent(fptree::FPTree)\nparent!(fptree::FPTree, parentfpt::Union{Nothing,FPTree})\n\nchildren(fptree::FPTree)\nchildren!(fptree::FPTree, child::FPTree)\n\nBase.count(fptree::FPTree)\ncount!(fptree::FPTree, newcount::Int64)\naddcount!(fptree::FPTree, deltacount::Int64)\n\ncontributors(fptree::FPTree)\ncontributors!(fptree::FPTree, contribution::WorldMask)\naddcontributors!(fptree::FPTree, contribution::WorldMask)\n\nBase.push!(fptree::FPTree, itemset::Itemset, ninstance::Int64, miner::Miner; htable::Union{Nothing,HeaderTable}=nothing)\n\nlink(fptree::FPTree)\nlink!(from::FPTree, to::FPTree)\nfollow(fptree::FPTree)\n\nislist(fptree::FPTree)\nretrieveall(fptree::FPTree)\nprune!(fptree::FPTree, miner::Miner)","category":"page"},{"location":"data-structures/#ModalAssociationRules.FPTree","page":"Built-in data structures","title":"ModalAssociationRules.FPTree","text":"mutable struct FPTree\n    content::Union{Nothing,Item}        # Item contained in this node (nothing if root)\n\n    parent::Union{Nothing,FPTree}       # parent node\n    const children::Vector{FPTree}      # children nodes\n\n    count::Int64                        # number of equal Items this node represents\n\n    link::Union{Nothing,FPTree}         # link to another FPTree root\nend\n\nFundamental data structure used in FP-Growth algorithm. Essentialy, an FPTree is a prefix tree where a root-leaf path represent an Itemset.\n\nConsider the Itemsets sorted by gsupport of their items. An FPTree is such that the common Items-prefix shared by different Itemsets is not stored multiple times.\n\nThis implementation generalizes the propositional logic case scenario to modal logic; given two Itemsets sharing a Item prefix, the worlds in which they are true is accumulated.\n\ninfo: Info\nDid you notice? One FPTree structure contains all the information needed to construct an EnhancedItemset. This is crucial to generate new FPTrees during fpgrowth algorithm, via building ConditionalPatternBase iteratively while avoiding visiting the dataset over and over again.\n\nSee also EnhancedItemset, fpgrowth, gsupport, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.content-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.content","text":"content(fptree::FPTree)::Union{Nothing,Item}\n\nGetter for the Item (possibly empty) wrapped by fptree.\n\nSee also content!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.content!-Tuple{FPTree, Union{Nothing, Formula}}","page":"Built-in data structures","title":"ModalAssociationRules.content!","text":"content!(fptree::FPTree, item::Union{Nothing,Item})\n\nSetter for fptree's content (the wrapped item).\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.parent","text":"parent(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for the parent FPTrees of fptree.\n\nSee also FPTree, parent!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent!-Tuple{FPTree, Union{Nothing, FPTree}}","page":"Built-in data structures","title":"ModalAssociationRules.parent!","text":"parent!(fptree::FPTree, item::Union{Nothing,FPTree})\n\nSetter for fptree's parent FPTree.\n\nSee also FPTree, parent.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.children","text":"children(fptree::FPTree)::Vector{FPTree}\n\nGetter for the list of children FPTrees of fptree.\n\nSee also children!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.children!","text":"children!(fptree::FPTree, child::FPTree)\n\nAdd a new FPTree to fptree's children vector.\n\nwarning: Warning\nThis method forces the new children to be added: it is a caller's responsability to check whether child is not already a children of fptree and, if so, handle the case. This check is performed, for example, in grow!.\n\nnote: Note\nThis method already sets the new children parent to fptree itself.\n\nSee also children, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.count-Tuple{FPTree}","page":"Built-in data structures","title":"Base.count","text":"Base.count(fptree::FPTree)::Int64\n\nGetter for the fptree internal counter. Essentially, it represents the number of overlappings Item which ended up in fptree node during the building process of the tree itself.\n\nSee also count!, FPTree, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.count!-Tuple{FPTree, Int64}","page":"Built-in data structures","title":"ModalAssociationRules.count!","text":"count!(fptree::FPTree, newcount::Int64)\n\nSetter for fptree's internal counter to a fixed value newcount.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.addcount!-Tuple{FPTree, Int64}","page":"Built-in data structures","title":"ModalAssociationRules.addcount!","text":"addcount!(fptree::FPTree, newcount::Int64)\n\nAdd newcount to fptree's internal counter.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link","text":"link(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for fptree's next brother FPTree. fptree's brotherhood is the set of all the FPTree whose content is exactly fptree.content.\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link!","text":"function link!(from::FPTree, to::FPTree)\n\nEstablish a link between two FPTrees. If the starting tree is already linked with something, the already existing link are followed until a new \"empty-linked\" FPTree is found.\n\nSee also follow, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.follow","text":"function follow(fptree::FPTree)::Union{Nothing,FPTree}\n\nFollow fptree link to (an internal node of) another FPTree.\n\nSee also FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.islist-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.islist","text":"islist(fptree::FPTree)::Bool\n\nReturn true if every subtree in fptree has exactly 0 or 1 children.\n\nSee also FPTree\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#HeaderTable","page":"Built-in data structures","title":"HeaderTable","text":"","category":"section"},{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"HeaderTable\n\nitems(htable::HeaderTable)\nlink(htable::HeaderTable)\n\nfollow(htable::HeaderTable, item::Item)\nlink!(htable::HeaderTable, fptree::FPTree)\n\nchecksanity!(htable::HeaderTable, miner::Miner)\nBase.reverse(htable::HeaderTable)","category":"page"},{"location":"data-structures/#ModalAssociationRules.HeaderTable","page":"Built-in data structures","title":"ModalAssociationRules.HeaderTable","text":"struct HeaderTable\n    items::Vector{Item}\n    link::Dict{Item,Union{Nothing,FPTree}}\nend\n\nUtility data structure used to fastly access FPTree internal nodes.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.items-Tuple{HeaderTable}","page":"Built-in data structures","title":"ModalAssociationRules.items","text":"items(htable::HeaderTable)::Vector{Item}\n\nGetter for the Items loaded inside htable.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{HeaderTable}","page":"Built-in data structures","title":"ModalAssociationRules.link","text":"link(htable::HeaderTable)\nlink(htable::HeaderTable, item::Item)\n\nGetter for the link structure wrapped by htable, or one of its specific entry.\n\nThe link structure is, essentially, a dictionary associating an Item to a specific FPTree.\n\nSee also FPTree, HeaderTable, Item, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{HeaderTable, Formula}","page":"Built-in data structures","title":"ModalAssociationRules.follow","text":"function follow(htable::HeaderTable, item::Item)::Union{Nothing,FPTree}\n\nFollow htable link to (an internal node of) a FPTree.\n\nSee also FPTree, HeaderTable, Item, link, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{HeaderTable, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link!","text":"function link!(htable::HeaderTable, fptree::FPTree)\n\nEstablish a link towards fptree, following the entry in htable corresponding to the content of fptree.\n\nSee also content, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.checksanity!-Tuple{HeaderTable, Miner}","page":"Built-in data structures","title":"ModalAssociationRules.checksanity!","text":"function checksanity!(htable::HeaderTable, miner::Miner)::Bool\n\nCheck if htable internal state is correct, that is, its items are sorted decreasingly by global support. If items are already sorted, return true; otherwise, sort them and return false.\n\nSee also Miner, gsupport, HeaderTable, items.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.reverse-Tuple{HeaderTable}","page":"Built-in data structures","title":"Base.reverse","text":"Base.reverse(htable::HeaderTable)\n\nIterator on htable wrapped Items, in reverse order.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = ModalAssociationRules","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In this introductory section you will learn about the main building blocks of ModalAssociationRules.jl.  Also if a good picture about association rule mining (ARM, from now onwards) is given during the documentation, to make the most out of this guide we suggest to read the following articles:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"association rule mining introduction and Apriori algorithm\nFPGrowth algorithm","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Those up above introduce two important algorithms, which are also built-in in this package. Moreover, the latter one is the state-of-the-art in the field of ARM.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Further on in the documentation, the potential of ModalAssociationRules.jl will emerge: this package's raison d'être is to generalize the already existing ARM algorithms to modal logics, which are more expressive than propositional one and computationally less expensive than first order logic. If you are new to Sole.jl and you want to learn more about modal logic, please have a look at SoleLogics.jl for a general overview on the topic, or follow this documentation and return to this link if needed.","category":"page"},{"location":"getting-started/#Core-definitions","page":"Getting started","title":"Core definitions","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"One Item is just a logical formula, which can be interpreted by a certain model. At the moment, here, we don't care about how models are represented by Sole.jl under the hood, or how the checking algorithm works: what matters is that Items are manipulated by ARM algorithms, which try to find which conjunctions between items are most statistically significant.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Item\nItemset","category":"page"},{"location":"getting-started/#ModalAssociationRules.Item","page":"Getting started","title":"ModalAssociationRules.Item","text":"const Item = SoleLogics.Formula\n\nFundamental type in the context of association rule mining. An Item is a logical formula, which can be SoleLogics.checked on models.\n\nThe purpose of association rule mining (ARM) is to discover interesting relations between Items, regrouped in Itemsets, to generate association rules (ARule).\n\nInterestingness is established through a set of MeaningfulnessMeasure.\n\nSee also SoleLogics.check, gconfidence, lsupport, MeaningfulnessMeasure, SoleLogics.Formula.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.Itemset","page":"Getting started","title":"ModalAssociationRules.Itemset","text":"struct Itemset\n    items::Vector{Item}\nend\n\nCollection of unique Items.\n\nGiven a MeaningfulnessMeasure meas and a threshold to be overpassed t, then an itemset itemset is said to be meaningful with respect to meas if and only if meas(itemset) > t.\n\nGenerally speaking, meaningfulness (or interestingness) of an itemset is directly correlated to its frequency in the data: intuitively, when a pattern is recurrent in data, then it is candidate to be interesting.\n\nEvery association rule mining algorithm aims to find frequent itemsets by applying meaningfulness measures such as local and global support, respectively lsupport and gsupport.\n\nFrequent itemsets are then used to generate association rules (ARule).\n\nnote: Note\nDespite being implemented as vector, an Itemset behaves like a set. Lookup is faster and the internal sorting of the items is essential to make mining algorithms work.In other words, it is guaranteed that, if two Itemset are created with the same content, regardless of their items order, then their hash is the same.\n\nSee also ARule, gsupport, Item, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Notice that one Itemset could be a set, but actually it is a vector: this is because, often, ARM algorithms need to establish an order between items in itemsets to work efficiently. To convert an Itemset in its conjunctive normla form we simply call toformula.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"toformula","category":"page"},{"location":"getting-started/#ModalAssociationRules.toformula","page":"Getting started","title":"ModalAssociationRules.toformula","text":"toformula(itemset::Itemset)\n\nConjunctive normal form of the Items contained in itemset.\n\nSee also Item, Itemset, SoleLogics.LeftmostConjunctiveForm\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In general, an Itemset behaves exactly like you would expect a Vector{Item} would do. At the end of the day, the only difference is that manipulating an Itemset, for example through push! or union, guarantees the wrapped items always keep the same sorting.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Enough about Itemsets. Our final goal is to produce association rules. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"ARule\ncontent(rule::ARule)\nantecedent(rule::ARule)\nconsequent(rule::ARule)","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARule","page":"Getting started","title":"ModalAssociationRules.ARule","text":"const ARule = Tuple{Itemset,Itemset}\n\nAn association rule represents a strong and meaningful co-occurrence relationship between two Itemsets, callend antecedent and consequent, whose intersection is empty.\n\nExtracting all the ARule \"hidden\" in the data is the main purpose of ARM.\n\nThe general framework always followed by ARM techniques is to, firstly, generate all the frequent itemsets considering a set of MeaningfulnessMeasure specifically tailored to work with Itemsets. Thereafter, all the association rules are generated by testing all the combinations of frequent itemsets against another set of MeaningfulnessMeasure, this time designed to capture how \"reliable\" a rule is.\n\nSee also antecedent, consequent, gconfidence, Itemset, lconfidence, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.content-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.content","text":"content(rule::ARule)::Tuple{Itemset,Itemset}\n\nGetter for the content of an ARule, that is, both its antecedent and its consequent.\n\nSee also antecedent, ARule, consequent, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.antecedent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.antecedent","text":"antecedent(rule::ARule)::Itemset\n\nGetter for rule's antecedent.\n\nSee also antecedent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.consequent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.consequent","text":"consequent(rule::ARule)::Itemset\n\nGetter for rule's consequent.\n\nSee also consequent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To print an ARule enriched with more informations (at the moment, this is everything we need to know), we can use the following.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"analyze(arule::ARule, miner::Miner; io::IO=stdout)","category":"page"},{"location":"getting-started/#ModalAssociationRules.analyze-Tuple{ARule, Miner}","page":"Getting started","title":"ModalAssociationRules.analyze","text":"analyze(arule::ARule, miner::Miner; io::IO=stdout, localities=false)\n\nPrint an ARule analysis to the console, including related meaningfulness measures values.\n\nSee also ARule, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Sometimes we could be interested in writing a function that consider a generic entity obtained through an association rule mining algorithm (frequent itemsets and, of course, association rules). Think about a dictionary mapping some extracted pattern to metadata. We call that generic entity \"an ARM subject\", and the following union type comes in help.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"ARMSubject","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARMSubject","page":"Getting started","title":"ModalAssociationRules.ARMSubject","text":"ARMSubject = Union{ARule,Itemset}\n\nMemoizable types for association rule mining (ARM).\n\nSee also GmeasMemo, GmeasMemoKey, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Measures","page":"Getting started","title":"Measures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To establish when an ARMSubject is interesting, we need meaningfulness measures. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Threshold\nMeaningfulnessMeasure\n\nislocalof(::Function, ::Function)\nlocalof(::Function)\n\nisglobalof(::Function, ::Function)\nglobalof(::Function)","category":"page"},{"location":"getting-started/#ModalAssociationRules.Threshold","page":"Getting started","title":"ModalAssociationRules.Threshold","text":"const Threshold = Float64\n\nThreshold value for meaningfulness measures.\n\nSee also gconfidence, gsupport, lconfidence, lsupport.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.MeaningfulnessMeasure","page":"Getting started","title":"ModalAssociationRules.MeaningfulnessMeasure","text":"const MeaningfulnessMeasure = Tuple{Function, Threshold, Threshold}\n\nIn the classic propositional case scenario where each instance of a Logiset is composed of just a single world (it is a propositional interpretation), a meaningfulness measure is simply a function which measures how many times a property of an Itemset or an ARule is respected across all instances of the dataset.\n\nIn the context of modal logic, where the instances of a dataset are relational objects, every meaningfulness measure must capture two aspects: how much an Itemset or an ARule is meaningful inside an instance, and how much the same object is meaningful across all the instances.\n\nFor this reason, we can think of a meaningfulness measure as a matryoshka composed of an external global measure and an internal local measure. The global measure tests for how many instances a local measure overpass a local threshold. At the end of the process, a global threshold can be used to establish if the global measure is actually meaningful or not. (Note that this generalizes the propositional logic case scenario, where it is enough to just apply a measure across instances.)\n\nTherefore, a MeaningfulnessMeasure is a tuple composed of a global meaningfulness measure, a local threshold and a global threshold.\n\nSee also gconfidence, gsupport, lconfidence, lsupport.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.islocalof-Tuple{Function, Function}","page":"Getting started","title":"ModalAssociationRules.islocalof","text":"islocalof(::Function, ::Function)::Bool\n\nTwin method of isglobalof.\n\nTrait to indicate that a local meaningfulness measure is used as subroutine in a global measure.\n\nFor example, islocalof(lsupport, gsupport) is true, and isglobalof(gsupport, lsupport) is false.\n\nwarning: Warning\nWhen implementing a custom meaningfulness measure, make sure to implement both traits if necessary. This is fundamental to guarantee the correct behavior of some methods, such as getlocalthreshold.\n\nSee also getlocalthreshold, gsupport, isglobalof, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localof-Tuple{Function}","page":"Getting started","title":"ModalAssociationRules.localof","text":"localof(::Function)\n\nReturn the local measure associated with the given one.\n\nSee also islocalof, isglobalof, globalof.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.isglobalof-Tuple{Function, Function}","page":"Getting started","title":"ModalAssociationRules.isglobalof","text":"isglobalof(::Function, ::Function)::Bool\n\nTwin trait of islocalof.\n\nSee also getlocalthreshold, gsupport, islocalof, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalof-Tuple{Function}","page":"Getting started","title":"ModalAssociationRules.globalof","text":"globalof(::Function) = nothing\n\nReturn the global measure associated with the given one.\n\nSee also islocalof, isglobalof, localof.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The following are little data structures which will return useful later, when you will read about how a dataset is mined, looking for ARMSubjects.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"LmeasMemoKey\nLmeasMemo\nGmeasMemoKey\nGmeasMemo","category":"page"},{"location":"getting-started/#ModalAssociationRules.LmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.LmeasMemoKey","text":"const LmeasMemoKey = Tuple{Symbol,ARMSubject,Int64}\n\nKey of a LmeasMemo dictionary. Represents a local meaningfulness measure name (as a Symbol), a ARMSubject, and the number of a dataset instance where the measure is applied.\n\nSee also LmeasMemo, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.LmeasMemo","page":"Getting started","title":"ModalAssociationRules.LmeasMemo","text":"const LmeasMemo = Dict{LmeasMemoKey,Threshold}\n\nAssociation between a local measure of a ARMSubject on a specific dataset instance, and its value.\n\nSee also LmeasMemoKey, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.GmeasMemoKey","text":"const GmeasMemoKey = Tuple{Symbol,ARMSubject}\n\nKey of a GmeasMemo dictionary. Represents a global meaningfulness measure name (as a Symbol) and a ARMSubject.\n\nSee also GmeasMemo, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemo","page":"Getting started","title":"ModalAssociationRules.GmeasMemo","text":"const GmeasMemo = Dict{GmeasMemoKey,Threshold}\n\nAssociation between a global measure of a ARMSubject on a dataset, and its value.\n\nThe reference to the dataset is not explicited here, since GmeasMemo is intended to be used as a memoization structure inside Miner objects, and the latter already knows the dataset they are working with.\n\nSee also GmeasMemoKey, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"What follows is a list of the already built-in meaningfulness measures. In the hands-on section you will learn how to implement your own measure.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"lsupport(itemset::Itemset, logi_instance::LogicalInstance; miner::Union{Nothing,Miner}=nothing)\ngsupport(itemset::Itemset, X::SupportedLogiset, threshold::Threshold; miner::Union{Nothing,Miner}=nothing)\nlconfidence(rule::ARule, logi_instance::LogicalInstance; miner::Union{Nothing,Miner} = nothing)\ngconfidence(rule::ARule, X::SupportedLogiset, threshold::Threshold; miner::Union{Nothing,Miner}=nothing)","category":"page"},{"location":"getting-started/#Mining-structures","page":"Getting started","title":"Mining structures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we are ready to start mining. To do so, we need to create a Miner object. We just need to specify which dataset we are working with, together with a mining function, a vector of initial Items, and the `MeaningfulnessMeasures to establish ARMSubject interestingness.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Miner","category":"page"},{"location":"getting-started/#ModalAssociationRules.Miner","page":"Getting started","title":"ModalAssociationRules.Miner","text":"struct Miner{\n    DATA<:AbstractDataset,\n    MINALGO<:Function,\n    I<:Item,\n    IMEAS<:MeaningfulnessMeasure,\n    RMEAS<:MeaningfulnessMeasure\n}\n    X::DATA                            # target dataset\n    algorithm::MINALGO                    # algorithm used to perform extraction\n    items::Vector{I}\n\n                                    # meaningfulness measures\n    item_constrained_measures::Vector{IMEAS}\n    rule_constrained_measures::Vector{RMEAS}\n\n    freqitems::Vector{Itemset}      # collected frequent itemsets\n    arules::Vector{ARule}           # collected association rules\n\n    lmemo::LmeasMemo                # local memoization structure\n    gmemo::GmeasMemo                # global memoization structure\n\n    powerups::Powerup               # mining algorithm powerups (see documentation)\n    info::Info                      # general informations\nend\n\nMachine learning model interface to perform association rules extraction.\n\nExamples\n\njulia> using ModalAssociationRules\njulia> using SoleData\n\n# Load NATOPS DataFrame\njulia> X_df, y = load_arff_dataset(\"NATOPS\");\n\n# Convert NATOPS DataFrame to a Logiset\njulia> X = scalarlogiset(X_df)\n\n# Prepare some propositional atoms\njulia> p = Atom(ScalarCondition(UnivariateMin(1), >, -0.5))\njulia> q = Atom(ScalarCondition(UnivariateMin(2), <=, -2.2))\njulia> r = Atom(ScalarCondition(UnivariateMin(3), >, -3.6))\n\n# Prepare modal atoms using later relationship - see [`SoleLogics.IntervalRelation`](@ref))\njulia> lp = box(IA_L)(p)\njulia> lq = diamond(IA_L)(q)\njulia> lr = boxlater(r)\n\n# Compose a vector of items, regrouping the atoms defined before\njulia> manual_alphabet = Vector{Item}([p, q, r, lp, lq, lr])\n\n# Create an association rule miner wrapping `fpgrowth` algorithm - see [`fpgrowth`](@ref);\n# note that meaningfulness measures are not explicited and, thus, are defaulted as in the\n# call below.\njulia> miner = Miner(X, fpgrowth(), manual_alphabet)\n\n# Create an association rule miner, expliciting global meaningfulness measures with their\n# local and global thresholds, both for [`Itemset`](@ref)s and [`ARule`](@ref).\njulia> miner = Miner(X, fpgrowth(), manual_alphabet,\n    [(gsupport, 0.1, 0.1)], [(gconfidence, 0.2, 0.2)])\n\n# Consider the dataset and learning algorithm wrapped by `miner` (resp., `X` and `fpgrowth`)\n# Mine the frequent itemsets, that is, those for which item measures are large enough.\n# Then iterate the generator returned by [`mine`](@ref) to enumerate association rules.\njulia> for arule in ModalAssociationRules.mine!(miner)\n    println(miner)\nend\n\nSee also  ARule, apriori, MeaningfulnessMeasure, Itemset, GmeasMemo, LmeasMemo.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let us see which getters and setters are available for Miner.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"dataset(miner::Miner)\nalgorithm(miner::Miner)\nitems(miner::Miner)\n\nmeasures(miner::Miner)\nfindmeasure(miner::Miner,meas::Function; recognizer::Function=islocalof)\nitemsetmeasures(miner::Miner)\nadditemmeas(miner::Miner, measure::MeaningfulnessMeasure)\nrulemeasures(miner::Miner)\naddrulemeas(miner::Miner, measure::MeaningfulnessMeasure)\n\ngetlocalthreshold(miner::Miner, meas::Function)\ngetlocalthreshold_integer(miner::Miner, meas::Function,contributorslength::Int64)\n\ngetglobalthreshold(miner::Miner, meas::Function)\ngetglobalthreshold_integer(miner::Miner, meas::Function, ninstances::Int64)","category":"page"},{"location":"getting-started/#ModalAssociationRules.dataset-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.dataset","text":"dataset(miner::Miner)::AbstractDataset\n\nGetter for the dataset wrapped by miners.\n\nSee SoleBase.AbstractDataset, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.algorithm-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.algorithm","text":"algorithm(miner::Miner)::Function\n\nGetter for the mining algorithm loaded into miner.\n\nSee Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.items-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.items","text":"items(miner::Miner)\n\nGetter for the items of Items loaded into miner.\n\nSee Item, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.measures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.measures","text":"measures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nReturn all the MeaningfulnessMeasures wrapped by miner.\n\nSee also MeaningfulnessMeasure, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.findmeasure-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.findmeasure","text":"findmeasure(\n    miner::Miner,\n    meas::Function;\n    recognizer::Function=islocalof\n)::MeaningfulnessMeasure\n\nRetrieve the MeaningfulnessMeasure associated with meas.\n\nSee also isglobalof, islocalof, MeaningfulnessMeasure, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemsetmeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.itemsetmeasures","text":"itemsetmeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nReturn the MeaningfulnessMeasures tailored to work with Itemsets, loaded inside miner.\n\nSee  Itemset, MeaningfulnessMeasure, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.additemmeas-Tuple{Miner, Tuple{Function, Float64, Float64}}","page":"Getting started","title":"ModalAssociationRules.additemmeas","text":"additemmeas(miner::Miner, measure::MeaningfulnessMeasure)\n\nAdd a new measure to miner's itemsetmeasures.\n\nSee also addrulemeas, Miner, rulemeasures.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.rulemeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.rulemeasures","text":"rulemeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nReturn the MeaningfulnessMeasures tailored to work with ARules, loaded inside miner.\n\nSee Miner, ARule, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.addrulemeas-Tuple{Miner, Tuple{Function, Float64, Float64}}","page":"Getting started","title":"ModalAssociationRules.addrulemeas","text":"addrulemeas(miner::Miner, measure::MeaningfulnessMeasure)\n\nAdd a new measure to miner's rulemeasures.\n\nSee also itemsetmeasures, Miner, rulemeasures.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getlocalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getlocalthreshold","text":"getlocalthreshold(miner::Miner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work locally (that is, analyzing \"the inside\" of a dataset's instances) in miner.\n\nSee Miner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getglobalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getglobalthreshold","text":"getglobalthreshold(miner::Miner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work globally (that is, measuring the behavior of a specific local-measure across all dataset's instances) in miner.\n\nSee Miner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"After a Miner ends mining (we will see how to mine in a second), frequent Itemsets and ARule are accessibles through the getters below.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"freqitems(miner::Miner)\narules(miner::Miner)","category":"page"},{"location":"getting-started/#ModalAssociationRules.freqitems-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.freqitems","text":"freqitems(miner::Miner)\n\nReturn all frequent Itemsets mined by miner.\n\nSee also Itemset, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.arules-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.arules","text":"arules(miner::Miner)\n\nReturn all the ARules mined by miner.\n\nSee also ARule, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Here is how to start mining.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"mine!(miner::Miner)\napply!(miner::Miner, X::AbstractDataset)","category":"page"},{"location":"getting-started/#ModalAssociationRules.mine!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.mine!","text":"mine!(miner::Miner)\n\nSynonym for ModalAssociationRules.apply!(miner, dataset(miner)).\n\nSee also ARule, Itemset, ModalAssociationRules.apply.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.apply!-Tuple{Miner, AbstractDataset}","page":"Getting started","title":"ModalAssociationRules.apply!","text":"apply!(miner::Miner, X::AbstractDataset)\n\nExtract association rules in the dataset referenced by miner, saving the interesting Itemsets inside miner. Then, return a generator of ARules.\n\nSee also ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The mining call returns an ARule generator. Since the extracted rules could be several, it's up to you to collect all the rules in a step or analyze them lazily, collecting them one at a time. You can also call the mining function ignoring it's return value, and then generate the rules later by calling the following.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"generaterules!(miner::Miner)","category":"page"},{"location":"getting-started/#ModalAssociationRules.generaterules!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.generaterules!","text":"generaterules!(miner::Miner; kwargs...)\n\nReturn a generator of ARules, given an already trained Miner.\n\nSee also ARule, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"During both the mining and the rules generation phases, the values returned by MeaningfulnessMeasure applied on a certain ARMSubject are saved (memoized) inside the Miner. Thanks to the methods hereafter, a Miner can avoid useless recomputations.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"localmemo(miner::Miner)\nlocalmemo!(miner::Miner, key::LmeasMemoKey, val::Threshold)\nglobalmemo(miner::Miner)\nglobalmemo!(miner::Miner, key::GmeasMemoKey, val::Threshold)","category":"page"},{"location":"getting-started/#ModalAssociationRules.localmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.localmemo","text":"localmemo(miner::Miner)::LmeasMemo\nlocalmemo(miner::Miner, key::LmeasMemoKey)\n\nReturn the local memoization structure inside miner, or a specific entry if a LmeasMemoKey is provided.\n\nSee also Miner, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject, Int64}, Float64}","page":"Getting started","title":"ModalAssociationRules.localmemo!","text":"localmemo!(miner::Miner, key::LmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the local memoization structure wrapped by miner.\n\nSee also Miner, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.globalmemo","text":"globalmemo(miner::Miner)::GmeasMemo\nglobalmemo(miner::Miner, key::GmeasMemoKey)\n\nReturn the global memoization structure inside miner, or a specific entry if a GmeasMemoKey is provided.\n\nSee also Miner, GmeasMemo, GmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject}, Float64}","page":"Getting started","title":"ModalAssociationRules.globalmemo!","text":"globalmemo!(miner::Miner, key::GmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the global memoization structure wrapped by miner.\n\nSee also Miner, GmeasMemo, GmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Miner-customization","page":"Getting started","title":"Miner customization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A Miner also contains two fields to keep additional informations, those are info and powerups.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The info field in Miner is a dictionary used to store extra informations about the miner, such as statistics about mining. Currently, since the package is still being developed, the info field only contains a flag indicating whether the miner has been used for mining or no.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Info\ninfo(miner::Miner)\ninfo!(miner::Miner, key::Symbol, val)\nhasinfo(miner::Miner, key::Symbol)","category":"page"},{"location":"getting-started/#ModalAssociationRules.Info","page":"Getting started","title":"ModalAssociationRules.Info","text":"const Info = Dict{Symbol,Any}\n\nGeneric setting storage inside Miner structures.\n\nSee also info, info!, hasinfo, Miner.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.info-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.info","text":"info(miner::Miner)::Powerup\ninfo(miner::Miner, key::Symbol)\n\nGetter for the entire additional informations field inside a miner, or one of its specific entries.\n\nSee also Miner, Powerup.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.info!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.info!","text":"info!(miner::Miner, key::Symbol, val)\n\nSetter for the content of a specific field of miner's info.\n\nSee also hasinfo, info, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasinfo-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasinfo","text":"hasinfo(miner::Miner, key::Symbol)\n\nReturn whether miner additional informations field contains an entry key.\n\nSee also Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When writing your own mining algorithm, or when mining with a particular kind of dataset, you might need to specialize the Miner, keeping, for example, custom meta data and data structures. To specialize a Miner, you can fill a Powerup structure to fit your needs.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Powerup\npowerups(miner::Miner)\npowerups!(miner::Miner, key::Symbol, val)\nhaspowerup(miner::Miner, key::Symbol)\ninitpowerups(::Function, ::AbstractDataset)","category":"page"},{"location":"getting-started/#ModalAssociationRules.Powerup","page":"Getting started","title":"ModalAssociationRules.Powerup","text":"const Powerup = Dict{Symbol,Any}\n\nAdditional informations associated with an ARMSubject that can be used to specialize a Miner, augmenting its capabilities.\n\nTo understand how to specialize a Miner, see haspowerup, initpowerups, 'powerups`, powerups!.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.powerups-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.powerups","text":"powerups(miner::Miner)::Powerup\npowerups(miner::Miner, key::Symbol)\n\nGetter for the entire powerups structure currently loaded in miner, or a specific powerup.\n\nSee also haspowerup, initpowerups, Miner, Powerup.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.powerups!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.powerups!","text":"powerups!(miner::Miner, key::Symbol, val)\n\nSetter for the content of a specific field of miner's powerups.\n\nSee also haspowerup, initpowerups, Miner, Powerup.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.haspowerup-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.haspowerup","text":"haspowerup(miner::Miner, key::Symbol)\n\nReturn whether miner powerups field contains an entry key.\n\nSee also Miner, Powerup, powerups.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.initpowerups-Tuple{Function, AbstractDataset}","page":"Getting started","title":"ModalAssociationRules.initpowerups","text":"initpowerups(::Function, ::AbstractDataset)\n\nThis defines how Miner's powerup field is filled to optimize the mining.\n\n\n\n\n\n","category":"method"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = ModalAssociationRules","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"utilities/#man-utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The following utilities often involve performing some combinatoric trick between Itemsets and ARules, and  might be useful to avoid reinventing the wheel.","category":"page"},{"location":"utilities/#Items-and-Itemsets","page":"Utilities","title":"Items and Itemsets","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"combine_items\ngrow_prune\ncoalesce_contributors(itemset::Itemset, miner::Miner; lmeas::Function=lsupport)","category":"page"},{"location":"utilities/#ModalAssociationRules.combine_items","page":"Utilities","title":"ModalAssociationRules.combine_items","text":"combine_items(itemsets::Vector{<:Itemset}, newlength::Integer)\n\nReturn a generator which combines Itemsets from itemsets into new itemsets of length newlength by taking all combinations of two itemsets and joining them.\n\nSee also Itemset.\n\n\n\n\n\ncombine_items(variable::Vector{<:Item}, fixed::Vector{<:Item})\n\nReturn a generator of Itemset, which iterates the combinations of Items in variable and prepend them to fixed vector.\n\nSee also Item, Itemset.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ModalAssociationRules.grow_prune","page":"Utilities","title":"ModalAssociationRules.grow_prune","text":"grow_prune(candidates::Vector{Itemset}, frequents::Vector{Itemset}, k::Integer)\n\nReturn a generator, which yields only the candidates for which every (k-1)-length subset is in frequents.\n\nSee also Itemset.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Association-rules","page":"Utilities","title":"Association rules","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"generaterules(itemsets::Vector{Itemset}, miner::Miner)","category":"page"},{"location":"utilities/#ModalAssociationRules.generaterules-Tuple{Vector{Itemset}, Miner}","page":"Utilities","title":"ModalAssociationRules.generaterules","text":"generaterules(itemsets::Vector{Itemset}, miner::Miner)\n\nRaw subroutine of generaterules!(miner::Miner; kwargs...).\n\nGenerates ARule from the given collection of itemsets and miner.\n\nThe strategy followed is described here at section 2.2.\n\nTo establish the meaningfulness of each association rule, check if it meets the global constraints specified in rulemeasures(miner), and yields the rule if so.\n\nSee also ARule, Miner, Itemset, rulemeasures.\n\n\n\n\n\n","category":"method"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"CurrentModule = ModalAssociationRules","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Pages = [\"modal-generalization.md\"]","category":"page"},{"location":"modal-generalization/#man-modal-generalization","page":"Mining with modal logic","title":"Association rule mining with modal logic","text":"","category":"section"},{"location":"modal-generalization/#New-building-blocks","page":"Mining with modal logic","title":"New building blocks","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"WorldMask\nEnhancedItemset\nConditionalPatternBase","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.WorldMask","page":"Mining with modal logic","title":"ModalAssociationRules.WorldMask","text":"const WorldMask = Vector{Int64}\n\nVector whose i-th position stores how many times a certain MeaningfulnessMeasure applied on a specific Itemsets is true on the i-th world of multiple instances.\n\nIf a single instance is considered, then this acts as a bit mask.\n\nFor example, if we consider 5 instances, each of which containing 3 worlds, then the worlds mask of an itemset could be [5,2,0], meaning that the itemset is always true on the first world of every instance. If we consider the second world, the same itemset is true on it only on two instances. If we consider the third world, then the itemset is never true.\n\nSee also Itemset, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.EnhancedItemset","page":"Mining with modal logic","title":"ModalAssociationRules.EnhancedItemset","text":"const EnhancedItemset = Tuple{Itemset,Int64}\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.ConditionalPatternBase","page":"Mining with modal logic","title":"ModalAssociationRules.ConditionalPatternBase","text":"const ConditionalPatternBase = Vector{EnhancedItemset}\n\nCollection of EnhancedItemset. This is useful to manipulate certain data structures when looking for frequent Itemsets, such as FPTree.\n\nThis is used to implement fpgrowth algorithm as described here.\n\nSee also EnhancedItemset, fpgrowth, FPTree.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#Modal-logic-in-action","page":"Mining with modal logic","title":"Modal logic in action","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Contributors\ncontributors\ncontributors!\n\ninitpowerups(::typeof(fpgrowth), ::AbstractDataset)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ModalAssociationRules","category":"page"},{"location":"#ModalAssociationRules","page":"Home","title":"ModalAssociationRules","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for ModalAssociationRules, a Julia package for mining (modal) association rules in ModalAssociationRules.jl. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install ModalAssociationRules.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModalAssociationRules\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Define your own meaningfulness measures to work with modal datasets, by simply calling the macros lmeas and gmeas.\nConstruct and manipulate Itemsets and Association rules that support custom modal logic, such as Halpern Shoham Interval Logic.\nConfigure and start your mining by easily creating a Miner object, containing the initial items, a list of meaningfulness measures and a reference to the underlying algorithm.\nMine using state-of-the-art algorithm FP-Growth, optimized to leverage parallelization, or simply make your own by following an interface. ","category":"page"},{"location":"#Package-potential-at-a-glance","page":"Home","title":"Package potential at a glance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider a time series dataset obtained by recording the hand movements of an operator. Instead of working it through propositional logic, we decide to segment each time serie in intervals, and we build relationships between intervals through a certain modal logic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After that, consider four meaningfulness measures: local support, global support, local confidence and global confidence. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We want to extract the association rules hidden in the dataset","category":"page"},{"location":"","page":"Home","title":"Home","text":"We choose HS Interval Logic in order to establish relationships such as \"interval X OVERLAPS with Y\", or \"interval Y comes AFTER X\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"An association rule supporting , shaped starting from a temporal dataset talking about hand gestures, segmented into intervals, could be the one below. It means if in a time interval the vertical distance between right hand middle finger tip and thumb tip is negative, then some specific meaningfulness measures hold while","category":"page"},{"location":"","page":"Home","title":"Home","text":"(max[ΔY[Hand tip r and thumb r]] ≤ 0.0) => ([O]min[Y[Hand tip r]] ≥ -0.5)","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModalAssociationRules.jl lives in the context of Sole.jl, an open-source framework for symbolic machine learning, originally designed for machine learning based on modal logics (see Eduard I. Stan's PhD thesis 'Foundations of Modal Symbolic Learning' here).","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleBase.jl\nSoleLogics.jl\nMultiData.jl\nSoleModels.jl\nSoleData.jl\nSoleFeatures.jl \nSolePostHoc.jl","category":"page"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"CurrentModule = ModalAssociationRules","category":"page"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Pages = [\"hands-on.md\"]","category":"page"},{"location":"hands-on/#hands-on","page":"Hands on","title":"Hands-on","text":"","category":"section"},{"location":"hands-on/#A-real-case-usage-scenario","page":"Hands on","title":"A real case usage scenario","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Write here a little lesson, maybe with a jupyter notebook like @giopaglia did.","category":"page"},{"location":"hands-on/#Implementing-a-new-meaningfulness-measure","page":"Hands on","title":"Implementing a new meaningfulness measure","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Local and global lift.","category":"page"},{"location":"hands-on/#Writing-a-new-mining-algorithm","page":"Hands on","title":"Writing a new mining algorithm","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Write a new mining algorithm (eclat)","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"CurrentModule = ModalAssociationRules","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Pages = [\"algorithms.md\"]","category":"page"},{"location":"algorithms/#algorithms","page":"Available algorithms","title":"Available algorithms","text":"","category":"section"},{"location":"algorithms/#Candidate-generation-based","page":"Available algorithms","title":"Candidate generation based","text":"","category":"section"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"apriori(miner::Miner, X::AbstractDataset; verbose::Bool=false)","category":"page"},{"location":"algorithms/#ModalAssociationRules.apriori-Tuple{Miner, AbstractDataset}","page":"Available algorithms","title":"ModalAssociationRules.apriori","text":"apriori(miner::Miner, X::AbstractDataset; verbose::Bool=true)::Nothing\n\nApriori algorithm, as described here but generalized to also work with modal logic.\n\nSee also Miner, SoleBase.AbstractDataset.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#TreeProjection-based","page":"Available algorithms","title":"TreeProjection based","text":"","category":"section"},{"location":"algorithms/#FPGrowth","page":"Available algorithms","title":"FPGrowth","text":"","category":"section"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"fpgrowth(miner::Miner, X::AbstractDataset; verbose::Bool=false)","category":"page"},{"location":"algorithms/#ModalAssociationRules.fpgrowth-Tuple{Miner, AbstractDataset}","page":"Available algorithms","title":"ModalAssociationRules.fpgrowth","text":"fpgrowth(miner::Miner, X::AbstractDataset; verbose::Bool=true)::Nothing\n\nFP-Growth algorithm, as described here but generalized to also work with modal logic.\n\nSee also Miner, FPTree, HeaderTable, SoleBase.AbstractDataset\n\n\n\n\n\n","category":"method"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on two data structures, FPTree and HeaderTable. To know more about them and their, please refer to the documentation here data-structures.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on the following two routines.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"patternbase(item::Item, htable::HeaderTable, miner::Miner)\nprojection(pbase::ConditionalPatternBase, miner::Miner)","category":"page"},{"location":"algorithms/#ModalAssociationRules.patternbase-Tuple{Formula, HeaderTable, Miner}","page":"Available algorithms","title":"ModalAssociationRules.patternbase","text":"patternbase(item::Item, htable::HeaderTable, miner::Miner)::ConditionalPatternBase\n\nRetrieve the ConditionalPatternBase of fptree based on item.\n\nThe conditional pattern based on a FPTree is the set of all the paths from the tree root to nodes containing item (not included). Each of these paths is represented by an EnhancedItemset.\n\nThe EnhancedItemsets in the returned ConditionalPatternBase are sorted decreasingly by gsupport.\n\nSee also Miner, ConditionalPatternBase, contributors, EnhancedItemset, fpgrowth, FPTree, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ModalAssociationRules.projection-Tuple{Vector{Tuple{Itemset, Int64}}, Miner}","page":"Available algorithms","title":"ModalAssociationRules.projection","text":"function projection(pbase::ConditionalPatternBase, miner::Miner)\n\nReturn respectively a FPTree and a HeaderTable starting from pbase. A Miner must be provided to guarantee the generated header table internal state is OK, that is, its items are sorted decreasingly by gsupport.\n\nSee also ConditionalPatternBase, FPTree, gsupport, HeaderTable, Miner.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Also, FPGrowth requires the Miner to remember the Contributors associated with the extracted frequent itemsets. To add this functionality, we can define a new dispatch of initpowerups: it is automatically considered to enrich the miner, while building it together with fpgrowth as mining algorithm.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"initpowerups(::typeof(fpgrowth), ::AbstractDataset)","category":"page"},{"location":"algorithms/#ModalAssociationRules.initpowerups-Tuple{typeof(fpgrowth), AbstractDataset}","page":"Available algorithms","title":"ModalAssociationRules.initpowerups","text":"initpowerups(::typeof(fpgrowth), ::AbstractDataset)::Powerup\n\nPowerups suite for FP-Growth algorithm. When initializing a Miner with fpgrowth algorithm, this defines how miner's powerup field is filled to optimize the mining. See also haspowerup, powerup.\n\n\n\n\n\n","category":"method"}]
}
