var documenterSearchIndex = {"docs":
[{"location":"data-structures/","page":"Built-in data structures","title":"Built-in data structures","text":"Pages = [\"data-structures.md\"]","category":"page"},{"location":"data-structures/#data-structures","page":"Built-in data structures","title":"Built in data structures","text":"","category":"section"},{"location":"data-structures/#FPTree","page":"Built-in data structures","title":"FPTree","text":"","category":"section"},{"location":"data-structures/#ModalAssociationRules.FPTree","page":"Built-in data structures","title":"ModalAssociationRules.FPTree","text":"mutable struct FPTree\n    content::Union{Nothing,Item}        # Item contained in this node (nothing if root)\n\n    parent::Union{Nothing,FPTree}       # parent node\n    const children::Vector{FPTree}      # children nodes\n\n    count::Integer                        # number of equal Items this node represents\n\n    link::Union{Nothing,FPTree}         # link to another FPTree root\nend\n\nFundamental data structure used in FP-Growth algorithm. Essentialy, an FPTree is a prefix tree where a root-leaf path represent an Itemset.\n\nConsider the Itemsets sorted by gsupport of their items. An FPTree is such that the common Items-prefix shared by different Itemsets is not stored multiple times.\n\nThis implementation generalizes the propositional logic case scenario to modal logic; given two Itemsets sharing a Item prefix, the worlds in which they are true is accumulated.\n\ninfo: Info\nDid you notice? One FPTree structure contains all the information needed to construct an EnhancedItemset. This is crucial to generate new FPTrees during fpgrowth algorithm, via building ConditionalPatternBases iteratively while avoiding visiting the dataset over and over again.\n\nSee also EnhancedItemset, fpgrowth, gsupport, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.content-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.content","text":"content(fptree::FPTree)::Union{Nothing,Item}\n\nGetter for the Item (possibly empty) wrapped by fptree.\n\nSee also content!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.parent","text":"parent(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for the parent FPTrees of fptree.\n\nSee also FPTree, parent!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent!-Tuple{FPTree, Union{Nothing, FPTree}}","page":"Built-in data structures","title":"ModalAssociationRules.parent!","text":"parent!(fptree::FPTree, item::Union{Nothing,FPTree})\n\nSetter for fptree's parent FPTree.\n\nSee also FPTree, parent.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.children","text":"children(fptree::FPTree)::Vector{FPTree}\n\nGetter for the list of children FPTrees of fptree.\n\nSee also children!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.children!","text":"children!(fptree::FPTree, child::FPTree)\n\nAdd a new FPTree to fptree's children vector.\n\nwarning: Warning\nThis method forces the new children to be added: it is a caller's responsability to check whether child is not already a children of fptree and, if so, handle the case. This check is performed, for example, in grow!.\n\nnote: Note\nThis method already sets the new children parent to fptree itself.\n\nSee also children, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.count-Tuple{FPTree}","page":"Built-in data structures","title":"Base.count","text":"Base.count(fptree::FPTree)::Integer\n\nGetter for the fptree internal counter. Essentially, it represents the number of overlappings Item which ended up in fptree node during the building process of the tree itself.\n\nSee also count!, FPTree, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.count!-Tuple{FPTree, Integer}","page":"Built-in data structures","title":"ModalAssociationRules.count!","text":"count!(fptree::FPTree, newcount::Integer)\n\nSetter for fptree's internal counter to a fixed value newcount.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.addcount!-Tuple{FPTree, Integer}","page":"Built-in data structures","title":"ModalAssociationRules.addcount!","text":"addcount!(fptree::FPTree, newcount::Integer)\n\nAdd newcount to fptree's internal counter.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link","text":"link(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for fptree's next brother FPTree. fptree's brotherhood is the set of all the FPTree whose content is exactly fptree.content.\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link!","text":"function link!(from::FPTree, to::FPTree)\n\nEstablish a link between two FPTrees. If the starting tree is already linked with something, the already existing link are followed until a new \"empty-linked\" FPTree is found.\n\nSee also follow, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.follow","text":"function follow(fptree::FPTree)::Union{Nothing,FPTree}\n\nFollow fptree link to (an internal node of) another FPTree.\n\nSee also FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.islist-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.islist","text":"islist(fptree::FPTree)::Bool\n\nReturn true if every subtree in fptree has exactly 0 or 1 children.\n\nSee also FPTree\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#HeaderTable","page":"Built-in data structures","title":"HeaderTable","text":"","category":"section"},{"location":"data-structures/#ModalAssociationRules.HeaderTable","page":"Built-in data structures","title":"ModalAssociationRules.HeaderTable","text":"struct HeaderTable\n    items::Vector{Item}\n    link::Dict{Item,Union{Nothing,FPTree}}\nend\n\nUtility data structure used to fastly access FPTree internal nodes.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.items-Tuple{HeaderTable}","page":"Built-in data structures","title":"ModalAssociationRules.items","text":"items(htable::HeaderTable)::Vector{Item}\n\nGetter for the Items loaded inside htable.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{HeaderTable}","page":"Built-in data structures","title":"ModalAssociationRules.link","text":"link(htable::HeaderTable)\nlink(htable::HeaderTable, item::Item)\n\nGetter for the link structure wrapped by htable, or one of its specific entry.\n\nThe link structure is, essentially, a dictionary associating an Item to a specific FPTree.\n\nSee also FPTree, HeaderTable, Item, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{HeaderTable, Item}","page":"Built-in data structures","title":"ModalAssociationRules.follow","text":"function follow(htable::HeaderTable, item::Item)::Union{Nothing,FPTree}\n\nFollow htable link to (an internal node of) a FPTree.\n\nSee also FPTree, HeaderTable, Item, link, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{HeaderTable, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link!","text":"function link!(htable::HeaderTable, fptree::FPTree)\n\nEstablish a link towards fptree, following the entry in htable corresponding to the content of fptree.\n\nSee also content, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.checksanity!-Tuple{HeaderTable, Miner}","page":"Built-in data structures","title":"ModalAssociationRules.checksanity!","text":"function checksanity!(htable::HeaderTable, miner::AbstractMiner)::Bool\n\nCheck if htable internal state is correct, that is, its items are sorted decreasingly by global support. If items are already sorted, return true; otherwise, sort them and return false.\n\nSee also AbstractMiner, gsupport, HeaderTable, items.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.reverse-Tuple{HeaderTable}","page":"Built-in data structures","title":"Base.reverse","text":"Base.reverse(htable::HeaderTable)\n\nIterator on htable wrapped Items, in reverse order.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In this introductory section you will learn about the main building blocks of ModalAssociationRules.jl.  Also if a good picture about association rule mining (ARM, from now onwards) is given during the documentation, to make the most out of this guide we suggest to read the following articles:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"association rule mining introduction and Apriori algorithm\nFPGrowth algorithm","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Those up above introduce two important algorithms, which are also built-in in this package. Moreover, the latter one is the state-of-the-art in the field of ARM.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Further on in the documentation, the potential of ModalAssociationRules.jl will emerge: this package's raison d'être is to generalize the already existing ARM algorithms to modal logics, which are more expressive than propositional one and computationally less expensive than first order logic. If you are new to Sole.jl and you want to learn more about modal logic, please have a look at SoleLogics.jl for a general overview on the topic, or follow this documentation and return to this link if needed.","category":"page"},{"location":"getting-started/#Core-definitions","page":"Getting started","title":"Core definitions","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"One Item is just a logical formula, which can be interpreted by a certain model. At the moment, here, we don't care about how models are represented by Sole.jl under the hood, or how the checking algorithm works: what matters is that Items are manipulated by ARM algorithms, which try to find which conjunctions between items are most statistically significant.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Item","page":"Getting started","title":"ModalAssociationRules.Item","text":"struct Item{F<:SoleLogics.Formula}\n    formula::F\nend\n\nFundamental type in the context of association rule mining.\n\nThe name Item comes from the classical association rule mining jargon, but it is simply a wrapper around a logical formula, whose truth value can be checked on a model. To know more about logical formulas, see SoleLogics.Formula.\n\nSee also ARule, gconfidence, Itemset, MeaningfulnessMeasure, SoleLogics.Formula.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.Itemset","page":"Getting started","title":"ModalAssociationRules.Itemset","text":"const Itemset{I<:Item} = Vector{I}\n\nVector collecting multiple Items.\n\nSemantically, Itemsets represent Items (that is, formulas) conjunctions.\n\nnote: Note\nIn the context of association rule mining, interesting itemsets are manipulated to discover interesting relations between Items, in the form of association rules (ARule).Interestingness is established through a set of MeaningfulnessMeasure.\n\ndetails: Details\nItemsets are implemented as a vector for two reasons:lookup is fasterwhen the collection is small (an itemset is unlikely to consist of more than 100 items);most of the time, we want to keep an ordering between items while searching forinteresting itemsets.\n\nExamples\n\njulia> p = ScalarCondition(VariableMin(1), >, 1.0)  |> Atom |> Item\nmin[V1] > 1.0\njulia> q = ScalarCondition(VariableMin(2), >=, 0.0) |> Atom |> Item\nmin[V2] ≥ 0.0\n\njulia> pq = Itemset([p,q])\njulia> qp = Itemset([q,p])\n\njulia> pq == qp\ntrue\njulia> pq === qp\nfalse\n\njulia> r = ScalarCondition(VariableMax(3), <=, 2.0) |> Atom |> Item\nmax[V3] ≤ 2.0\njulia> pqr = [pq; r];\n\njulia> pq in pqr\ntrue\n\njulia> formula(pqr) |> syntaxstring\n\"(min[V1] > 1.0) ∧ (min[V2] ≥ 0.0) ∧ (max[V3] ≤ 2.0)\"\n\nSee also ARule, formula, gsupport, Item, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Notice that one Itemset could be a set, but actually it is a vector: this is because, often, ARM algorithms need to establish an order between items in itemsets to work efficiently. To convert an Itemset in its conjunctive normla form we simply call formula.","category":"page"},{"location":"getting-started/#ModalAssociationRules.formula","page":"Getting started","title":"ModalAssociationRules.formula","text":"formula(item::Item{F}) where {F}\n\nSee also Item, SoleLogics.Formula.\n\n\n\n\n\nformula(itemset::Itemset)::SoleLogics.LeftmostConjunctiveForm\n\nConjunctive normal form of the Items contained in itemset.\n\nSee also Item, Itemset, SoleLogics.LeftmostConjunctiveForm\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In general, an Itemset behaves exactly like you would expect a Vector{Item} would do. At the end of the day, the only difference is that manipulating an Itemset, for example through push! or union, guarantees the wrapped items always keep the same sorting.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Enough about Itemsets. Our final goal is to produce association rules. ","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARule","page":"Getting started","title":"ModalAssociationRules.ARule","text":"const ARule = Tuple{Itemset,Itemset}\n\nAn association rule represents a frequent and meaningful co-occurrence relationship of the form \"X ⇒ Y\", between two Itemsets X and Y, where X ∩ Y = ∅, respectively called antecedent and consequent.\n\nnote: Note\nExtracting all the ARule \"hidden\" in the data is the main purpose of association rule mining (ARM).Given an itemset Z containing atleast two Items (|Z| ≥ 2), it can be partitioned in two (sub)itemsets X and Y; trying all the possible binary partitioning of Z is a systematic way to generate ARules.The general framework always followed by ARM techniques is to, firstly, generate all the frequent itemsets considering a set of MeaningfulnessMeasure specifically tailored to work with Itemsets.Thereafter, all the association rules are generated by testing all the combinations of frequent itemsets against another set of MeaningfulnessMeasure, this time designed to capture how interesting a rule is.\n\nSee also antecedent, consequent, gconfidence, Itemset, lconfidence, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.content-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.content","text":"content(rule::ARule)::Tuple{Itemset,Itemset}\n\nGetter for the content of an ARule, that is, both its antecedent and its consequent.\n\nSee also antecedent, ARule, consequent, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.antecedent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.antecedent","text":"antecedent(rule::ARule)::Itemset\n\nGetter for rule's antecedent.\n\nSee also antecedent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.consequent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.consequent","text":"consequent(rule::ARule)::Itemset\n\nGetter for rule's consequent.\n\nSee also consequent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To print an ARule enriched with more informations (at the moment, this is everything we need to know), we can use the following.","category":"page"},{"location":"getting-started/#ModalAssociationRules.arule_analysis-Tuple{ARule, Miner}","page":"Getting started","title":"ModalAssociationRules.arule_analysis","text":"arule_analysis(arule::ARule, miner::Miner; io::IO=stdout, localities=false)\n\nSee also arule_analysis(::Arule, ::AbstractMiner), ARule, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Sometimes we could be interested in writing a function that consider a generic entity obtained through an association rule mining algorithm (frequent itemsets and, of course, association rules). Think about a dictionary mapping some extracted pattern to metadata. We call that generic entity \"an ARM subject\", and the following union type comes in help.","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARMSubject","page":"Getting started","title":"ModalAssociationRules.ARMSubject","text":"ARMSubject = Union{ARule,Itemset}\n\nEach entity mined through an association rule mining algorithm.\n\nSee also ARule, GmeasMemo, GmeasMemoKey, Itemset, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Measures","page":"Getting started","title":"Measures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To establish when an ARMSubject is interesting, we need meaningfulness measures. ","category":"page"},{"location":"getting-started/#ModalAssociationRules.Threshold","page":"Getting started","title":"ModalAssociationRules.Threshold","text":"const Threshold = Float64\n\nThreshold value type for MeaningfulnessMeasures.\n\nSee also gconfidence, gsupport, lconfidence, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.MeaningfulnessMeasure","page":"Getting started","title":"ModalAssociationRules.MeaningfulnessMeasure","text":"const MeaningfulnessMeasure = Tuple{Function, Threshold, Threshold}\n\nTo fully understand this description, we suggest reading this article.\n\nIn the classic propositional case scenario, we can think each instance as a propositional interpretation, or equivalently, as a Kripke frame containing only one world. In this setting, a meaningfulness measure indicates how many times a specific property of an Itemset (or an ARule) is satisfied.\n\nThe most important meaningfulness measure is support, defined as \"the number of instances in a dataset that satisfy an itemset\" (it is defined similarly for association rules, where we consider the itemset obtained by combining both rule's antecedent and consequent). Other meaningfulness measures can be defined in function of support.\n\nIn the context of modal logic, where the instances of a dataset are relational objects called Kripke frames, every meaningfulness measure must capture two aspects: how much an Itemset or an ARule is meaningful within an instance, and how much the same object is meaningful across all the instances, that is, how many times it resulted meaningful within an instance. Note that those two aspects coincide in the propositional scenario.\n\nWhen a meaningfulness measure is applied locally within an instance, it is said to be \"local\". Otherwise, it is said to be \"global\". For example, local support is defined as \"the number of worlds within an instance, which satisfy an itemset\". To define global support we need to define a minimum local support threshold sl which is a real number between 0 and 1. Now, we can say that global support is \"the number of instances for which local support overpassed the minimum local support threshold\".\n\nAs in the propositional setting, more meaningfulness measures can be defined starting from support, but now they must respect the local/global dichotomy.\n\nWe now have all the ingredients to understand this type definition. A MeaningfulnessMeasure is a tuple composed of a global meaningfulness measure, a local threshold used internally, and a global threshold we would like our itemsets (rules) to overpass.\n\nSee also gconfidence, gsupport, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.islocalof-Tuple{Function, Function}","page":"Getting started","title":"ModalAssociationRules.islocalof","text":"islocalof(::Function, ::Function)::Bool\n\nTwin method of isglobalof.\n\nTrait to indicate that a local meaningfulness measure is used as subroutine in a global measure.\n\nFor example, islocalof(lsupport, gsupport) is true, and isglobalof(gsupport, lsupport) is false.\n\nwarning: Warning\nWhen implementing a custom meaningfulness measure, make sure to implement both islocalof/isglobalof and localof/globalof. This is fundamental to guarantee the correct behavior of some methods, such as getlocalthreshold. Alternatively, you can simply use the macro @linkmeas.\n\nSee also getlocalthreshold, gsupport, isglobalof, linkmeas, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localof-Tuple{Function}","page":"Getting started","title":"ModalAssociationRules.localof","text":"localof(::Function)::Union{Nothing,MeaningfulnessMeasure}\n\nReturn the local measure associated with the given one.\n\nSee also islocalof, isglobalof, globalof, linkmeas.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.isglobalof-Tuple{Function, Function}","page":"Getting started","title":"ModalAssociationRules.isglobalof","text":"isglobalof(::Function, ::Function)::Bool\n\nTwin trait of islocalof.\n\nSee also getlocalthreshold, gsupport, islocalof, linkmeas, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalof-Tuple{Function}","page":"Getting started","title":"ModalAssociationRules.globalof","text":"globalof(::Function)::Union{Nothing,MeaningfulnessMeasure} = nothing\n\nReturn the global measure associated with the given one.\n\nSee also linkmeas, islocalof, isglobalof, localof.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The following are little data structures which will return useful later, when you will read about how a dataset is mined, looking for ARMSubjects.","category":"page"},{"location":"getting-started/#ModalAssociationRules.LmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.LmeasMemoKey","text":"const LmeasMemoKey = Tuple{Symbol,ARMSubject,Integer}\n\nKey of a LmeasMemo dictionary. Represents a local meaningfulness measure name (as a Symbol), a ARMSubject, and the number of a dataset instance where the measure is applied.\n\nSee also ARMSubject, LmeasMemo, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.LmeasMemo","page":"Getting started","title":"ModalAssociationRules.LmeasMemo","text":"const LmeasMemo = Dict{LmeasMemoKey,Threshold}\n\nAssociation between a local measure of a ARMSubject on a specific dataset instance, and its value.\n\nSee also ARMSubject, LmeasMemo, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.GmeasMemoKey","text":"const GmeasMemoKey = Tuple{Symbol,ARMSubject}\n\nKey of a GmeasMemo dictionary. Represents a global meaningfulness measure name (as a Symbol) and a ARMSubject.\n\nSee also ARMSubject, GmeasMemo, gconfidence, gsupport.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemo","page":"Getting started","title":"ModalAssociationRules.GmeasMemo","text":"const GmeasMemo = Dict{GmeasMemoKey,Threshold}\n\nAssociation between a global measure of a ARMSubject on a dataset, and its value.\n\nThe reference to the dataset is not explicited here, since GmeasMemo is intended to be used as a memoization structure inside Miner objects, and the latter already knows the dataset they are working with.\n\nSee also GmeasMemoKey, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"What follows is a list of the already built-in meaningfulness measures. In the Hands on section you will learn how to implement your own measure.","category":"page"},{"location":"getting-started/#Mining-structures","page":"Getting started","title":"Mining structures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we are ready to start mining. To do so, we need to create a Miner object. We just need to specify which dataset we are working with, together with a mining function, a vector of initial Items, and the `MeaningfulnessMeasures to establish ARMSubject interestingness.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Miner","page":"Getting started","title":"ModalAssociationRules.Miner","text":"struct Miner{\n    D<:MineableData,\n    I<:Item\n} <: AbstractMiner\n    X::D                            # target dataset\n\n    algorithm::Function             # algorithm used to perform extraction\n\n    items::Vector{I}                # alphabet\n\n    # meaningfulness measures\n    itemset_constrained_measures::Vector{<:MeaningfulnessMeasure}\n    arule_constrained_measures::Vector{<:MeaningfulnessMeasure}\n\n    freqitems::Vector{Itemset}      # collected frequent itemsets\n    arules::Vector{ARule}           # collected association rules\n\n    localmemo::LmeasMemo            # local memoization structure\n    globalmemo::GmeasMemo           # global memoization structure\n\n    worldfilter::Union{Nothing,WorldFilter}       # metarules about world filterings\n    itemset_policies::Vector{<:Function}   # metarules about itemsets mining\n    arule_policies::Vector{<:Function}     # metarules about arules mining\n\n    miningstate::MiningState        # mining algorithm miningstate (see documentation)\n\n    info::Info                      # general informations\n\n    # locks on memoization and miningstate structures\n    lmemolock::ReentrantLock\n    gmemolock::ReentrantLock\n    miningstatelock::ReentrantLock\nend\n\nConcrete AbstractMiner containing both the data, the logic and the parameterization to perform association rule mining in the modal setting.\n\nExamples\n\njulia> using ModalAssociationRules\njulia> using SoleData\n\n# Load NATOPS DataFrame\njulia> X_df, y = load_NATOPS();\n\n# Convert NATOPS DataFrame to a Logiset\njulia> X = scalarlogiset(X_df)\n\n# Prepare some propositional atoms\njulia> p = Atom(ScalarCondition(VariableMin(1), >, -0.5))\njulia> q = Atom(ScalarCondition(VariableMin(2), <=, -2.2))\njulia> r = Atom(ScalarCondition(VariableMin(3), >, -3.6))\n\n# Prepare modal atoms using later relationship - see [`SoleLogics.IntervalRelation`](@ref))\njulia> lp = box(IA_L)(p)\njulia> lq = diamond(IA_L)(q)\njulia> lr = box(IA_L)(r)\n\n# Compose a vector of items, regrouping the atoms defined before\njulia> my_alphabet = Vector{Item}([p, q, r, lp, lq, lr])\n\n# Establish which meaningfulness measures you want to define the notion of itemset and\n# association rule holding on an instance and on a modal dataset\njulia> my_itemsetmeasures = [(gsupport, 0.1, 0.1)]\njulia> my_rulemeasures = [(gconfidence, 0.1, 0.1)]\n\n# (optional) Establish a filter to iterate the worlds in a generic modal instance\njulia> my_worldfilter = SoleLogics.FunctionalWorldFilter(\n        x -> length(x) >= 3 && length(x) <= 10, Interval{Int}\n    )\n\n# (optional) Establish a policy to further restrict itemsets that can be considered frequent\njulia> my_itemset_policies = [islimited_length_itemset()]\n\n# (optional) Establish a policy to further restrict rules that can be considered\n# association rules\njulia> my_arule_policies = [\n        islimited_length_arule(), isanchored_arule(), isheterogeneous_arule()\n    ]\n\n# Create an association rule miner wrapping `fpgrowth` algorithm - see [`fpgrowth`](@ref);\njulia> miner = Miner(X, fpgrowth, my_alphabet,\n        my_itemsetmeasures, my_rulemeasures,\n        worldfilter=my_worldfilter,\n        itemset_policies=my_itemset_policies,\n        arule_policies=my_arule_policies\n    )\n\n# We mine using mine!\n# (optional) We could pass kwargs to forward them to the mining algorithm\njulia> mine!(miner)\n\n# Print all the mined association rules\njulia> for arule in generaterules(miner)\n    println(arule)\nend\n\nSee also  ARule, Bulldozer, MeaningfulnessMeasure, Info, isanchored_arule, isheterogeneous_arule, islimited_length_arule(), islimited_length_itemset(), Item, Itemset, GmeasMemo, LmeasMemo, MiningState, SoleLogics.WorldFilter.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let us see which getters and setters are available for Miner.","category":"page"},{"location":"getting-started/#ModalAssociationRules.algorithm-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.algorithm","text":"algorithm(miner::Miner)::Function\n\nSee algorithm(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.items-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.items","text":"items(miner::Miner)\n\nSee items(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.measures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.measures","text":"measures(miner::AbstractMiner)::Vector{<:MeaningfulnessMeasure}\n\nReturn all the MeaningfulnessMeasures wrapped by miner.\n\nSee also AbstractMiner, itemsetmeasures, MeaningfulnessMeasure, arulemeasures.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.findmeasure-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.findmeasure","text":"findmeasure(\n    miner::AbstractMiner,\n    meas::Function;\n    recognizer::Function=islocalof\n)::MeaningfulnessMeasure\n\nRetrieve the MeaningfulnessMeasure associated with meas within miner.\n\nSee also isglobalof, islocalof, MeaningfulnessMeasure, AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemsetmeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.itemsetmeasures","text":"itemsetmeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nSee [itemsetmeasures(::AbstractMiner)]\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.arulemeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.arulemeasures","text":"arulemeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nSee arulemeasures(miner::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getlocalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getlocalthreshold","text":"getlocalthreshold(miner::AbstractMiner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work locally (that is, analyzing \"the inside\" of a dataset's instances) in miner.\n\nSee AbstractMiner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getglobalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getglobalthreshold","text":"getglobalthreshold(miner::AbstractMiner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work globally (that is, measuring the behavior of a specific local-measure across all dataset's instances) in miner.\n\nSee AbstractMiner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"After a Miner ends mining (we will see how to mine in a second), frequent Itemsets and ARule are accessibles through the getters below.","category":"page"},{"location":"getting-started/#ModalAssociationRules.freqitems-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.freqitems","text":"freqitems(miner::Miner)\n\nSee freqitems(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.arules-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.arules","text":"arules(miner::Miner) See arules(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Here is how to start mining.","category":"page"},{"location":"getting-started/#ModalAssociationRules.mine!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.mine!","text":"mine!(miner::AbstractMiner; kwargs...)\n\nSynonym for `apply!.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The mining call returns an ARule generator. Since the extracted rules could be several, it's up to you to collect all the rules in a step or arule_analysis them lazily, collecting them one at a time. You can also call the mining function ignoring it's return value, and then generate the rules later by calling the following.","category":"page"},{"location":"getting-started/#ModalAssociationRules.generaterules!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.generaterules!","text":"generaterules!(miner::Miner)\n\nSee generaterules!(::Miner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"During both the mining and the rules generation phases, the values returned by MeaningfulnessMeasure applied on a certain ARMSubject are saved (memoized) inside the Miner. Thanks to the methods hereafter, a Miner can avoid useless recomputations.","category":"page"},{"location":"getting-started/#ModalAssociationRules.localmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.localmemo","text":"localmemo(miner::Miner)::LmeasMemo\n\nSee localmemo(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject, Integer}, Float64}","page":"Getting started","title":"ModalAssociationRules.localmemo!","text":"localmemo!(miner::Miner, key::LmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the local memoization structure wrapped by miner.\n\nSee also Miner, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.globalmemo","text":"globalmemo(miner::Miner)::GmeasMemo\n\nSee globalmemo(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject}, Float64}","page":"Getting started","title":"ModalAssociationRules.globalmemo!","text":"globalmemo!(miner::Miner, key::GmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the global memoization structure wrapped by miner.\n\nSee also Miner, GmeasMemo, GmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Miner-customization","page":"Getting started","title":"Miner customization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A Miner also contains two fields to keep additional informations, those are info and miningstate.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The info field in Miner is a dictionary used to store extra informations about the miner, such as statistics about mining. Currently, since the package is still being developed, the info field only contains a flag indicating whether the miner has been used for mining or no.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Info","page":"Getting started","title":"ModalAssociationRules.Info","text":"const Info = Dict{Symbol,Any}\n\nStorage reserved to metadata about mining (e.g., execution time).\n\nSee also info, info!, hasinfo, Miner.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.info-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.info","text":"info(miner::Miner)::Info = miner.info\n\nGetter for miner's structure holding meta informations about mining.\n\nSee also Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.info!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.info!","text":"info!(miner::Miner, key::Symbol, val)\n\nSetter for miner's metadata.\n\nSee also hasinfo, info, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasinfo-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasinfo","text":"hasinfo(miner::AbstractMiner, key::Symbol)\n\nReturn whether miner additional informations field contains an entry key.\n\nSee also AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When writing your own mining algorithm, or when mining with a particular kind of dataset, you might need to specialize the Miner, keeping, for example, custom meta data and data structures. To specialize a Miner, you can fill a MiningState structure to fit your needs.","category":"page"},{"location":"getting-started/#ModalAssociationRules.MiningState","page":"Getting started","title":"ModalAssociationRules.MiningState","text":"const MiningState = Dict{Symbol,Any}\n\nAdditional informations associated with an ARMSubject that can be used to specialize any concrete type deriving from AbstractMiner, thus augmenting its capabilities.\n\nTo understand how to specialize a Miner, see hasminingstate, initminingstate, 'miningstate`, miningstate!.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.miningstate-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.miningstate","text":"miningstate(miner::Miner)\n\nSee miningstate(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstate!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.miningstate!","text":"miningstate!(miner::Miner, key::Symbol, val)\n\nSetter for the content of a specific field of miner's miningstate.\n\nSee also Miner, hasminingstate, initminingstate, MiningState.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasminingstate-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasminingstate","text":"hasminingstate(miner::Miner, key::Symbol)\n\nReturn whether miner miningstate contains a field key.\n\nSee also Miner, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.initminingstate-Tuple{Function, AbstractDataset}","page":"Getting started","title":"ModalAssociationRules.initminingstate","text":"initminingstate(::Function, ::MineableData)\n\nThis trait defines how to initialize the MiningState structure of an AbstractMiner, in order to customize it to your needings depending on a specific function/data pairing.\n\nSee ealso hasminingstate, AbstractMiner, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"utilities/#man-utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The following utilities often involve performing some combinatoric trick between Itemsets and ARules, and  might be useful to avoid reinventing the wheel.","category":"page"},{"location":"utilities/#Items-and-Itemsets","page":"Utilities","title":"Items and Itemsets","text":"","category":"section"},{"location":"utilities/#ModalAssociationRules.combine_items","page":"Utilities","title":"ModalAssociationRules.combine_items","text":"combine_items(itemsets::AbstractVector{<:Itemset}, newlength::Integer)\n\nReturn a generator which combines Itemsets from itemsets into new itemsets of length newlength by taking all combinations of two itemsets and joining them.\n\nSee also Itemset.\n\n\n\n\n\ncombine_items(variable::AbstractVector{<:Item}, fixed::AbstractVector{<:Item})\n\nReturn a generator of Itemset, which iterates the combinations of Items in variable and prepend them to fixed vector.\n\nSee also Item, Itemset.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ModalAssociationRules.grow_prune","page":"Utilities","title":"ModalAssociationRules.grow_prune","text":"grow_prune(\n    candidates::AbstractVector{Itemset},\n    frequents::AbstractVector{Itemset},\n    k::Integer\n)\n\nReturn a generator, which yields only the candidates for which every (k-1)-length subset is in frequents.\n\nSee also Itemset.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Association-rules","page":"Utilities","title":"Association rules","text":"","category":"section"},{"location":"utilities/#ModalAssociationRules.generaterules-Tuple{Vector{Vector{I} where I<:Item}, Miner}","page":"Utilities","title":"ModalAssociationRules.generaterules","text":"generaterules(itemsets::AbstractVector{Itemset}, miner::AbstractMiner)\n\nRaw subroutine of generaterules!(miner::AbstractMiner; kwargs...).\n\nGenerates ARule from the given collection of itemsets and miner.\n\nThe strategy followed is described here at section 2.2.\n\nTo establish the meaningfulness of each association rule, check if it meets the global constraints specified in arulemeasures(miner), and yields the rule if so.\n\nSee also AbstractMiner, ARule, Itemset, arulemeasures.\n\n\n\n\n\ngeneraterules(itemsets::AbstractVector{Itemset}, miner::Miner)\n\nSee generaterules(::AbstractVector{Itemset}, ::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Pages = [\"modal-generalization.md\"]","category":"page"},{"location":"modal-generalization/#man-modal-generalization","page":"Mining with modal logic","title":"Association rule mining with modal logic","text":"","category":"section"},{"location":"modal-generalization/#New-building-blocks","page":"Mining with modal logic","title":"New building blocks","text":"","category":"section"},{"location":"modal-generalization/#ModalAssociationRules.WorldMask","page":"Mining with modal logic","title":"ModalAssociationRules.WorldMask","text":"const WorldMask = BitVector\n\nVector whose i-th position stores how many times a certain MeaningfulnessMeasure applied on a specific Itemsets is true on the i-th world of multiple instances.\n\nIf a single instance is considered, then this acts as a bit mask.\n\nFor example, if we consider 5 Kripke structures of a modal dataset, each of which containing 3 worlds, then the WorldMask of an itemset could be [5,2,0], meaning that the itemset is always true on the first world of every instance. In the second world, the same itemset is true on it only for two instances. Considering the third world, then the itemset is never true.\n\nSee also Itemset, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.EnhancedItemset","page":"Mining with modal logic","title":"ModalAssociationRules.EnhancedItemset","text":"const EnhancedItemset = Tuple{Itemset,UInt32}\n\nCompressed representation of multiple, identical Itemsets.\n\nSee also Itemset.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.ConditionalPatternBase","page":"Mining with modal logic","title":"ModalAssociationRules.ConditionalPatternBase","text":"const ConditionalPatternBase = Vector{EnhancedItemset}\n\nCollection of EnhancedItemset.\n\nnote: Note\nThis plays a central role in the state-of-the-art algorithm fpgrowth, where a ConditionalPatternBase embodies all the information needed to build an FPTree data structure in the algorithm.\n\nSee also EnhancedItemset, fpgrowth, FPTree.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#Modal-logic-in-action","page":"Mining with modal logic","title":"Modal logic in action","text":"","category":"section"},{"location":"#ModalAssociationRules","page":"Home","title":"ModalAssociationRules","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for ModalAssociationRules, a Julia package for mining (modal) association rules in ModalAssociationRules.jl. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install ModalAssociationRules.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModalAssociationRules\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Construct and manipulate conjunctions of facts (items) called itemsets, eventually supporting specific modal logic to suit your data (e.g., Halpern Shoham Interval Logic to work with time series).\nExtract the association rules hidden in a dataset, starting from a set of items and a list of meaningfulness measures.\nDefine your own meaningfulness measures to work with both propositional and modal datasets, by simply calling the macros localmeasure and globalmeasure.\nConfigure an experiment by creating as Miner object, and start your mining by choosing an extraction algorithm. We provide the state-of-the-art algorithm FP-Growth, optimized to leverage parallelization, but you can easily write your own algorithm by following a simple interface. ","category":"page"},{"location":"#Package-potential-at-a-glance","page":"Home","title":"Package potential at a glance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a small summary of the Hands on section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider a time series dataset obtained by recording the hand movements of an operator. Instead of working it through propositional logic, we decide to segment each time serie in intervals, and we build relationships between intervals through a certain modal logic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particular, we choose HS Interval Logic in order to establish relationships such as \"interval X OVERLAPS with Y\", or \"interval Y comes AFTER X\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that the dataset is ready we define, let's say manually, some itemset. An itemset, essentially, is a conjunction of facts (possibly, one fact). For example we define the two following itemset called A and B:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A coloneqq textmaxΔtextYHand tip r and thumb r  00\nB coloneqq textOtextmintextYHand tip r  -05","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first one is the fact in the current interval, the right hand is oriented downward. We could also read the vertical distance between right hand middle finger tip and right hand thumb tip is negative.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the second fact, the relation OVERLAPS must be considered universally because of the square brackets. It can be translated into the phrase in all the intervals overlapping with the current one, the hand is located higher than -05.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that we have arranged two itemsets, we want to probe the dataset looking for association rules. To do so, we compute some meaningfulness measures:","category":"page"},{"location":"","page":"Home","title":"Home","text":"local support: \"inside\" an instance, count how many times an itemset is true across all the worlds\nglobal support: across all instances, count how many times the local support \"is significant enough\" on an instance","category":"page"},{"location":"","page":"Home","title":"Home","text":"After that we choose a threshold for each kind of support, in order to delineate what does it mean for an itemset to be frequent (that is, we are interested in it), or no. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's say that both our original itemsets turns out to be frequent. At this point, we can generate two rules A Rightarrow B and B Rightarrow A. Now, we can compute specific meaningfulness measures, such as confidence, to establish whether a rule is an association rule, or no.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModalAssociationRules.jl lives in the context of Sole.jl, an open-source framework for symbolic machine learning, originally designed for machine learning based on modal logics (see Eduard I. Stan's PhD thesis 'Foundations of Modal Symbolic Learning' here).","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleBase.jl\nSoleLogics.jl\nMultiData.jl\nSoleModels.jl\nSoleData.jl\nSoleFeatures.jl \nSolePostHoc.jl","category":"page"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Pages = [\"hands-on.md\"]","category":"page"},{"location":"hands-on/#hands-on","page":"Hands on","title":"Hands-on","text":"","category":"section"},{"location":"hands-on/#A-real-case-usage-scenario","page":"Hands on","title":"A real case usage scenario","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Write here a little lesson, maybe with a jupyter notebook like @giopaglia did.","category":"page"},{"location":"hands-on/#Implementing-a-new-meaningfulness-measure","page":"Hands on","title":"Implementing a new meaningfulness measure","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Local and global lift.","category":"page"},{"location":"hands-on/#Writing-a-new-mining-algorithm","page":"Hands on","title":"Writing a new mining algorithm","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"Write a new mining algorithm (eclat)","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Pages = [\"algorithms.md\"]","category":"page"},{"location":"algorithms/#algorithms","page":"Available algorithms","title":"Available algorithms","text":"","category":"section"},{"location":"algorithms/#Candidate-generation-based","page":"Available algorithms","title":"Candidate generation based","text":"","category":"section"},{"location":"algorithms/#TreeProjection-based","page":"Available algorithms","title":"TreeProjection based","text":"","category":"section"},{"location":"algorithms/#FPGrowth","page":"Available algorithms","title":"FPGrowth","text":"","category":"section"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on two data structures, FPTree and HeaderTable. To know more about them and their, please refer to the documentation here data-structures.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on the following two routines.","category":"page"},{"location":"algorithms/#ModalAssociationRules.patternbase-Tuple{Item, HeaderTable, Miner}","page":"Available algorithms","title":"ModalAssociationRules.patternbase","text":"patternbase(\n    item::Item,\n    htable::HeaderTable,\n    miner::AbstractMiner\n)::ConditionalPatternBase\n\nRetrieve the ConditionalPatternBase of fptree based on item.\n\nThe conditional pattern based on a FPTree is the set of all the paths from the tree root to nodes containing item (not included). Each of these paths is represented by an EnhancedItemset.\n\nThe EnhancedItemsets in the returned ConditionalPatternBase are sorted decreasingly by gsupport.\n\nSee also AbstractMiner, ConditionalPatternBase, contributors, EnhancedItemset, fpgrowth, FPTree, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ModalAssociationRules.projection-Tuple{Vector{Tuple{Vector{I} where I<:Item, Integer}}, Miner}","page":"Available algorithms","title":"ModalAssociationRules.projection","text":"function projection(pbase::ConditionalPatternBase, miner::AbstractMiner)\n\nReturn respectively a FPTree and a HeaderTable starting from pbase. An AbstractMiner must be provided to guarantee the generated header table internal state is OK, that is, its items are sorted decreasingly by gsupport.\n\nSee also ConditionalPatternBase, FPTree, gsupport, HeaderTable, AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Also, FPGrowth requires the Miner to remember the Contributors associated with the extracted frequent itemsets. To add this functionality, we can define a new dispatch of initminingstate: it is automatically considered to enrich the miner, while building it together with fpgrowth as mining algorithm.","category":"page"},{"location":"algorithms/#ModalAssociationRules.initminingstate-Tuple{typeof(fpgrowth), AbstractDataset}","page":"Available algorithms","title":"ModalAssociationRules.initminingstate","text":"initminingstate(::typeof(fpgrowth), ::MineableData)::MiningState\n\nMiningState fields levereged when executing FP-Growth algorithm.\n\nSee also hasminingstate, MiningState, miningstate.\n\n\n\n\n\n","category":"method"}]
}
