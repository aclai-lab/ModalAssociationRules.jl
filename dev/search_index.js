var documenterSearchIndex = {"docs":
[{"location":"data-structures/#data-structures","page":"Built in data structures","title":"Built in data structures","text":"","category":"section"},{"location":"data-structures/#FPTree","page":"Built in data structures","title":"FPTree","text":"","category":"section"},{"location":"data-structures/#ModalAssociationRules.FPTree","page":"Built in data structures","title":"ModalAssociationRules.FPTree","text":"mutable struct FPTree\n    content::Union{Nothing,Item}        # Item contained in this node (nothing if root)\n\n    parent::Union{Nothing,FPTree}       # parent node\n    const children::Vector{FPTree}      # children nodes\n\n    count::Integer                      # number of equal Items this node represents\n\n    link::Union{Nothing,FPTree}         # link to another FPTree root\nend\n\nFundamental data structure used in FP-Growth algorithm. Essentialy, an FPTree is a prefix tree where a root-leaf path represent an Itemset.\n\nConsider the Itemsets sorted by gsupport of their items. An FPTree is such that the common Items-prefix shared by different Itemsets is not stored multiple times.\n\nThis implementation generalizes the propositional logic case scenario to modal logic; given two Itemsets sharing a Item prefix, the worlds in which they are true is accumulated.\n\ninfo: Info\nDid you notice? One FPTree structure contains all the information needed to construct an EnhancedItemset. This is crucial to generate new FPTrees during fpgrowth algorithm, via building ConditionalPatternBases iteratively while avoiding visiting the dataset over and over again.\n\nSee also EnhancedItemset, fpgrowth, gsupport, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.content-Tuple{FPTree}","page":"Built in data structures","title":"ModalAssociationRules.content","text":"content(fptree::FPTree)::Union{Nothing,Item}\n\nGetter for the Item (possibly empty) wrapped by fptree.\n\nSee also content!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.content!-Tuple{FPTree, Item}","page":"Built in data structures","title":"ModalAssociationRules.content!","text":"content!(fptree::FPTree, item::Item)\n\nSetter for fptree's content (the wrapped item).\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent-Tuple{FPTree}","page":"Built in data structures","title":"ModalAssociationRules.parent","text":"parent(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for the parent FPTrees of fptree.\n\nSee also FPTree, parent!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent!-Tuple{FPTree, Union{Nothing, FPTree}}","page":"Built in data structures","title":"ModalAssociationRules.parent!","text":"parent!(fptree::FPTree, item::Union{Nothing,FPTree})\n\nSetter for fptree's parent FPTree.\n\nSee also FPTree, parent.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children-Tuple{FPTree}","page":"Built in data structures","title":"ModalAssociationRules.children","text":"children(fptree::FPTree)::Vector{FPTree}\n\nGetter for the list of children FPTrees of fptree.\n\nSee also children!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children!-Tuple{FPTree, FPTree}","page":"Built in data structures","title":"ModalAssociationRules.children!","text":"children!(fptree::FPTree, child::FPTree)\n\nAdd a new FPTree to fptree's children vector.\n\nwarning: Warning\nThis method forces the new children to be added: it is a caller's responsability to check whether child is not already a children of fptree and, if so, handle the case. This check is performed, for example, in grow!.\n\nnote: Note\nThis method already sets the new children parent to fptree itself.\n\nSee also children, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.retrieveleaf","page":"Built in data structures","title":"ModalAssociationRules.retrieveleaf","text":"function retrieveleaf(fptree::FPTree)::FPTree\n\nReturn a reference to the last node in a list-shaped FPTree.\n\nSee also FPTree;\n\n\n\n\n\n","category":"function"},{"location":"data-structures/#Base.count-Tuple{FPTree}","page":"Built in data structures","title":"Base.count","text":"Base.count(fptree::FPTree)::Integer\n\nGetter for the fptree internal counter. Essentially, it represents the number of overlappings Item which ended up in fptree node during the building process of the tree itself.\n\nSee also count!, FPTree, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.count!-Tuple{FPTree, Integer}","page":"Built in data structures","title":"ModalAssociationRules.count!","text":"count!(fptree::FPTree, newcount::Integer)\n\nSetter for fptree's internal counter to a fixed value newcount.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.addcount!-Tuple{FPTree, Integer}","page":"Built in data structures","title":"ModalAssociationRules.addcount!","text":"addcount!(fptree::FPTree, newcount::Integer)\n\nAdd newcount to fptree's internal counter.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.grow!-Union{Tuple{IT}, Tuple{FPTree, IT}} where IT<:(Vector{I} where I<:Item)","page":"Built in data structures","title":"ModalAssociationRules.grow!","text":"function grow!(\n    fptree::FPTree,\n    itemset::Itemset,\n    ith_instance::Integer,\n    miner::AbstractMiner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\nfunction grow!(\n    fptree::FPTree,\n    itemset::EnhancedItemset,\n    ith_instance::Integer,\n    miner::AbstractMiner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\ngrow!(\n    fptree::FPTree,\n    enhanceditemsets::Union{ConditionalPatternBase,Vector{Itemset}},\n    miner::AbstractMiner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\nPush one or more Itemsets/EnhancedItemset to an FPTree. If an HeaderTable is provided, it is leveraged to develop internal links.\n\nSee also EnhancedItemset, FPTree, gsupport, HeaderTable, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{FPTree}","page":"Built in data structures","title":"ModalAssociationRules.link","text":"link(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for fptree's next brother FPTree. fptree's brotherhood is the set of all the FPTree whose content is exactly fptree.content.\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{FPTree, FPTree}","page":"Built in data structures","title":"ModalAssociationRules.link!","text":"function link!(from::FPTree, to::FPTree)\n\nEstablish a link between two FPTrees. If the starting tree is already linked with something, the already existing link are followed until a new \"empty-linked\" FPTree is found.\n\nSee also follow, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{FPTree}","page":"Built in data structures","title":"ModalAssociationRules.follow","text":"function follow(fptree::FPTree)::Union{Nothing,FPTree}\n\nFollow fptree link to (an internal node of) another FPTree.\n\nSee also FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.islist-Tuple{FPTree}","page":"Built in data structures","title":"ModalAssociationRules.islist","text":"islist(fptree::FPTree)::Bool\n\nReturn true if every subtree in fptree has exactly 0 or 1 children.\n\nSee also FPTree\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#HeaderTable","page":"Built in data structures","title":"HeaderTable","text":"","category":"section"},{"location":"data-structures/#ModalAssociationRules.HeaderTable","page":"Built in data structures","title":"ModalAssociationRules.HeaderTable","text":"struct HeaderTable\n    items::Vector{Item}\n    link::Dict{Item,Union{Nothing,FPTree}}\nend\n\nUtility data structure used to fastly access FPTree internal nodes.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.items-Tuple{HeaderTable}","page":"Built in data structures","title":"ModalAssociationRules.items","text":"items(htable::HeaderTable)::Vector{Item}\n\nGetter for the Items loaded inside htable.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{HeaderTable}","page":"Built in data structures","title":"ModalAssociationRules.link","text":"link(htable::HeaderTable)\nlink(htable::HeaderTable, item::Item)\n\nGetter for the link structure wrapped by htable, or one of its specific entry.\n\nThe link structure is, essentially, a dictionary associating an Item to a specific FPTree.\n\nSee also FPTree, HeaderTable, Item, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{HeaderTable, Item}","page":"Built in data structures","title":"ModalAssociationRules.follow","text":"function follow(htable::HeaderTable, item::Item)::Union{Nothing,FPTree}\n\nFollow htable link to (an internal node of) a FPTree.\n\nSee also FPTree, HeaderTable, Item, link, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{HeaderTable, FPTree}","page":"Built in data structures","title":"ModalAssociationRules.link!","text":"function link!(htable::HeaderTable, fptree::FPTree)\n\nEstablish a link towards fptree, following the entry in htable corresponding to the content of fptree.\n\nSee also content, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.checksanity!-Tuple{HeaderTable, Miner}","page":"Built in data structures","title":"ModalAssociationRules.checksanity!","text":"function checksanity!(htable::HeaderTable, miner::AbstractMiner)::Bool\n\nCheck if htable internal state is correct, that is, its items are sorted decreasingly by global support. If items are already sorted, return true; otherwise, sort them and return false.\n\nSee also AbstractMiner, gsupport, HeaderTable, items.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.reverse-Tuple{HeaderTable}","page":"Built in data structures","title":"Base.reverse","text":"Base.reverse(htable::HeaderTable)\n\nIterator on htable wrapped Items, in reverse order.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"This folder contains a raw and structured dissection of a signal typical of the movement \"I have command\", of the dataset NATOPS.","category":"page"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"More specifically, it is the right hand Y signal of the first instance.","category":"page"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"Both raw and structured signals are generated starting with this julia preamble:","category":"page"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"using Plots\nusing ModalAssociationRules\n\n# for save .tex plots instead of .png\npgfplotsx()\n\nX_df, y = load_NATOPS();\nX = X_df[1:30, :]","category":"page"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"The raw signals are generated with the following julia code:","category":"page"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"windows = [ \n    [(s:s+9) for s in 1:10:41]..., \n    [(s:s+19) for s in 1:10:31]...,  \n    [(s:s+29) for s in 1:10:21]...,  \n    [(s:s+39) for s in 1:10:11]...,  \n    [(s:s+49) for s in 1:10:1]..., \n]\n\nfor i in windows\n    x = collect(i)\n    y = @view X[1,5][x]\n\n    p = plot(x, y;\n        label=false,            # remove legend\n        linecolor=:blue,\n        linewidth=2,\n        size=(10 * length(i), 250),\n        ylims=(-2, 1.9),\n        xticks=false,           # remove x-axis ticks\n        yticks=false,           # remove y-axis ticks\n        xlabel=\"\",              # remove x label\n        ylabel=\"\",              # remove y label\n        framestyle=:none,       # remove frame/axes completely\n        background_color=:transparent\n    )\n\n    _first = i |> first\n    _last = i |> last\n    \n    savefig(p,  \"$(_first)-to-$(_last).tex\")\nend","category":"page"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"while the structured signals are generated with:","category":"page"},{"location":"assets/figures/natops-signals/README/","page":"-","title":"-","text":"windows = [(s:s+9) for s in 1:10:41]\nfor i in windows\n    x = collect(i)\n    y = @view X[1,5][x]\n\n    p = plot(x, y; \n        label=\"Right hand\", linecolor=:blue, linewidth=2, \n        size=(500,250), ylims=(-2,1.9), \n        xticks=collect(1:50), xlabel=\"Time\", ylabel=\"Position on y axis\"\n    )\n    \n    savefig(p, string <| i[1])\nend","category":"page"},{"location":"getting-started/#getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In this introductory section, you will learn about the main building blocks of ModalAssociationRules.jl.  Also, if a good picture about association rule mining (ARM, from now onwards) is given during the documentation, to make the most out of this guide, we suggest reading the following articles:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Association rule mining introduction and Apriori algorithm\nFPGrowth algorithm","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The above introduces two important algorithms, which are also built into this package. Moreover, the latter one is the state-of-the-art in the field of ARM.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Further on in the documentation, the potential of ModalAssociationRules.jl will emerge: this package's raison d'être is to generalize the already existing ARM algorithms to modal logics, which are more expressive than propositional ones (as it allows to reason in terms of relational data) and computationally less expensive than first-order logic. If you are new to Sole.jl and you want to learn more about modal logic, please have a look at SoleLogics.jl for a general overview on the topic, or follow this documentation and return to the link if needed.","category":"page"},{"location":"getting-started/#Fast-introduction","page":"Getting started","title":"Fast introduction","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Consider a time series dataset. For example, let us consider the NATOPS dataset, obtained by recording the movement of different body parts of an operator. We are interested in extracting temporal considerations hidden in the data. To do so, we can highlight specific intervals in each time series (we assume every signal to have the same length). For example, consider the following time series encoding the vertical trajectory of the right hand of an operator.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- Figure code:\nplot(X[1][1,5], label=\"Right hand\", linecolor=:orange, linewidth=2, size=(500,250)); xlabel!(\"Time\"); ylabel!(\"Position on y axis\") \n-->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: I have command movement, specifically the right hand y-axis of the operator)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Now, we can highlight different intervals on the signal. For example, via windowing:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- Figure code:\nX_df, y = load_NATOPS();\nX = X_df[1:30, :]\n\nwindows = [(s:s+9) for s in 1:10:41]\nfor i in windows\n    x = collect(i)\n    y = @view X[1,5][x]\n\n    p = plot(x, y; \n        label=\"Right hand\", linecolor=:blue, linewidth=2, \n        size=(500,250), ylims=(-2,1.9), \n        xticks=collect(1:50), xlabel=\"Time\", ylabel=\"Position on y axis\"\n    )\n    \n    savefig(p, string <| i[1])\nend\n\n# this is an alternative minimal version, considering every possible window (minimum size is set to 10)\nwindows = [ \n    [(s:s+9) for s in 1:10:41]..., \n    [(s:s+19) for s in 1:10:31]...,  \n    [(s:s+29) for s in 1:10:21]...,  \n    [(s:s+39) for s in 1:10:11]...,  \n    [(s:s+49) for s in 1:10:1]...,  \n]\n\nfor i in windows\n    x = collect(i)\n    y = @view X[1,5][x]\n\n    p = plot(x, y;\n        label=false,            # remove legend\n        linecolor=:blue,\n        linewidth=2,\n        size=(10 * length(i), 250),\n        ylims=(-2, 1.9),\n        xticks=false,           # remove x-axis ticks\n        yticks=false,           # remove y-axis ticks\n        xlabel=\"\",              # remove x label\n        ylabel=\"\",              # remove y label\n        framestyle=:none        # remove frame/axes completely\n    )\n\n    _first = i |> first\n    _last = i |> last\n    \n    savefig(p,  \"$(_first)-to-$(_last).png\")\nend\n!-->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"(Image: 1st window of the signal above.) (Image: 2nd window of the signal above.) (Image: 3rd window of the signal above.) (Image: 4th window of the signal above.) (Image: 5th window of the signal above.)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"At this point, we can define a set of logical facts (Items in the jargon) to express a particular property of each interval. We are interested in extracting complex associations hidden in data. In this case, we need a logical formalism capable of capturing temporal relations between different intervals. In particular, HS Interval Logic comes in handy to establish relations such as \"the item p holds on the interval X, while the item q holds on the interval Y, and Y comes after X\".","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"What we want to do, in general, is to extend propositional logic with a specific modal logic formalism (hence, the name of this package) that lets us reason in terms of dimensional relations in data while, at the same time, is not as computationally expensive as first order logic.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To provide you with a more concrete example, consider the following two items, called p and q. We define them as if we were in the Julia REPL.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"# ScalarCondition is a \"generic comparison strategy\" defined in SoleData.jl; it says that the maximum in an object encoding a piece of the first variable (in the example above, the right hand vertical movement) must be greater than the threshold 0.5. \n\n# Atom is a wrapper provided by SoleLogics.jl, to later establish the truth value of a structure.\np = ScalarCondition(VariableMin(1), <, -1.0) |> Atom\n\n# This fact is true on the intervals [1:10] and [11:20] in the example above.\nq = ScalarCondition(VariableMax(1), >=, 0.0) |> Atom\n\n# IA_A is the After relation of Allen's interval algebra; \"diamond\" is one of two modalities (the other one is called \"box\"); we can ignore it for simplicity here.\nap = diamond(IA_A)(p)\n\nalphabet = [p,q,ap]","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Note that the example provided, although concrete, is still a toy example as each interval is completely flattened to just one scalar value. In practice, we would like to deal with more expressive kinds of ScalarCondition.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Now that we have arranged an alphabet of items, we want to establish which items co-occur together by computing the relative frequency of every possible combination of items (this is the most naive mining strategy, but, at the moment, let us forget about performance). Item combinations are called itemsets, and the relative frequency of how many times an itemset is true within the data is typically called support.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Itemset [1:10] [11:20] [21:30] [31:40] [41:50] Support\n[p] true true true  true 4/5\n[q]   true true true 3/5\n[ap] true true  true  3/5\n[p,ap] true true    2/5\n[q,ap]   true  true 2/5\n[p,q,ap]      0/5","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Note that the relative frequency decreases as the itemset we consider gets bigger. Also, note how the after operator in ap shifts the truth values of p one space to the left in the table; in this sense, a temporal declination of a fact is simply a special mask of bits obtained by the fact itself. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let us say that we want to consider the itemset [p,ap] to be frequent, that is, we consider its support to be high enough. The support for an itemset could be very high because it expresses a triviality, so we want to further process the itemset and better analyze it via specific meaningfulness measures.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In particular, we could consider the two rules [p] => [ap] and [ap] => [p]. If they turn out to be meaningful to us, then we call such rules association rules. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The high-level pipeline we described should be useful to proceed with reading the rest of the documentation.","category":"page"},{"location":"getting-started/#Core-definitions","page":"Getting started","title":"Core definitions","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"One Item is just a logical formula, which can be interpreted by a certain model. At the moment, here, we don't care about how models are represented by Sole.jl under the hood, or how the checking algorithm works: what matters is that Items are manipulated by ARM algorithms, which try to find which conjunctions between items are most statistically significant.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Item","page":"Getting started","title":"ModalAssociationRules.Item","text":"struct Item{F<:SoleLogics.Formula}\n    formula::F\nend\n\nFundamental type in the context of association rule mining.\n\nThe name Item comes from the classical association rule mining jargon, but it is simply a wrapper around a logical formula, whose truth value can be checked on a model. To know more about logical formulas, see SoleLogics.Formula.\n\nSee also ARule, gconfidence, Itemset, MeaningfulnessMeasure, SoleLogics.Formula.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.Itemset","page":"Getting started","title":"ModalAssociationRules.Itemset","text":"const Itemset{I<:Item} = Vector{I}\n\nVector collecting multiple Items.\n\nSemantically, Itemsets represent Items (that is, formulas) conjunctions.\n\nnote: Note\nIn the context of association rule mining, interesting itemsets are manipulated to discover interesting relations between Items, in the form of association rules (ARule).Interestingness is established through a set of MeaningfulnessMeasure.\n\ndetails: Details\nItemsets are implemented as a vector for two reasons:lookup is faster  when the collection is small (an itemset is unlikely to consist of more than 100  items);\nmost of the time, we want to keep an ordering between items while searching for  interesting itemsets.\n\nExamples\n\njulia> p = ScalarCondition(VariableMin(1), >, 1.0)  |> Atom |> Item\nmin[V1] > 1.0\njulia> q = ScalarCondition(VariableMin(2), >=, 0.0) |> Atom |> Item\nmin[V2] ≥ 0.0\n\njulia> pq = Itemset([p,q])\njulia> qp = Itemset([q,p])\n\njulia> pq == qp\ntrue\njulia> pq === qp\nfalse\n\njulia> r = ScalarCondition(VariableMax(3), <=, 2.0) |> Atom |> Item\nmax[V3] ≤ 2.0\njulia> pqr = [pq; r];\n\njulia> pq in pqr\ntrue\n\njulia> formula(pqr) |> syntaxstring\n\"(min[V1] > 1.0) ∧ (min[V2] ≥ 0.0) ∧ (max[V3] ≤ 2.0)\"\n\nSee also ARule, formula, gsupport, Item, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Notice that one Itemset could be a set, but actually it is a vector: this is because keeping an ordering between items is always computationally beneficial to ARM algorithms. To convert an Itemset in its conjunctive normal form we simply call formula.","category":"page"},{"location":"getting-started/#ModalAssociationRules.formula","page":"Getting started","title":"ModalAssociationRules.formula","text":"formula(item::Item{F}) where {F}\n\nSee also Item, SoleLogics.Formula.\n\n\n\n\n\nformula(itemset::Itemset)::SoleLogics.LeftmostConjunctiveForm\n\nConjunctive normal form of the Items contained in itemset.\n\nSee also Item, Itemset, SoleLogics.LeftmostConjunctiveForm\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In general, an Itemset behaves exactly like you would expect a Vector{Item} would do. At the end of the day, the only difference is that manipulating an Itemset, for example, through push! or union, guarantees the wrapped items always keep the same sorting.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Enough about Itemsets. Our final goal is to produce association rules. ","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARule","page":"Getting started","title":"ModalAssociationRules.ARule","text":"const ARule = Tuple{Itemset,Itemset}\n\nAn association rule represents a frequent and meaningful co-occurrence relationship of the form \"X ⇒ Y\", between two Itemsets X and Y, where X ∩ Y = ∅, respectively called antecedent and consequent.\n\nnote: Note\nExtracting all the ARule \"hidden\" in the data is the main purpose of association rule mining (ARM).Given an itemset Z containing atleast two Items (|Z| ≥ 2), it can be partitioned in two (sub)itemsets X and Y; trying all the possible binary partitioning of Z is a systematic way to generate ARules.The general framework always followed by ARM techniques is to, firstly, generate all the frequent itemsets considering a set of MeaningfulnessMeasure specifically tailored to work with Itemsets.Thereafter, all the association rules are generated by testing all the combinations of frequent itemsets against another set of MeaningfulnessMeasure, this time designed to capture how interesting a rule is.\n\nSee also antecedent, consequent, gconfidence, Itemset, lconfidence, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.content-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.content","text":"content(rule::ARule)::Tuple{Itemset,Itemset}\n\nGetter for the content of an ARule, that is, both its antecedent and its consequent.\n\nSee also antecedent, ARule, consequent, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.antecedent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.antecedent","text":"antecedent(rule::ARule)::Itemset\n\nGetter for rule's antecedent.\n\nSee also antecedent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.consequent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.consequent","text":"consequent(rule::ARule)::Itemset\n\nGetter for rule's consequent.\n\nSee also consequent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A rich print for ARule is provided by the following utility:","category":"page"},{"location":"getting-started/#ModalAssociationRules.arule_analysis-Tuple{ARule, Miner}","page":"Getting started","title":"ModalAssociationRules.arule_analysis","text":"arule_analysis(arule::ARule, miner::Miner; io::IO=stdout, localities=false)\n\nSee also arule_analysis(::Arule, ::AbstractMiner), ARule, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Sometimes we could be interested in writing a function that considers a generic entity obtained through an association rule mining algorithm (frequent itemsets and, of course, association rules). Think about a dictionary mapping some extracted pattern to metadata. We call that generic entity \"an ARM subject\", and the following union type comes in handy.","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARMSubject","page":"Getting started","title":"ModalAssociationRules.ARMSubject","text":"ARMSubject = Union{ARule,Itemset}\n\nEach entity mined through an association rule mining algorithm.\n\nSee also ARule, GmeasMemo, GmeasMemoKey, Itemset, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Measures","page":"Getting started","title":"Measures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To establish when an ARMSubject is interesting, we need meaningfulness measures. ","category":"page"},{"location":"getting-started/#ModalAssociationRules.Threshold","page":"Getting started","title":"ModalAssociationRules.Threshold","text":"const Threshold = Float64\n\nThreshold value type for MeaningfulnessMeasures.\n\nSee also gconfidence, gsupport, lconfidence, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.MeaningfulnessMeasure","page":"Getting started","title":"ModalAssociationRules.MeaningfulnessMeasure","text":"const MeaningfulnessMeasure = Tuple{Function, Threshold, Threshold}\n\nTo fully understand this description, we suggest reading this article.\n\nIn the classic propositional case scenario, we can think each instance as a propositional interpretation, or equivalently, as a Kripke frame containing only one world. In this setting, a meaningfulness measure indicates how many times a specific property of an Itemset (or an ARule) is satisfied.\n\nThe most important meaningfulness measure is support, defined as \"the number of instances in a dataset that satisfy an itemset\" (it is defined similarly for association rules, where we consider the itemset obtained by combining both rule's antecedent and consequent). Other meaningfulness measures can be defined in function of support.\n\nIn the context of modal logic, where the instances of a dataset are relational objects called Kripke frames, every meaningfulness measure must capture two aspects: how much an Itemset or an ARule is meaningful within an instance, and how much the same object is meaningful across all the instances, that is, how many times it resulted meaningful within an instance. Note that those two aspects coincide in the propositional scenario.\n\nWhen a meaningfulness measure is applied locally within an instance, it is said to be \"local\". Otherwise, it is said to be \"global\". For example, local support is defined as \"the number of worlds within an instance, which satisfy an itemset\". To define global support we need to define a minimum local support threshold sl which is a real number between 0 and 1. Now, we can say that global support is \"the number of instances for which local support overpassed the minimum local support threshold\".\n\nAs in the propositional setting, more meaningfulness measures can be defined starting from support, but now they must respect the local/global dichotomy.\n\nWe now have all the ingredients to understand this type definition. A MeaningfulnessMeasure is a tuple composed of a global meaningfulness measure, a local threshold used internally, and a global threshold we would like our itemsets (rules) to overpass.\n\nSee also gconfidence, gsupport, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"What follows is a list of the already built-in meaningfulness measures. In the Hands on section you will learn how to implement your own measure leveraging memoization optimization via a simple macro.","category":"page"},{"location":"getting-started/#ModalAssociationRules.lsupport","page":"Getting started","title":"ModalAssociationRules.lsupport","text":"function lsupport(\n    itemset::Itemset,\n    instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local support for the given itemset in the given instance.\n\nLocal support is the ratio between the number of worlds in a LogicalInstance where and Itemset is true and the total number of worlds where the Itemset can be checked.\n\nSee also SoleLogics.check, Miner, gsupport, LogicalInstance, Itemset, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#ModalAssociationRules.gsupport","page":"Getting started","title":"ModalAssociationRules.gsupport","text":"function gsupport(\n    itemset::Itemset,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the global support for the given itemset on a logiset X, considering threshold as the threshold for the local support called internally.\n\nGlobal support is the ratio between the number of LogicalInstances in a SupportedLogiset for which the local support, lsupport, is greater than a Threshold, and the total number of instances in the same logiset.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also Miner, lsupport, LogicalInstance, Itemset, SupportedLogiset, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#ModalAssociationRules.lconfidence","page":"Getting started","title":"ModalAssociationRules.lconfidence","text":"function lconfidence(\n    rule::ARule,\n    ith_instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local confidence for the given rule.\n\nLocal confidence is the ratio between lsupport of an ARule on a LogicalInstance and the lsupport of the antecedent of the same rule.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also AbstractMiner, antecedent, ARule, LogicalInstance, lsupport, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#ModalAssociationRules.gconfidence","page":"Getting started","title":"ModalAssociationRules.gconfidence","text":"function gconfidence(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the global confidence for the given rule on a logiset X, considering threshold as the threshold for the global support called internally.\n\nGlobal confidence is the ratio between gsupport of an ARule on a SupportedLogiset and the gsupport of the only antecedent of the same rule.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also antecedent, ARule, AbstractMiner, gsupport, SupportedLogiset.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The measures above are explained in more detail in the Modal generalization section, together with more sophisticated ones. For now, all you need to understand is that lsupport and gsupport compute how many times an itemset is true, while the \"confidence\" counterpart measures how many times an itemset is true, given the fact that another one is currently true.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Measures are stored in ad-hoc shaped data structures.","category":"page"},{"location":"getting-started/#ModalAssociationRules.LmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.LmeasMemoKey","text":"const LmeasMemoKey = Tuple{Symbol,ARMSubject,Integer}\n\nKey of a LmeasMemo dictionary. Represents a local meaningfulness measure name (as a Symbol), a ARMSubject, and the number of a dataset instance where the measure is applied.\n\nSee also ARMSubject, LmeasMemo, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.LmeasMemo","page":"Getting started","title":"ModalAssociationRules.LmeasMemo","text":"const LmeasMemo = Dict{LmeasMemoKey,Threshold}\n\nAssociation between a local measure of a ARMSubject on a specific dataset instance, and its value.\n\nSee also ARMSubject, LmeasMemo, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.GmeasMemoKey","text":"const GmeasMemoKey = Tuple{Symbol,ARMSubject}\n\nKey of a GmeasMemo dictionary. Represents a global meaningfulness measure name (as a Symbol) and a ARMSubject.\n\nSee also ARMSubject, GmeasMemo, gconfidence, gsupport.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemo","page":"Getting started","title":"ModalAssociationRules.GmeasMemo","text":"const GmeasMemo = Dict{GmeasMemoKey,Threshold}\n\nAssociation between a global measure of a ARMSubject on a dataset, and its value.\n\nThe reference to the dataset is not explicited here, since GmeasMemo is intended to be used as a memoization structure inside Miner objects, and the latter already knows the dataset they are working with.\n\nSee also GmeasMemoKey, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Mining-structures","page":"Getting started","title":"Mining structures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we are ready to start mining. To do so, we must implement an AbstractMiner.","category":"page"},{"location":"getting-started/#ModalAssociationRules.AbstractMiner","page":"Getting started","title":"ModalAssociationRules.AbstractMiner","text":"Any entity capable of perform association rule mining.\n\nInterface\n\nEach new concrete miner structure must define the following getters and setters. Actually, depending on its purposes, a structure may partially implement these dispatches. For example, Miner does completely implement the interface while Bulldozer does not.\n\ndata(miner::AbstractMiner)\nitems(miner::AbstractMiner)\nalgorithm(miner::AbstractMiner)\nfreqitems(miner::AbstractMiner)\narules(miner::AbstractMiner)\nitemsetmeasures(miner::AbstractMiner)\narulemeasures(miner::AbstractMiner)\nlocalmemo(miner::AbstractMiner)\nlocalmemo!(miner::AbstractMiner)\nglobalmemo(miner::AbstractMiner)\nglobalmemo!(miner::AbstractMiner)\nworldfilter(miner::AbstractMiner)\nitemset_policies(miner::AbstractMiner)\narule_policies(miner::AbstractMiner)\nminingstate(miner::AbstractMiner)\nminingstate!(miner::AbstractMiner)\ninfo(miner::AbstractMiner)\n\nSee also Miner, Bulldozer.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The main implementation of an AbstractMiner's an interface is embodied by the Miner structure. At the moment of writing, all the experiments written with this package are implemented using the latter.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To mine using a Miner, we just need to specify which dataset we are working with, together with a mining function, a vector of initial Items, and the MeaningfulnessMeasures to establish ARMSubject interestingness.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Miner","page":"Getting started","title":"ModalAssociationRules.Miner","text":"struct Miner{\n    D<:MineableData,\n    I<:Item\n} <: AbstractMiner\n    X::D                            # target dataset\n\n    algorithm::Function             # algorithm used to perform extraction\n\n    items::Vector{I}                # alphabet\n\n    # meaningfulness measures\n    itemset_constrained_measures::Vector{<:MeaningfulnessMeasure}\n    arule_constrained_measures::Vector{<:MeaningfulnessMeasure}\n\n    freqitems::Vector{Itemset}      # collected frequent itemsets\n    arules::Vector{ARule}           # collected association rules\n\n    localmemo::LmeasMemo            # local memoization structure\n    globalmemo::GmeasMemo           # global memoization structure\n\n    worldfilter::Union{Nothing,WorldFilter} # metarules about world filterings\n    itemset_policies::Vector{<:Function}    # metarules about itemsets mining\n    arule_policies::Vector{<:Function}      # metarules about arules mining\n\n    miningstate::MiningState        # mining algorithm miningstate (see documentation)\n\n    info::Info                      # general informations\n\n    # locks on memoization and miningstate structures\n    lmemolock::ReentrantLock\n    gmemolock::ReentrantLock\n    miningstatelock::ReentrantLock\nend\n\nConcrete AbstractMiner containing both the data, the logic and the parameterization to perform association rule mining in the modal setting.\n\nExamples\n\njulia> using ModalAssociationRules\njulia> using SoleData\n\n# Load NATOPS DataFrame\njulia> X_df, y = load_NATOPS();\n\n# Convert NATOPS DataFrame to a Logiset\njulia> X = scalarlogiset(X_df)\n\n# Prepare some propositional atoms\njulia> p = Atom(ScalarCondition(VariableMin(1), >, -0.5))\njulia> q = Atom(ScalarCondition(VariableMin(2), <=, -2.2))\njulia> r = Atom(ScalarCondition(VariableMin(3), >, -3.6))\n\n# Prepare modal atoms using later relationship - see [`SoleLogics.IntervalRelation`](@ref))\njulia> lp = box(IA_L)(p)\njulia> lq = diamond(IA_L)(q)\njulia> lr = box(IA_L)(r)\n\n# Compose a vector of items, regrouping the atoms defined before\njulia> my_alphabet = Vector{Item}([p, q, r, lp, lq, lr])\n\n# Establish which meaningfulness measures you want to define the notion of itemset and\n# association rule holding on an instance and on a modal dataset\njulia> my_itemsetmeasures = [(gsupport, 0.1, 0.1)]\njulia> my_rulemeasures = [(gconfidence, 0.1, 0.1)]\n\n# (optional) Establish a filter to iterate the worlds in a generic modal instance\njulia> my_worldfilter = SoleLogics.FunctionalWorldFilter(\n        x -> length(x) >= 3 && length(x) <= 10, Interval{Int}\n    )\n\n# (optional) Establish a policy to further restrict itemsets that can be considered frequent\njulia> my_itemset_policies = [islimited_length_itemset()]\n\n# (optional) Establish a policy to further restrict rules that can be considered\n# association rules\njulia> my_arule_policies = [\n        islimited_length_arule(), isanchored_arule(), isheterogeneous_arule()\n    ]\n\n# Create an association rule miner wrapping `fpgrowth` algorithm - see [`fpgrowth`](@ref);\njulia> miner = Miner(X, fpgrowth, my_alphabet,\n        my_itemsetmeasures, my_rulemeasures,\n        worldfilter=my_worldfilter,\n        itemset_policies=my_itemset_policies,\n        arule_policies=my_arule_policies\n    )\n\n# We mine using mine!\n# (optional) We could pass kwargs to forward them to the mining algorithm\njulia> mine!(miner)\n\n# Print all the mined association rules\njulia> for arule in generaterules(miner)\n    println(arule)\nend\n\nSee also  ARule, Bulldozer, MeaningfulnessMeasure, Info, isanchored_arule, isheterogeneous_arule, islimited_length_arule(), islimited_length_itemset(), Item, Itemset, GmeasMemo, LmeasMemo, MiningState, SoleLogics.WorldFilter.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let us see which getters and setters are available for Miner.","category":"page"},{"location":"getting-started/#ModalAssociationRules.data-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.data","text":"data(miner::Miner)::MineableData\n\nSee data(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.algorithm-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.algorithm","text":"algorithm(miner::Miner)::Function\n\nSee algorithm(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.items-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.items","text":"items(miner::Miner)\n\nSee items(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.measures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.measures","text":"measures(miner::AbstractMiner)::Vector{<:MeaningfulnessMeasure}\n\nReturn all the MeaningfulnessMeasures wrapped by miner.\n\nSee also AbstractMiner, itemsetmeasures, MeaningfulnessMeasure, arulemeasures.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.findmeasure-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.findmeasure","text":"findmeasure(\n    miner::AbstractMiner,\n    meas::Function;\n    recognizer::Function=islocalof\n)::MeaningfulnessMeasure\n\nRetrieve the MeaningfulnessMeasure associated with meas within miner.\n\nSee also isglobalof, islocalof, MeaningfulnessMeasure, AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemsetmeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.itemsetmeasures","text":"itemsetmeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nSee [itemsetmeasures(::AbstractMiner)]\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.arulemeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.arulemeasures","text":"arulemeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nSee arulemeasures(miner::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getlocalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getlocalthreshold","text":"getlocalthreshold(miner::AbstractMiner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work locally (that is, analyzing \"the inside\" of a dataset's instances) in miner.\n\nSee AbstractMiner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getglobalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getglobalthreshold","text":"getglobalthreshold(miner::AbstractMiner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work globally (that is, measuring the behavior of a specific local-measure across all dataset's instances) in miner.\n\nSee AbstractMiner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"After a Miner ends mining (we will see how to mine in a second), frequent Itemsets and ARule are accessible through the getters below.","category":"page"},{"location":"getting-started/#ModalAssociationRules.freqitems-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.freqitems","text":"freqitems(miner::Miner)\n\nSee freqitems(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.arules-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.arules","text":"arules(miner::Miner) See arules(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To start the mining algorithm, simply call the following:","category":"page"},{"location":"getting-started/#ModalAssociationRules.mine!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.mine!","text":"mine!(miner::AbstractMiner; kwargs...)\n\nSynonym for `apply!.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The mining call returns an ARule generator. Since the extracted rules could be an exponential number, the rule generation phase is separated from the mining itself (for example, you might be interested in serializing the miner object and continuing the rules enumeration later).","category":"page"},{"location":"getting-started/#ModalAssociationRules.generaterules!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.generaterules!","text":"generaterules!(miner::Miner)\n\nSee generaterules(::AbstractVector{Itemset}, ::Miner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"During both the mining and the rules generation phases, the values returned by MeaningfulnessMeasure applied on a certain ARMSubject are saved inside the Miner. Thanks to the methods hereafter, a Miner can avoid useless recomputations.","category":"page"},{"location":"getting-started/#ModalAssociationRules.localmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.localmemo","text":"localmemo(miner::Miner)::LmeasMemo\n\nSee localmemo(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject, Integer}, Float64}","page":"Getting started","title":"ModalAssociationRules.localmemo!","text":"localmemo!(miner::Miner, key::LmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the local memoization structure wrapped by miner.\n\nSee also Miner, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.globalmemo","text":"globalmemo(miner::Miner)::GmeasMemo\n\nSee globalmemo(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject}, Float64}","page":"Getting started","title":"ModalAssociationRules.globalmemo!","text":"globalmemo!(miner::Miner, key::GmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the global memoization structure wrapped by miner.\n\nSee also Miner, GmeasMemo, GmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Miner-customization","page":"Getting started","title":"Miner customization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A Miner also contains two fields to keep additional information, those are info and miningstate.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The info field in Miner is a dictionary used to store extra information about the miner, such as statistics about mining. Currently, since the package is still being developed, the info field only contains a flag indicating whether the miner has been used for mining or not.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Info","page":"Getting started","title":"ModalAssociationRules.Info","text":"const Info = Dict{Symbol,Any}\n\nStorage reserved to metadata about mining (e.g., execution time).\n\nSee also info, info!, hasinfo, Miner.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.info-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.info","text":"info(miner::Miner)::Info = miner.info\n\nGetter for miner's structure holding meta informations about mining.\n\nSee also Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.info!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.info!","text":"info!(miner::Miner, key::Symbol, val)\n\nSetter for miner's metadata.\n\nSee also hasinfo, info, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasinfo-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasinfo","text":"hasinfo(miner::AbstractMiner, key::Symbol)\n\nReturn whether miner additional informations field contains an entry key.\n\nSee also AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When writing your own mining algorithm, or when mining with a particular kind of dataset, you might need to specialize the Miner, keeping, for example, custom metadata and data structures. To specialize a Miner, you can fill a MiningState structure to fit your needs.","category":"page"},{"location":"getting-started/#ModalAssociationRules.MiningState","page":"Getting started","title":"ModalAssociationRules.MiningState","text":"const MiningState = Dict{Symbol,Any}\n\nAdditional informations associated with an ARMSubject that can be used to specialize any concrete type deriving from AbstractMiner, thus augmenting its capabilities.\n\nTo understand how to specialize a Miner, see hasminingstate, initminingstate, 'miningstate`, miningstate!.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.miningstate-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.miningstate","text":"miningstate(miner::Miner)\n\nSee miningstate(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstate!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.miningstate!","text":"miningstate!(miner::Miner, key::Symbol, val)\n\nSetter for the content of a specific field of miner's miningstate.\n\nSee also Miner, hasminingstate, initminingstate, MiningState.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasminingstate-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasminingstate","text":"hasminingstate(miner::Miner, key::Symbol)\n\nReturn whether miner miningstate contains a field key.\n\nSee also Miner, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.initminingstate-Tuple{Function, AbstractDataset}","page":"Getting started","title":"ModalAssociationRules.initminingstate","text":"initminingstate(::Function, ::MineableData)\n\nThis trait defines how to initialize the MiningState structure of an AbstractMiner, in order to customize it to your needings depending on a specific function/data pairing.\n\nSee ealso hasminingstate, AbstractMiner, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Parallelization","page":"Getting started","title":"Parallelization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To support parallel mining, we provide a Bulldozer miner, that is, a lightweight copy of Miner which mines a specific section of the data in its own thread.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Bulldozer","page":"Getting started","title":"ModalAssociationRules.Bulldozer","text":"struct Bulldozer{\n    I<:Item,\n    IMEAS<:MeaningfulnessMeasure\n} <: AbstractMiner\n    # data mineable by the Bulldozer\n    data::D\n\n    # original instance ids associated with the current slice of data\n    # if this is 5:10, this this means that the first instance of the slice is\n    # the original fifth and so on.\n    instancesrange::UnitRange{<:Integer}\n\n    # alphabet\n    items::Vector{I}\n\n    # measures associated with mined itemsets\n    itemsetmeasures::Vector{<:MeaningfulnessMeasure}\n\n    # meaningfulness measures memoization structure\n    localmemo::LmeasMemo\n\n    # special fields related to mining algorithms\n    worldfilter::Union{Nothing,WorldFilter}\n    itemset_policies::Vector{<:Function}\n    miningstate::MiningState\n\n    # locks on data, memoization structure and miningstate structure\n    datalock::ReentrantLock\n    memolock::ReentrantLock\n    miningstatelock::ReentrantLock\n}\n\nConcrete AbstractMiner specialized to mine a single modal instance.\n\nBulldozer's interface is similar to Miner's one, but contains only the essential fields necessary to work locally within a Kripke structure, and is designed to be thread-safe.\n\nnote: Note\nBulldozers are designed to easily implement multi-threaded mining algorithms. When doing so, you can use a monolithic miner structure to collect the initial parameterization, map the computation on many bulldozers, each of which can be easily constructed from the miner itself, and then reduce the results together.\n\nSee also AbstractMiner, Miner.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.datalock-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.datalock","text":"datalock(bulldozer::Bulldozer)\n\nGetter for the ReentrantLock associated with the SoleLogics.LogicalInstance wrapped by a Bulldozer.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.memolock-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.memolock","text":"memolock(bulldozer::Bulldozer)\n\nGetter for the ReentrantLock associated with the inner Bulldozer's memoization structure\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstatelock-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.miningstatelock","text":"miningstatelock(bulldozer::Bulldozer)\n\nGetter for the ReentrantLock associated with the customizable dictionary within a Bulldozer.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.datatype-Union{Tuple{Bulldozer{D}}, Tuple{D}} where D<:AbstractDataset","page":"Getting started","title":"ModalAssociationRules.datatype","text":"datatype(::Bulldozer{D}) where {D<:MineableData} = D\n\nReturn the type of the MineableData given by data(::Bulldozer).\n\nSee also Bulldozer, data(::Bulldozer), MineableData.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemtype-Union{Tuple{Bulldozer{D, I}}, Tuple{I}, Tuple{D}} where {D, I<:Item}","page":"Getting started","title":"ModalAssociationRules.itemtype","text":"itemtype(::Bulldozer{D,I}) where {D,I<:Item} = I\n\nReturn the type of the Items given by items(::Bulldozer).\n\nSee also Bulldozer, items(::Bulldozer), MineableData.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.instancesrange-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.instancesrange","text":"instancesrange(bulldozer::Bulldozer)\n\nReturn the instance slice range on which bulldozer is working.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.instanceprojection-Tuple{Bulldozer, Integer}","page":"Getting started","title":"ModalAssociationRules.instanceprojection","text":"instanceprojection(bulldozer::Bulldozer, ith_instance::Integer)\n\nMaps the ith_instance on a range starting from 1, instead of instancerange.\n\nSee also Bulldozer, instancerange.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.data-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.data","text":"data(bulldozer::Bulldozer)\ndata(bulldozer::Bulldozer, ith_instance::Integer)\n\nGetter for the MineableData wrapped within bulldozer, or a specific instance.\n\nSee data(::AbstractMiner), SoleLogics.LogicalInstance, MineableData.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.items-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.items","text":"items(bulldozer::Bulldozer)\n\nSee items(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemsetmeasures-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.itemsetmeasures","text":"itemsetmeasures(bulldozer::Bulldozer)::Vector{<:MeaningfulnessMeasure}\n\nSee also itemsetmeasures(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localmemo-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.localmemo","text":"localmemo(bulldozer::Bulldozer)\nlocalmemo(bulldozer::Bulldozer, key::LmeasMemoKey)\n\nSee localmemo(::AbstractMiner), LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.worldfilter-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.worldfilter","text":"worldfilter(bulldozer::Bulldozer) = bulldozer.worldfilter\n\nSee also worldfilter(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemset_policies-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.itemset_policies","text":"itemset_policies(bulldozer::Bulldozer)\n\nSee also itemset_policies(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstate-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.miningstate","text":"miningstate(bulldozer::Bulldozer)::MiningState\nminingstate(bulldozer::Bulldozer, key::Symbol)::Any\nminingstate(bulldozer::Bulldozer, key::Symbol, inner_key)::Any\n\nGetter for the customizable dictionary wrapped by a Bulldozer.\n\nSee also [miningstate!(::Bulldozer)].\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstate!-Tuple{Bulldozer, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.miningstate!","text":"miningstate!(bulldozer::Bulldozer, key::Symbol, val)\nminingstate!(bulldozer::Bulldozer, key::Symbol, inner_key, val)\n\nSetter for the content of a specific bulldozer's miningstate.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasminingstate-Tuple{Bulldozer, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasminingstate","text":"hasminingstate(bulldozer::Bulldozer, key::Symbol)\n\nReturn whether bulldozer miningstate field contains a field key.\n\nSee also Bulldozer, miningstate, miningstate!.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.measures-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.measures","text":"measures(bulldozer::Bulldozer)\n\nSynonym for itemsetmeasures. This exists to adhere to Miner's interface.\n\nSee also Bulldozer, itemsetmeasures, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miner_reduce!-Union{Tuple{AbstractVector{B}}, Tuple{B}} where B<:Bulldozer","page":"Getting started","title":"ModalAssociationRules.miner_reduce!","text":"function miner_reduce!(b1::Bulldozer, b2::Bulldozer)::LmeasMemo\n\nReduce many Bulldozers together, merging their local memo structures in linear time.\n\nnote: Note\nThis method will soon be deprecated in favour of a general dispatch miner_reduce!(::AbstractVector{M})\n\nSee also LmeasMemo, localmemo(::Bulldozer);\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.load_localmemo!-Tuple{AbstractMiner, Dict{Tuple{Symbol, ARMSubject, Integer}, Float64}}","page":"Getting started","title":"ModalAssociationRules.load_localmemo!","text":"function load_localmemo!(miner::AbstractMiner, localmemo::LmeasMemo)\n\nLoad a local memoization structure inside miner. Also, returns a dictionary associating each loaded local Itemset loaded to its its global support, in order to simplify miner's job when working in the global setting.\n\nSee also Itemset, LmeasMemo, lsupport, Miner.\n\n\n\n\n\n","category":"method"},{"location":"contributing/#contributing","page":"Contributing","title":"Hands-on","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TODO","category":"page"},{"location":"advanced/#advanced-usage","page":"Advanced usage","title":"Advanced usage","text":"","category":"section"},{"location":"advanced/#Mining-Policies","page":"Advanced usage","title":"Mining Policies","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"It is possible to limit the action of the mining, to force an AbstractMiner to only consider a subset of the available data.","category":"page"},{"location":"advanced/#ModalAssociationRules.worldfilter","page":"Advanced usage","title":"ModalAssociationRules.worldfilter","text":"worldfilter(::AbstractMiner)\n\nReturn the world filter policy wrapped within the AbstractMiner. This specifies how the worlds of a modal instance must be iterated.\n\nSee also AbstractMiner, data(::AbstractMiner), SoleLogics.WorldFilter.\n\n\n\n\n\nworldfilter(miner::Miner)\n\nSee also worldfilter(::AbstractMiner).\n\n\n\n\n\nworldfilter(bulldozer::Bulldozer) = bulldozer.worldfilter\n\nSee also worldfilter(::AbstractMiner).\n\n\n\n\n\n","category":"function"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"We can also constrain the generation of new itemsets and rules, by defining a vector of policies. For what regards itemsets, the following dispatches are available:","category":"page"},{"location":"advanced/#ModalAssociationRules.itemset_policies","page":"Advanced usage","title":"ModalAssociationRules.itemset_policies","text":"function itemset_policies(::AbstractMiner)\n\nReturn the mining policies vector wrapped within an AbstractMiner. Each mining policies is a meta-rule describing which Itemset are accepted during the mining phase and which are discarded.\n\nwarning: Warning\nThese policies often require to be tailored ad-hoc for a specific mining algorithm, and have the role of pruning unwanted explorations of the search space as early as possible.Keep in mind that you may need to modify some existing policies to make them correct and effective for your custom algorithm.As far as the algorithms already implemented in this package are concerned, generation policies are applied before saving an itemset inside the miner: thus, they reduce the waste of memory, but not necessarily of computational time.\n\nSee also AbstractMiner, generaterules, arule_policies.\n\n\n\n\n\nfunction itemset_policies(miner::Miner)\n\nSee itemset_policies(::AbstractMiner).\n\n\n\n\n\nitemset_policies(bulldozer::Bulldozer)\n\nSee also itemset_policies(::AbstractMiner).\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.islimited_length_itemset","page":"Advanced usage","title":"ModalAssociationRules.islimited_length_itemset","text":"function islimited_length_itemset(; maxlength::Union{Nothing,Integer}=nothing)::Function\n\nClosure returning a boolean function F with one argument itemset::Itemset.\n\nF is true if the length of the given itemset does not exceed the given thresholds.\n\nArguments\n\nmaxlength::Union{Nothing,Integer}=nothing: maximum itemset's length; when nothing,   defaults to typemax(Int16).\n\nSee also Itemset, itemset_policies.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isanchored_itemset","page":"Advanced usage","title":"ModalAssociationRules.isanchored_itemset","text":"function isanchored_itemset(;\n    npropositions::Integer=1,\n    ignoreuntillength::Integer=1\n)::Function\n\nClosure returning a boolean function F with one argument rule::Itemset.\n\nF is true if the given itemset contains atleast npropositions propositional anchors (that is, propositions without modal operators).\n\nArguments\n\nnpropositions::Integer=1: minimum number of propositional anchors (propositions with   no modal operators) in the antecedent of the given rule.\nignoreuntillength::Integer=1: avoid applying the policy to isolated Items, or   Itemset short enough.\n\nSee Item, Itemset, itemset_policies, isanchored_arule.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isdimensionally_coherent_itemset","page":"Advanced usage","title":"ModalAssociationRules.isdimensionally_coherent_itemset","text":"function isdimensionally_coherent_itemset(;)::Function\n\nClosure returning a boolean function F with one argument itemset::Itemset.\n\nThis is needed to ensure the Itemset is coherent with the dimensional definition of local support. All the propositions (or anchors) in an itemset must be VariableDistances wrapping references of the same size.\n\nSee also Itemset, itemset_policies, SoleData.VariableDistance.\n\n\n\n\n\n","category":"function"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The following are referred to association rules:","category":"page"},{"location":"advanced/#ModalAssociationRules.arule_policies","page":"Advanced usage","title":"ModalAssociationRules.arule_policies","text":"arule_policies(::AbstractMiner)\n\nReturn the association rules generation policies vector wrapped within an AbstractMiner. Each generation policies is a meta-rule describing which ARule are accepted during the generation algorithm and which are discarded.\n\nSee also AbstractMiner, generaterules, itemset_policies.\n\n\n\n\n\narule_policies(miner::Miner)\n\nSee itemset_policies(::AbstractMiner).\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.islimited_length_arule","page":"Advanced usage","title":"ModalAssociationRules.islimited_length_arule","text":"function islimited_length_arule(;\n    antecedent_maxlength::Union{Nothing,Integer}=nothing,\n    consequent_maxlength::Union{Nothing,Integer}=1\n)::Function\n\nClosure returning a boolean function F with one argument rule::ARule.\n\nF is true if the length of rule's antecedent (and consequent) does not exceed the given thresholds.\n\nArguments\n\nantecedent_maxlength::Union{Nothing,Integer}=nothing: maximum antecedent length of   the given rule; when nothing, defaults to typemax(Int16);\nconsequent_maxlength::Union{Nothing,Integer}=1: maximum consequent length of the given   rule; when nothing, defaults to typemax(Int16).\n\nSee also antecedent, ARule, arule_policies, consequent.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isanchored_arule","page":"Advanced usage","title":"ModalAssociationRules.isanchored_arule","text":"function isanchored_arule(; npropositions::Integer=1)::Function\n\nClosure returning a boolean function F with one argument rule::ARule.\n\nF is true if the given rule contains atleast npropositions propositional anchors (that is, propositions without modal operators).\n\nArguments\n\nnpropositions::Integer=1: minimum number of propositional anchors (propositions with   no modal operators) in the antecedent of the given rule.\n\nSee antecedent, ARule, arule_policies, generaterules, Item, Miner.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isheterogeneous_arule","page":"Advanced usage","title":"ModalAssociationRules.isheterogeneous_arule","text":"function isheterogeneous_arule(;\n    antecedent_nrepetitions::Integer=1,\n    consequent_nrepetitions::Integer=0,\n    consider_thresholds::Bool=false\n)::Function\n\nClosure returning a boolean function F with one argument rule::ARule.\n\nF is true if the given rule is heterogeneous, that is, across all the Item in rule antecedent and consequent, the number of identical variables V is at most nrepetitions.\n\nArguments\n\nantecedent_nrepetitions::Integer=1: maximum allowed number of identical variables in the   antecedent of the given rule.\nconsequent_nrepetitions::Integer=0: maximum allowed number of identical variables   between the antecedent and the consequent of the given rule.\nconsider_thresholds::Bool=false: if true, both identical variables and thresholds   are considered in the counting.\n\nSee antecedent, ARule, consequent, generaterules, Item, Miner.\n\n\n\n\n\n","category":"function"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"To apply the policies, simply call the following.","category":"page"},{"location":"advanced/#Anchored-semantics","page":"Advanced usage","title":"Anchored semantics","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"To ensure the mining process is fair when dealing with modal operators, we must ensure that the miner is compliant with anchored semantics constraints.","category":"page"},{"location":"advanced/#ModalAssociationRules.isanchored_miner","page":"Advanced usage","title":"ModalAssociationRules.isanchored_miner","text":"isanchored_miner(miner::AbstractMiner)\n\nCheck if miner is provided of both isdimensionally_coherent_itemset and isanchored_itemset policy and, in particular, if ignoreuntillength parameter is set to 1 or above in the latter.\n\nSee also AbstractMiner, isanchored_itemset, isdimensionally_coherent_itemset.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.anchored_apriori","page":"Advanced usage","title":"ModalAssociationRules.anchored_apriori","text":"anchored_apriori(miner::AbstractMiner; kwargs...)::Nothing\n\nAnchored version of apriori algorithm, that is exactly apriori but assuring that miner possess atleast isanchored_itemset policy, with ignoreuntillength parameter set to 1 or higher.\n\nTODO - insert a reference to TIME2025 article.\n\nSee also AbstractMiner, anchored_semantics, apriori.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.anchored_fpgrowth","page":"Advanced usage","title":"ModalAssociationRules.anchored_fpgrowth","text":"function anchored_fpgrowth(miner::M; kwargs...)::M where {M<:AbstractMiner}\n\nImplementation of fpgrowth with anchored semantics. Essentially, Items are SoleData.VariableDistances wrapping motifs.\n\nMore information about motifs: <insert-link> More information about the implementation: <insert-link>\n\nSee also AbstractMiner, anchored_semantics, 'fpgrowth`.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.anchored_eclat","page":"Advanced usage","title":"ModalAssociationRules.anchored_eclat","text":"function anchored_eclat(miner::M; kwargs...)::M where {M<:AbstractMiner}\n\nImplementation of eclat with anchored semantics.\n\nSee also AbstractMiner, anchored_semantics, eclat.\n\n\n\n\n\n","category":"function"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Each algorithm above is simply a small wrapper around anchored_semantics:","category":"page"},{"location":"advanced/#ModalAssociationRules.anchored_semantics","page":"Advanced usage","title":"ModalAssociationRules.anchored_semantics","text":"anchored_semantics(miner::M; kwargs...)::M where {M<:AbstractMiner}\n\nLogic to be executed before the the algorithm wrapped within the miner; the goal is to make such an algorithm coherent with anchored semantics.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#Utilities","page":"Advanced usage","title":"Utilities","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The following utilities often involve performing some combinatoric trick between Itemsets and ARules, and might be useful to avoid reinventing the wheel.","category":"page"},{"location":"advanced/#ModalAssociationRules.combine_items","page":"Advanced usage","title":"ModalAssociationRules.combine_items","text":"combine_items(itemsets::AbstractVector{<:Itemset}, newlength::Integer)\n\nReturn a generator which combines Itemsets from itemsets into new itemsets of length newlength by taking all combinations of two itemsets and joining them.\n\nSee also Itemset.\n\n\n\n\n\ncombine_items(variable::AbstractVector{<:Item}, fixed::AbstractVector{<:Item})\n\nReturn a generator of Itemset, which iterates the combinations of Items in variable and prepend them to fixed vector.\n\nSee also Item, Itemset.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.grow_prune","page":"Advanced usage","title":"ModalAssociationRules.grow_prune","text":"grow_prune(\n    candidates::AbstractVector{Itemset},\n    frequents::AbstractVector{Itemset},\n    k::Integer\n)\n\nReturn a generator, which yields only the candidates for which every (k-1)-length subset is in frequents.\n\nSee also Itemset.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.anchored_grow_prune","page":"Advanced usage","title":"ModalAssociationRules.anchored_grow_prune","text":"anchored_grow_prune(\n    candidates::AbstractVector{Itemset},\n    frequents::AbstractVector{Itemset},\n    k::Integer\n)\n\nReturn a generator, which yields only the candidates for which every (k-1)-length subset is in frequents.\n\nDifferently from grow_prune, this method supports anchored semantics. This means that, for example, the following Itemsets are not pruned [[L]min[V1] > -0.5, min[V3] > -3.6], [min[V3] > -3.6, [L]min[V3] > -3.6] and can be merged in [[L]min[V1] > -0.5, min[V3] > -3.6, [L]min[V3] > -3.6], since it would be impossible to generate [[L]min[V1] > -0.5, [L]min[V3] > -3.6].\n\nSee also grow_prune, Itemset.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#man-modal-generalization","page":"Mining with modal logic","title":"Association rule mining with modal logic","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Symbolic modal learning is a branch of machine learning which deals with training classical symbolic machine learning models (e.g., list and set of rules, decision trees, random forests, association rules, etc.) but substituting propositional logic with a more expressive logical formalism (yet, computationally more affordable than first order logic), that is, a specific kind of modal logic.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"In the context of this package, modal logic helps us highlight complex relations hidden in data, especially in unstructured data, consisting of graph-like relational data, time series, spatial databases, text, etc. For more information about the modal symbolic learning, we suggest reading the main page of Sole.jl framework and SoleLogics.jl.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"The idea is to discretize complex data into relational objects called Kripke models, each of which consists of many propositional models called worlds, and expliciting the relations between worlds. In this way, it is possible to mine complex Itemset, including a certain subset of Item that are true on a target world, but also modally enhanced items that are true on related worlds.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"A picture is worth a thousand words. Here you are a slightly more complex example, with respect to the one at the top of Getting started section. We consider this monovariate time series:","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"(Image: Monovariate time series.)","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"We want to encode a graph-like structure from the data above. We could think of various strategies, one of which is to consider every contiguous subsequence in the time series and model it as a set of intervals.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"(Image: Monovariate time series sliced into intervals.)","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"At this point, we can see every resulting blue signal as a propositional model, on which items may be evaluated as true or false. In the modal logic jargon, this is exactly a Kripke model.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"(Image: Kripke model resulting from the image above.)","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"After fixing a set of suitable relations, we express them with arcs in the structure. Without defining them, we graphically present some possible relations between intervals. The one below is the begins relation.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"(Image: Begins relation.)","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Conversely, this one is the ends relation.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"(Image: Ends relation.)","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"When an interval is completely included in another one, then we say that it happens during the other one.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"(Image: During relation.)","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Finally, we say that an interval comes just after another one if its end coincides with the beginning of the other one.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"(Image: After relation.)","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Every relation R can be declined in an existential or a universal way. In the former (latter) case, given an item p, we say that Rp is true on w if at least one world (all worlds) w is such that wRw and p is true on w. Such relations can be encoded thanks to SoleLogics.jl; in particular, we use diamond(relation_name) to indicate an existential modality while box(relation_name) to indicate universal ones:","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"myitem = ScalarCondition(VariableDistance(1, [1,2,3]), <=, 1.0) |> diamond(IA_L)","category":"page"},{"location":"modal-generalization/#Meaningfulness-measures","page":"Mining with modal logic","title":"Meaningfulness measures","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"We already introduced lsupport, gsupport, lconfidence and gconfidence in the Getting started section. Other measures that are already built into the package, are the following; note how they are always organized in both local and global versions.","category":"page"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Local means that a measure is designed to be applied within a modal instance (a Kripke model), while global keywords denotes the fact that the computation is performed across instances.","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.llift","page":"Mining with modal logic","title":"ModalAssociationRules.llift","text":"function llift(\n    rule::ARule,\n    ith_instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local lift for the given rule.\n\nLocal lift measures how far from independence are rule's antecedent and consequent on a modal logic instance.\n\nGiven an ARule X ⇒ Y, if local lift value is around 1, then this means that P(X ⋃ Y) = P(X)P(Y), and hence, the two Itemsets X and Y are independant. If value is greater than (lower than) 1, then this means that X and Y are dependant and positively (negatively) correlated Itemsets.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also AbstractMiner, antecedent, ARule, glift, LogicalInstance, llift, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.glift","page":"Mining with modal logic","title":"ModalAssociationRules.glift","text":"function glift(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nSee also llift.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.lconviction","page":"Mining with modal logic","title":"ModalAssociationRules.lconviction","text":"function lconviction(\n    rule::ARule,\n    ith_instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local conviction for the given rule.\n\nConviction attempts to measure the degree of implication of a rule. It's value ranges from 0 to +∞. Unlike lift, conviction is sensitive to rule direction; like lift, values far from 1 indicate interesting rules.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also AbstractMiner, antecedent, ARule, LogicalInstance, llift, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.gconviction","page":"Mining with modal logic","title":"ModalAssociationRules.gconviction","text":"function gconviction(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nSee also lconviction.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.lleverage","page":"Mining with modal logic","title":"ModalAssociationRules.lleverage","text":"function lleverage(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local leverage for the given rule.\n\nMeasures how much more counting is obtained from the co-occurrence of the antecedent and consequent from the expected (from independence).\n\nThis value ranges between [-0.25,0.25].\n\nSee also AbstractMiner, antecedent, ARule, consequent, LogicalInstance, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.gleverage","page":"Mining with modal logic","title":"ModalAssociationRules.gleverage","text":"function gleverage(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nSee also lleverage.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"In general, we can define new meaningfulness measures by leveraging the following macros, ensuring to avoid solving repeated subproblems when computing the measure.","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.@localmeasure","page":"Mining with modal logic","title":"ModalAssociationRules.@localmeasure","text":"macro localmeasure(measname, measlogic)\n\nBuild a generic local meaningfulness measure, levering the optimizations provided by any AbstractMiner.\n\nArguments\n\nmeasname: the name of the local measure you are defining (e.g., lsupport);\nmeaslogic: a lambda function whose arguments are (itemset, data, ith_instance, miner) -\n\nsee the note below to know more about this.\n\nnote: Note\nWhen defining a new local measure, you only need to write its essential logic through a lambda function (itemset, X, ith_instance, miner).In particular, itemset is an Itemset, X is a reference to the dataset, ith_instance is an integer defining on which instance you want to compute the measure, and miner is the AbstractMiner in which you want to save the measure.Also, miner argument can be used to leverage its miningstate structure. A complete example of the logic behind local support is shown below:_lsupport_logic = (itemset, X, ith_instance, miner) -> begin\n    # vector representing on which world an Itemset holds\n    wmask = [\n        check(formula(itemset), X, ith_instance, w) for w in allworlds(X, ith_instance)]\n\n    # return the result enriched with more informations, that will eventually will be\n    # used if miner's miningstate has specific fields (e.g., :worldmask).\n    return Dict(\n        :measure => count(wmask) / length(wmask),\n        :worldmask => wmask,\n    )\nend\n\nSee also AbstractMiner, hasminingstate, lsupport, miningstate.\n\n\n\n\n\n","category":"macro"},{"location":"modal-generalization/#ModalAssociationRules.@globalmeasure","page":"Mining with modal logic","title":"ModalAssociationRules.@globalmeasure","text":"macro globalmeasure(measname, measlogic)\n\nBuild a generic global meaningfulness measure, levering the optimizations provided by any AbstractMiner.\n\nArguments\n\nmeasname: the name of the global measure you are defining (e.g., gsupport);\nmeaslogic: a lambda function whose arguments are (rule, X, threshold, miner) - see the\n\nnote below to know more about this.\n\nnote: Note\nWhen defining a new global measure, you only need to write its essential logic through a lambda function (itemset, X, ith_instance, miner).In particular, itemset is an Itemset, X is a reference to the dataset and miner is the AbstractMiner in which you want to save the measure.Also, miner argument can be used to leverage its miningstate structure. A complete example of the logic behind global support is shown below:_gsupport_logic = (itemset, X, threshold, miner) -> begin\n    _measure = sum([\n        lsupport(itemset, getinstance(X, ith_instance), miner) >= threshold\n        for ith_instance in 1:ninstances(X)\n    ]) / ninstances(X)\n\n    # at the moment, no `miningstate` fields in miner are leveraged\n    return Dict(:measure => _measure)\nend\n\nSee also AbstractMiner, hasminingstate, gsupport, miningstate.\n\n\n\n\n\n","category":"macro"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"You can identify which is the local (global) counterpart of a global (local) meaningfulness measure with the following utility dispatches.","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.islocalof-Tuple{Function, Function}","page":"Mining with modal logic","title":"ModalAssociationRules.islocalof","text":"islocalof(::Function, ::Function)::Bool\n\nTwin method of isglobalof.\n\nTrait to indicate that a local meaningfulness measure is used as subroutine in a global measure.\n\nFor example, islocalof(lsupport, gsupport) is true, and isglobalof(gsupport, lsupport) is false.\n\nwarning: Warning\nWhen implementing a custom meaningfulness measure, make sure to implement both islocalof/isglobalof and localof/globalof. This is fundamental to guarantee the correct behavior of some methods, such as getlocalthreshold. Alternatively, you can simply use the macro @linkmeas.\n\nSee also getlocalthreshold, gsupport, isglobalof, linkmeas, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"modal-generalization/#ModalAssociationRules.localof-Tuple{Function}","page":"Mining with modal logic","title":"ModalAssociationRules.localof","text":"localof(::Function)::Union{Nothing,MeaningfulnessMeasure}\n\nReturn the local measure associated with the given one.\n\nSee also islocalof, isglobalof, globalof, linkmeas.\n\n\n\n\n\n","category":"method"},{"location":"modal-generalization/#ModalAssociationRules.isglobalof-Tuple{Function, Function}","page":"Mining with modal logic","title":"ModalAssociationRules.isglobalof","text":"isglobalof(::Function, ::Function)::Bool\n\nTwin trait of islocalof.\n\nSee also getlocalthreshold, gsupport, islocalof, linkmeas, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"modal-generalization/#ModalAssociationRules.globalof-Tuple{Function}","page":"Mining with modal logic","title":"ModalAssociationRules.globalof","text":"globalof(::Function)::Union{Nothing,MeaningfulnessMeasure} = nothing\n\nReturn the global measure associated with the given one.\n\nSee also linkmeas, islocalof, isglobalof, localof.\n\n\n\n\n\n","category":"method"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Of course, you can even link your custom measures.","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.@linkmeas","page":"Mining with modal logic","title":"ModalAssociationRules.@linkmeas","text":"macro linkmeas(gmeasname, lmeasname)\n\nLink together two MeaningfulnessMeasure, automatically defining globalof/localof and isglobalof/islocalof traits.\n\nSee also globalof, isglobalof, islocalof, localof, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"macro"},{"location":"modal-generalization/#Other-utilities","page":"Mining with modal logic","title":"Other utilities","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"Every algorithm implemented in this package is designed for the modal symbolic learning context. The are three common types appearing in such algorithms.","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.WorldMask","page":"Mining with modal logic","title":"ModalAssociationRules.WorldMask","text":"const WorldMask = BitVector\n\nBitmask whose i-th position stores whether a certain (local) MeaningfulnessMeasure applied on a specific Itemsets is true on the i-th world of a data instance.\n\nThe term \"world\" comes from the fact that a data instance is expressed as an entity-relation object, such as a SoleLogics.KripkeStructure.\n\nSee also Itemset, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.EnhancedItemset","page":"Mining with modal logic","title":"ModalAssociationRules.EnhancedItemset","text":"const EnhancedItemset = Tuple{Itemset,UInt32}\n\nCompressed representation of multiple, identical Itemsets.\n\nSee also Itemset.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.ConditionalPatternBase","page":"Mining with modal logic","title":"ModalAssociationRules.ConditionalPatternBase","text":"const ConditionalPatternBase = Vector{EnhancedItemset}\n\nCollection of EnhancedItemset.\n\nnote: Note\nThis plays a central role in the state-of-the-art algorithm fpgrowth, where a ConditionalPatternBase embodies all the information needed to build an FPTree data structure in the algorithm.\n\nSee also EnhancedItemset, fpgrowth, FPTree.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"We can enrich the MiningState of an AbstractMiner by using the following trait, depending on the specific algorithm and the kind of data we want to handle.","category":"page"},{"location":"data-loaders/#data-loaders","page":"Dataset loaders","title":"Dataset loaders","text":"","category":"section"},{"location":"data-loaders/#NATOPS","page":"Dataset loaders","title":"NATOPS","text":"","category":"section"},{"location":"data-loaders/#Libras","page":"Dataset loaders","title":"Libras","text":"","category":"section"},{"location":"data-loaders/#HuGaDB","page":"Dataset loaders","title":"HuGaDB","text":"","category":"section"},{"location":"data-loaders/#Epilepsy","page":"Dataset loaders","title":"Epilepsy","text":"","category":"section"},{"location":"#ModalAssociationRules","page":"Home","title":"ModalAssociationRules","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for ModalAssociationRules (or MAS), a Julia package for mining association rules.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MAS, simply launch:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModalAssociationRules\")","category":"page"},{"location":"#feature-summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Define atomic facts, called items, that can be true or false with respect to some instance data; for example, given a collection of signals I=[[1,2,3], [4,5,6], [7,8,9]], an item p could encode the fact that sum(I[2]) < 16.\nEnhance the expressivity of each item and combine them in sets, called itemsets, leveraging more-than-propositional logical formalisms; considering the instance data I above, for example, an item q could encode the fact that mean(I[3]) = 8 and q and after p encodes the fact that q is true for the i-th dimension of the instance and p is true at the same time on the (i+1)-th dimension.\nExtract the association rules hidden in data; for example, the rule p => q encodes the fact that, if p is true, then q is true too. The extraction process is easily configurable via a Miner object, and can be executed with the parallel implementation of state-of-the-art algorithms.\nAnalyze and recap the extract rules in a succinct manner.","category":"page"},{"location":"#Diagrams","page":"Home","title":"Diagrams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"What follows are the system and container context diagrams, delineating the environment of this package and its main components from an high level perspective.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: system context diagram, relating the user to this package which, in turn, interfaces with SoleLogics.jl and SoleData.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As shown in the schema above, MAS interfaces with two main dependencies. In fact, while the main purpose of this package is to extract constrained co-occurrence relations from data, the representation layer of logical facts and data is almost entirely provided by two packages. SoleLogics.jl provides both the syntactical and semantical aspects related to various logical formalisms; the q and after p example in the Feature Summary section is not casual, and refers to Halpern and Shoham's modal logic for time intervals, which SoleLogics provide. SoleData.jl is used to automatically create Kripke structures from the given data, that is, expliciting the latter in the form of relational data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: container context diagram, showing the main components of this package)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each of the components above is considered in the Advanced usage, Hands on and Contributing sections. The first one is a complement to the Getting started section, while the second one is designed for developers that who are willing to contribute to this package.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModalAssociationRules.jl lives in the context of Sole.jl, an open-source framework for symbolic machine learning, originally designed for machine learning based on modal logics (see Eduard I. Stan's PhD thesis 'Foundations of Modal Symbolic Learning' here).","category":"page"},{"location":"hands-on/#hands-on","page":"Hands on","title":"Hands-on","text":"","category":"section"},{"location":"hands-on/#A-real-case-usage-scenario","page":"Hands on","title":"A real case usage scenario","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - retrace the experiments for TIME 2025","category":"page"},{"location":"hands-on/#Implementing-a-new-meaningfulness-measure","page":"Hands on","title":"Implementing a new meaningfulness measure","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - implement a new measure, leveraging @localmemo and @globalmemo, and explaining what optimizations they introduce.","category":"page"},{"location":"hands-on/#Writing-a-new-mining-algorithm","page":"Hands on","title":"Writing a new mining algorithm","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - Write a new mining algorithm (e.g., Eclat)","category":"page"},{"location":"hands-on/#Write-a-new-AbstractMiner","page":"Hands on","title":"Write a new AbstractMiner","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - E.g., to implement an heuristic approach such as NSGA-II.","category":"page"},{"location":"algorithms/#algorithms","page":"Available algorithms","title":"Available algorithms","text":"","category":"section"},{"location":"algorithms/#Candidate-generation-based","page":"Available algorithms","title":"Candidate generation based","text":"","category":"section"},{"location":"algorithms/#ModalAssociationRules.apriori","page":"Available algorithms","title":"ModalAssociationRules.apriori","text":"apriori(miner::Miner; verbose::Bool=true)::Nothing\n\nApriori algorithm, as described here but generalized to also work with modal logic.\n\nArguments\n\nminer::M: miner containing the data and the extraction parameterization;\nprune_strategy::Function=grow_prune: strategy to prune candidates between one iteration\n\nand the successive;\n\nverbose::Bool=false: print informations about each iteration.\n\nSee also grow_prune, Miner, MineableData.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TreeProjection-based","page":"Available algorithms","title":"TreeProjection based","text":"","category":"section"},{"location":"algorithms/#FPGrowth","page":"Available algorithms","title":"FPGrowth","text":"","category":"section"},{"location":"algorithms/#ModalAssociationRules.fpgrowth","page":"Available algorithms","title":"ModalAssociationRules.fpgrowth","text":"fpgrowth(miner::AbstractMiner; verbose::Bool=true)::Nothing\n\n(Modal) FP-Growth algorithm, as described here.\n\nArguments\n\nminer: miner containing the extraction parameterization;\nX: data from which you want to mine association rules;\nparallel: enable multi-threaded execution, using Threads.nthreads() threads;\ndistributed: enable multi-processing execution, with Distributed.nworkers() processes;\nverbose: print detailed informations while the algorithm runs.\n\nRequirements\n\nThis implementation requires a custom Bulldozer constructor capable of handling the given AbstractMiner. In particular, the following dispatch must be implemented:\n\nBulldozer(miner::MyMinerType, ith_instance::Integer)\n\nSee also AbstractMiner, Bulldozer, FPTree, HeaderTable, SoleBase.AbstractDataset\n\n\n\n\n\n","category":"function"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on two data structures, FPTree and HeaderTable. To know more about them and their, please refer to the documentation here data-structures.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on the following two routines.","category":"page"},{"location":"algorithms/#ModalAssociationRules.patternbase-Tuple{Item, HeaderTable, Miner}","page":"Available algorithms","title":"ModalAssociationRules.patternbase","text":"patternbase(\n    item::Item,\n    htable::HeaderTable,\n    miner::AbstractMiner\n)::ConditionalPatternBase\n\nRetrieve the ConditionalPatternBase of fptree based on item.\n\nThe conditional pattern based on a FPTree is the set of all the paths from the tree root to nodes containing item (not included). Each of these paths is represented by an EnhancedItemset.\n\nThe EnhancedItemsets in the returned ConditionalPatternBase are sorted decreasingly by gsupport.\n\nSee also AbstractMiner, ConditionalPatternBase, EnhancedItemset, fpgrowth, FPTree, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ModalAssociationRules.projection-Tuple{Vector{Tuple{Vector{I} where I<:Item, Integer}}, Miner}","page":"Available algorithms","title":"ModalAssociationRules.projection","text":"function projection(pbase::ConditionalPatternBase, miner::AbstractMiner)\n\nReturn respectively a FPTree and a HeaderTable starting from pbase. An AbstractMiner must be provided to guarantee the generated header table internal state is OK, that is, its items are sorted decreasingly by gsupport.\n\nSee also ConditionalPatternBase, FPTree, gsupport, HeaderTable, AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Also, FPGrowth requires the Miner to remember the worlds associated with the extracted frequent itemsets. To add this functionality, we can define a new dispatch of initminingstate: it is automatically considered to enrich the miner, while building it together with fpgrowth as mining algorithm.","category":"page"},{"location":"algorithms/#ModalAssociationRules.initminingstate-Tuple{typeof(fpgrowth), AbstractDataset}","page":"Available algorithms","title":"ModalAssociationRules.initminingstate","text":"initminingstate(::typeof(fpgrowth), ::MineableData)::MiningState\n\nMiningState fields levereged when executing FP-Growth algorithm.\n\nSee also hasminingstate, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#Anchored-semantics","page":"Available algorithms","title":"Anchored semantics","text":"","category":"section"}]
}
