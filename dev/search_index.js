var documenterSearchIndex = {"docs":
[{"location":"data-structures/#data-structures","page":"Built-in data structures","title":"Built in data structures","text":"","category":"section"},{"location":"data-structures/#FPTree","page":"Built-in data structures","title":"FPTree","text":"","category":"section"},{"location":"data-structures/#ModalAssociationRules.FPTree","page":"Built-in data structures","title":"ModalAssociationRules.FPTree","text":"mutable struct FPTree\n    content::Union{Nothing,Item}        # Item contained in this node (nothing if root)\n\n    parent::Union{Nothing,FPTree}       # parent node\n    const children::Vector{FPTree}      # children nodes\n\n    count::Integer                      # number of equal Items this node represents\n\n    link::Union{Nothing,FPTree}         # link to another FPTree root\nend\n\nFundamental data structure used in FP-Growth algorithm. Essentialy, an FPTree is a prefix tree where a root-leaf path represent an Itemset.\n\nConsider the Itemsets sorted by gsupport of their items. An FPTree is such that the common Items-prefix shared by different Itemsets is not stored multiple times.\n\nThis implementation generalizes the propositional logic case scenario to modal logic; given two Itemsets sharing a Item prefix, the worlds in which they are true is accumulated.\n\ninfo: Info\nDid you notice? One FPTree structure contains all the information needed to construct an EnhancedItemset. This is crucial to generate new FPTrees during fpgrowth algorithm, via building ConditionalPatternBases iteratively while avoiding visiting the dataset over and over again.\n\nSee also EnhancedItemset, fpgrowth, gsupport, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.content-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.content","text":"content(fptree::FPTree)::Union{Nothing,Item}\n\nGetter for the Item (possibly empty) wrapped by fptree.\n\nSee also content!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.content!-Tuple{FPTree, Item}","page":"Built-in data structures","title":"ModalAssociationRules.content!","text":"content!(fptree::FPTree, item::Item)\n\nSetter for fptree's content (the wrapped item).\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.parent","text":"parent(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for the parent FPTrees of fptree.\n\nSee also FPTree, parent!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.parent!-Tuple{FPTree, Union{Nothing, FPTree}}","page":"Built-in data structures","title":"ModalAssociationRules.parent!","text":"parent!(fptree::FPTree, item::Union{Nothing,FPTree})\n\nSetter for fptree's parent FPTree.\n\nSee also FPTree, parent.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.children","text":"children(fptree::FPTree)::Vector{FPTree}\n\nGetter for the list of children FPTrees of fptree.\n\nSee also children!, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.children!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.children!","text":"children!(fptree::FPTree, child::FPTree)\n\nAdd a new FPTree to fptree's children vector.\n\nwarning: Warning\nThis method forces the new children to be added: it is a caller's responsability to check whether child is not already a children of fptree and, if so, handle the case. This check is performed, for example, in grow!.\n\nnote: Note\nThis method already sets the new children parent to fptree itself.\n\nSee also children, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.retrieveleaf","page":"Built-in data structures","title":"ModalAssociationRules.retrieveleaf","text":"function retrieveleaf(fptree::FPTree)::FPTree\n\nReturn a reference to the last node in a list-shaped FPTree.\n\nSee also FPTree;\n\n\n\n\n\n","category":"function"},{"location":"data-structures/#Base.count-Tuple{FPTree}","page":"Built-in data structures","title":"Base.count","text":"Base.count(fptree::FPTree)::Integer\n\nGetter for the fptree internal counter. Essentially, it represents the number of overlappings Item which ended up in fptree node during the building process of the tree itself.\n\nSee also count!, FPTree, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.count!-Tuple{FPTree, Integer}","page":"Built-in data structures","title":"ModalAssociationRules.count!","text":"count!(fptree::FPTree, newcount::Integer)\n\nSetter for fptree's internal counter to a fixed value newcount.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.addcount!-Tuple{FPTree, Integer}","page":"Built-in data structures","title":"ModalAssociationRules.addcount!","text":"addcount!(fptree::FPTree, newcount::Integer)\n\nAdd newcount to fptree's internal counter.\n\nSee also count, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.grow!-Union{Tuple{IT}, Tuple{FPTree, IT}} where IT<:(Vector{I} where I<:Item)","page":"Built-in data structures","title":"ModalAssociationRules.grow!","text":"function grow!(\n    fptree::FPTree,\n    itemset::Itemset,\n    ith_instance::Integer,\n    miner::AbstractMiner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\nfunction grow!(\n    fptree::FPTree,\n    itemset::EnhancedItemset,\n    ith_instance::Integer,\n    miner::AbstractMiner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\ngrow!(\n    fptree::FPTree,\n    enhanceditemsets::Union{ConditionalPatternBase,Vector{Itemset}},\n    miner::AbstractMiner;\n    htable::Union{Nothing,HeaderTable}=nothing\n)\n\nPush one or more Itemsets/EnhancedItemset to an FPTree. If an HeaderTable is provided, it is leveraged to develop internal links.\n\nSee also EnhancedItemset, FPTree, gsupport, HeaderTable, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link","text":"link(fptree::FPTree)::Union{Nothing,FPTree}\n\nGetter for fptree's next brother FPTree. fptree's brotherhood is the set of all the FPTree whose content is exactly fptree.content.\n\nSee also content, FPTree.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{FPTree, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link!","text":"function link!(from::FPTree, to::FPTree)\n\nEstablish a link between two FPTrees. If the starting tree is already linked with something, the already existing link are followed until a new \"empty-linked\" FPTree is found.\n\nSee also follow, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.follow","text":"function follow(fptree::FPTree)::Union{Nothing,FPTree}\n\nFollow fptree link to (an internal node of) another FPTree.\n\nSee also FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.islist-Tuple{FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.islist","text":"islist(fptree::FPTree)::Bool\n\nReturn true if every subtree in fptree has exactly 0 or 1 children.\n\nSee also FPTree\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#HeaderTable","page":"Built-in data structures","title":"HeaderTable","text":"","category":"section"},{"location":"data-structures/#ModalAssociationRules.HeaderTable","page":"Built-in data structures","title":"ModalAssociationRules.HeaderTable","text":"struct HeaderTable\n    items::Vector{Item}\n    link::Dict{Item,Union{Nothing,FPTree}}\nend\n\nUtility data structure used to fastly access FPTree internal nodes.\n\n\n\n\n\n","category":"type"},{"location":"data-structures/#ModalAssociationRules.items-Tuple{HeaderTable}","page":"Built-in data structures","title":"ModalAssociationRules.items","text":"items(htable::HeaderTable)::Vector{Item}\n\nGetter for the Items loaded inside htable.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link-Tuple{HeaderTable}","page":"Built-in data structures","title":"ModalAssociationRules.link","text":"link(htable::HeaderTable)\nlink(htable::HeaderTable, item::Item)\n\nGetter for the link structure wrapped by htable, or one of its specific entry.\n\nThe link structure is, essentially, a dictionary associating an Item to a specific FPTree.\n\nSee also FPTree, HeaderTable, Item, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.follow-Tuple{HeaderTable, Item}","page":"Built-in data structures","title":"ModalAssociationRules.follow","text":"function follow(htable::HeaderTable, item::Item)::Union{Nothing,FPTree}\n\nFollow htable link to (an internal node of) a FPTree.\n\nSee also FPTree, HeaderTable, Item, link, link!.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.link!-Tuple{HeaderTable, FPTree}","page":"Built-in data structures","title":"ModalAssociationRules.link!","text":"function link!(htable::HeaderTable, fptree::FPTree)\n\nEstablish a link towards fptree, following the entry in htable corresponding to the content of fptree.\n\nSee also content, FPTree, HeaderTable.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#ModalAssociationRules.checksanity!-Tuple{HeaderTable, Miner}","page":"Built-in data structures","title":"ModalAssociationRules.checksanity!","text":"function checksanity!(htable::HeaderTable, miner::AbstractMiner)::Bool\n\nCheck if htable internal state is correct, that is, its items are sorted decreasingly by global support. If items are already sorted, return true; otherwise, sort them and return false.\n\nSee also AbstractMiner, gsupport, HeaderTable, items.\n\n\n\n\n\n","category":"method"},{"location":"data-structures/#Base.reverse-Tuple{HeaderTable}","page":"Built-in data structures","title":"Base.reverse","text":"Base.reverse(htable::HeaderTable)\n\nIterator on htable wrapped Items, in reverse order.\n\nSee also HeaderTable, Item.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In this introductory section, you will learn about the main building blocks of ModalAssociationRules.jl.  Also if a good picture about association rule mining (ARM, from now onwards) is given during the documentation, to make the most out of this guide we suggest reading the following articles:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Association rule mining introduction and Apriori algorithm\nFPGrowth algorithm","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The above introduce two important algorithms, which are also built-in into this package. Moreover, the latter one is the state-of-the-art in the field of ARM.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Further on in the documentation, the potential of ModalAssociationRules.jl will emerge: this package's raison d'être is to generalize the already existing ARM algorithms to modal logics, which are more expressive than propositional ones and computationally less expensive than first-order logic. If you are new to Sole.jl and you want to learn more about modal logic, please have a look at SoleLogics.jl for a general overview on the topic, or follow this documentation and return to this link if needed.","category":"page"},{"location":"getting-started/#Core-definitions","page":"Getting started","title":"Core definitions","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"One Item is just a logical formula, which can be interpreted by a certain model. At the moment, here, we don't care about how models are represented by Sole.jl under the hood, or how the checking algorithm works: what matters is that Items are manipulated by ARM algorithms, which try to find which conjunctions between items are most statistically significant.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Item","page":"Getting started","title":"ModalAssociationRules.Item","text":"struct Item{F<:SoleLogics.Formula}\n    formula::F\nend\n\nFundamental type in the context of association rule mining.\n\nThe name Item comes from the classical association rule mining jargon, but it is simply a wrapper around a logical formula, whose truth value can be checked on a model. To know more about logical formulas, see SoleLogics.Formula.\n\nSee also ARule, gconfidence, Itemset, MeaningfulnessMeasure, SoleLogics.Formula.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.Itemset","page":"Getting started","title":"ModalAssociationRules.Itemset","text":"const Itemset{I<:Item} = Vector{I}\n\nVector collecting multiple Items.\n\nSemantically, Itemsets represent Items (that is, formulas) conjunctions.\n\nnote: Note\nIn the context of association rule mining, interesting itemsets are manipulated to discover interesting relations between Items, in the form of association rules (ARule).Interestingness is established through a set of MeaningfulnessMeasure.\n\ndetails: Details\nItemsets are implemented as a vector for two reasons:lookup is fasterwhen the collection is small (an itemset is unlikely to consist of more than 100 items);most of the time, we want to keep an ordering between items while searching forinteresting itemsets.\n\nExamples\n\njulia> p = ScalarCondition(VariableMin(1), >, 1.0)  |> Atom |> Item\nmin[V1] > 1.0\njulia> q = ScalarCondition(VariableMin(2), >=, 0.0) |> Atom |> Item\nmin[V2] ≥ 0.0\n\njulia> pq = Itemset([p,q])\njulia> qp = Itemset([q,p])\n\njulia> pq == qp\ntrue\njulia> pq === qp\nfalse\n\njulia> r = ScalarCondition(VariableMax(3), <=, 2.0) |> Atom |> Item\nmax[V3] ≤ 2.0\njulia> pqr = [pq; r];\n\njulia> pq in pqr\ntrue\n\njulia> formula(pqr) |> syntaxstring\n\"(min[V1] > 1.0) ∧ (min[V2] ≥ 0.0) ∧ (max[V3] ≤ 2.0)\"\n\nSee also ARule, formula, gsupport, Item, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Notice that one Itemset could be a set, but actually it is a vector: this is because, often, ARM algorithms need to establish an order between items in itemsets to work efficiently. To convert an Itemset in its conjunctive normla form we simply call formula.","category":"page"},{"location":"getting-started/#ModalAssociationRules.formula","page":"Getting started","title":"ModalAssociationRules.formula","text":"formula(item::Item{F}) where {F}\n\nSee also Item, SoleLogics.Formula.\n\n\n\n\n\nformula(itemset::Itemset)::SoleLogics.LeftmostConjunctiveForm\n\nConjunctive normal form of the Items contained in itemset.\n\nSee also Item, Itemset, SoleLogics.LeftmostConjunctiveForm\n\n\n\n\n\n","category":"function"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In general, an Itemset behaves exactly like you would expect a Vector{Item} would do. At the end of the day, the only difference is that manipulating an Itemset, for example through push! or union, guarantees the wrapped items always keep the same sorting.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Enough about Itemsets. Our final goal is to produce association rules. ","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARule","page":"Getting started","title":"ModalAssociationRules.ARule","text":"const ARule = Tuple{Itemset,Itemset}\n\nAn association rule represents a frequent and meaningful co-occurrence relationship of the form \"X ⇒ Y\", between two Itemsets X and Y, where X ∩ Y = ∅, respectively called antecedent and consequent.\n\nnote: Note\nExtracting all the ARule \"hidden\" in the data is the main purpose of association rule mining (ARM).Given an itemset Z containing atleast two Items (|Z| ≥ 2), it can be partitioned in two (sub)itemsets X and Y; trying all the possible binary partitioning of Z is a systematic way to generate ARules.The general framework always followed by ARM techniques is to, firstly, generate all the frequent itemsets considering a set of MeaningfulnessMeasure specifically tailored to work with Itemsets.Thereafter, all the association rules are generated by testing all the combinations of frequent itemsets against another set of MeaningfulnessMeasure, this time designed to capture how interesting a rule is.\n\nSee also antecedent, consequent, gconfidence, Itemset, lconfidence, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.content-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.content","text":"content(rule::ARule)::Tuple{Itemset,Itemset}\n\nGetter for the content of an ARule, that is, both its antecedent and its consequent.\n\nSee also antecedent, ARule, consequent, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.antecedent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.antecedent","text":"antecedent(rule::ARule)::Itemset\n\nGetter for rule's antecedent.\n\nSee also antecedent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.consequent-Tuple{ARule}","page":"Getting started","title":"ModalAssociationRules.consequent","text":"consequent(rule::ARule)::Itemset\n\nGetter for rule's consequent.\n\nSee also consequent, ARule, Itemset.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To print an ARule enriched with more informations (at the moment, this is everything we need to know), we can use the following.","category":"page"},{"location":"getting-started/#ModalAssociationRules.arule_analysis-Tuple{ARule, Miner}","page":"Getting started","title":"ModalAssociationRules.arule_analysis","text":"arule_analysis(arule::ARule, miner::Miner; io::IO=stdout, localities=false)\n\nSee also arule_analysis(::Arule, ::AbstractMiner), ARule, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Sometimes we could be interested in writing a function that consider a generic entity obtained through an association rule mining algorithm (frequent itemsets and, of course, association rules). Think about a dictionary mapping some extracted pattern to metadata. We call that generic entity \"an ARM subject\", and the following union type comes in help.","category":"page"},{"location":"getting-started/#ModalAssociationRules.ARMSubject","page":"Getting started","title":"ModalAssociationRules.ARMSubject","text":"ARMSubject = Union{ARule,Itemset}\n\nEach entity mined through an association rule mining algorithm.\n\nSee also ARule, GmeasMemo, GmeasMemoKey, Itemset, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Measures","page":"Getting started","title":"Measures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To establish when an ARMSubject is interesting, we need meaningfulness measures. ","category":"page"},{"location":"getting-started/#ModalAssociationRules.Threshold","page":"Getting started","title":"ModalAssociationRules.Threshold","text":"const Threshold = Float64\n\nThreshold value type for MeaningfulnessMeasures.\n\nSee also gconfidence, gsupport, lconfidence, lsupport, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.MeaningfulnessMeasure","page":"Getting started","title":"ModalAssociationRules.MeaningfulnessMeasure","text":"const MeaningfulnessMeasure = Tuple{Function, Threshold, Threshold}\n\nTo fully understand this description, we suggest reading this article.\n\nIn the classic propositional case scenario, we can think each instance as a propositional interpretation, or equivalently, as a Kripke frame containing only one world. In this setting, a meaningfulness measure indicates how many times a specific property of an Itemset (or an ARule) is satisfied.\n\nThe most important meaningfulness measure is support, defined as \"the number of instances in a dataset that satisfy an itemset\" (it is defined similarly for association rules, where we consider the itemset obtained by combining both rule's antecedent and consequent). Other meaningfulness measures can be defined in function of support.\n\nIn the context of modal logic, where the instances of a dataset are relational objects called Kripke frames, every meaningfulness measure must capture two aspects: how much an Itemset or an ARule is meaningful within an instance, and how much the same object is meaningful across all the instances, that is, how many times it resulted meaningful within an instance. Note that those two aspects coincide in the propositional scenario.\n\nWhen a meaningfulness measure is applied locally within an instance, it is said to be \"local\". Otherwise, it is said to be \"global\". For example, local support is defined as \"the number of worlds within an instance, which satisfy an itemset\". To define global support we need to define a minimum local support threshold sl which is a real number between 0 and 1. Now, we can say that global support is \"the number of instances for which local support overpassed the minimum local support threshold\".\n\nAs in the propositional setting, more meaningfulness measures can be defined starting from support, but now they must respect the local/global dichotomy.\n\nWe now have all the ingredients to understand this type definition. A MeaningfulnessMeasure is a tuple composed of a global meaningfulness measure, a local threshold used internally, and a global threshold we would like our itemsets (rules) to overpass.\n\nSee also gconfidence, gsupport, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.islocalof-Tuple{Function, Function}","page":"Getting started","title":"ModalAssociationRules.islocalof","text":"islocalof(::Function, ::Function)::Bool\n\nTwin method of isglobalof.\n\nTrait to indicate that a local meaningfulness measure is used as subroutine in a global measure.\n\nFor example, islocalof(lsupport, gsupport) is true, and isglobalof(gsupport, lsupport) is false.\n\nwarning: Warning\nWhen implementing a custom meaningfulness measure, make sure to implement both islocalof/isglobalof and localof/globalof. This is fundamental to guarantee the correct behavior of some methods, such as getlocalthreshold. Alternatively, you can simply use the macro @linkmeas.\n\nSee also getlocalthreshold, gsupport, isglobalof, linkmeas, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localof-Tuple{Function}","page":"Getting started","title":"ModalAssociationRules.localof","text":"localof(::Function)::Union{Nothing,MeaningfulnessMeasure}\n\nReturn the local measure associated with the given one.\n\nSee also islocalof, isglobalof, globalof, linkmeas.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.isglobalof-Tuple{Function, Function}","page":"Getting started","title":"ModalAssociationRules.isglobalof","text":"isglobalof(::Function, ::Function)::Bool\n\nTwin trait of islocalof.\n\nSee also getlocalthreshold, gsupport, islocalof, linkmeas, lsupport.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalof-Tuple{Function}","page":"Getting started","title":"ModalAssociationRules.globalof","text":"globalof(::Function)::Union{Nothing,MeaningfulnessMeasure} = nothing\n\nReturn the global measure associated with the given one.\n\nSee also linkmeas, islocalof, isglobalof, localof.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The following are little data structures which will return useful later, when you will read about how a dataset is mined, looking for ARMSubjects.","category":"page"},{"location":"getting-started/#ModalAssociationRules.LmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.LmeasMemoKey","text":"const LmeasMemoKey = Tuple{Symbol,ARMSubject,Integer}\n\nKey of a LmeasMemo dictionary. Represents a local meaningfulness measure name (as a Symbol), a ARMSubject, and the number of a dataset instance where the measure is applied.\n\nSee also ARMSubject, LmeasMemo, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.LmeasMemo","page":"Getting started","title":"ModalAssociationRules.LmeasMemo","text":"const LmeasMemo = Dict{LmeasMemoKey,Threshold}\n\nAssociation between a local measure of a ARMSubject on a specific dataset instance, and its value.\n\nSee also ARMSubject, LmeasMemo, lsupport, lconfidence.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemoKey","page":"Getting started","title":"ModalAssociationRules.GmeasMemoKey","text":"const GmeasMemoKey = Tuple{Symbol,ARMSubject}\n\nKey of a GmeasMemo dictionary. Represents a global meaningfulness measure name (as a Symbol) and a ARMSubject.\n\nSee also ARMSubject, GmeasMemo, gconfidence, gsupport.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.GmeasMemo","page":"Getting started","title":"ModalAssociationRules.GmeasMemo","text":"const GmeasMemo = Dict{GmeasMemoKey,Threshold}\n\nAssociation between a global measure of a ARMSubject on a dataset, and its value.\n\nThe reference to the dataset is not explicited here, since GmeasMemo is intended to be used as a memoization structure inside Miner objects, and the latter already knows the dataset they are working with.\n\nSee also GmeasMemoKey, ARMSubject.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"What follows is a list of the already built-in meaningfulness measures. In the Hands on section you will learn how to implement your own measure. More information are available in the Modal generalization section.","category":"page"},{"location":"getting-started/#ModalAssociationRules.lsupport","page":"Getting started","title":"ModalAssociationRules.lsupport","text":"function lsupport(\n    itemset::Itemset,\n    instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local support for the given itemset in the given instance.\n\nLocal support is the ratio between the number of worlds in a LogicalInstance where and Itemset is true and the total number of worlds where the Itemset can be checked.\n\nSee also SoleLogics.check, Miner, gsupport, LogicalInstance, Itemset, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#ModalAssociationRules.gsupport","page":"Getting started","title":"ModalAssociationRules.gsupport","text":"function gsupport(\n    itemset::Itemset,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the global support for the given itemset on a logiset X, considering threshold as the threshold for the local support called internally.\n\nGlobal support is the ratio between the number of LogicalInstances in a SupportedLogiset for which the local support, lsupport, is greater than a Threshold, and the total number of instances in the same logiset.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also Miner, lsupport, LogicalInstance, Itemset, SupportedLogiset, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#ModalAssociationRules.lconfidence","page":"Getting started","title":"ModalAssociationRules.lconfidence","text":"function lconfidence(\n    rule::ARule,\n    ith_instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local confidence for the given rule.\n\nLocal confidence is the ratio between lsupport of an ARule on a LogicalInstance and the lsupport of the antecedent of the same rule.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also AbstractMiner, antecedent, ARule, LogicalInstance, lsupport, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#ModalAssociationRules.gconfidence","page":"Getting started","title":"ModalAssociationRules.gconfidence","text":"function gconfidence(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the global confidence for the given rule on a logiset X, considering threshold as the threshold for the global support called internally.\n\nGlobal confidence is the ratio between gsupport of an ARule on a SupportedLogiset and the gsupport of the only antecedent of the same rule.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also antecedent, ARule, AbstractMiner, gsupport, SupportedLogiset.\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Mining-structures","page":"Getting started","title":"Mining structures","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we are ready to start mining. To do so, we can create a custom AbstractMiner type.","category":"page"},{"location":"getting-started/#ModalAssociationRules.AbstractMiner","page":"Getting started","title":"ModalAssociationRules.AbstractMiner","text":"Any entity capable of perform association rule mining.\n\nInterface\n\nEach new concrete miner structure must define the following getters and setters. Actually, depending on its purposes, a structure may partially implement these dispatches. For example, Miner does completely implement the interface while Bulldozer does not.\n\ndata(miner::AbstractMiner)\nitems(miner::AbstractMiner)\nalgorithm(miner::AbstractMiner)\nfreqitems(miner::AbstractMiner)\narules(miner::AbstractMiner)\nitemsetmeasures(miner::AbstractMiner)\narulemeasures(miner::AbstractMiner)\nlocalmemo(miner::AbstractMiner)\nlocalmemo!(miner::AbstractMiner)\nglobalmemo(miner::AbstractMiner)\nglobalmemo!(miner::AbstractMiner)\nworldfilter(miner::AbstractMiner)\nitemset_policies(miner::AbstractMiner)\narule_policies(miner::AbstractMiner)\nminingstate(miner::AbstractMiner)\nminingstate!(miner::AbstractMiner)\ninfo(miner::AbstractMiner)\n\nSee also Miner, Bulldozer.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The main implementation of such an interface is embodied by the Miner object. To mine using a Miner, we just need to specify which dataset we are working with, together with a mining function, a vector of initial Items, and the MeaningfulnessMeasures to establish ARMSubject interestingness.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Miner","page":"Getting started","title":"ModalAssociationRules.Miner","text":"struct Miner{\n    D<:MineableData,\n    I<:Item\n} <: AbstractMiner\n    X::D                            # target dataset\n\n    algorithm::Function             # algorithm used to perform extraction\n\n    items::Vector{I}                # alphabet\n\n    # meaningfulness measures\n    itemset_constrained_measures::Vector{<:MeaningfulnessMeasure}\n    arule_constrained_measures::Vector{<:MeaningfulnessMeasure}\n\n    freqitems::Vector{Itemset}      # collected frequent itemsets\n    arules::Vector{ARule}           # collected association rules\n\n    localmemo::LmeasMemo            # local memoization structure\n    globalmemo::GmeasMemo           # global memoization structure\n\n    worldfilter::Union{Nothing,WorldFilter} # metarules about world filterings\n    itemset_policies::Vector{<:Function}    # metarules about itemsets mining\n    arule_policies::Vector{<:Function}      # metarules about arules mining\n\n    miningstate::MiningState        # mining algorithm miningstate (see documentation)\n\n    info::Info                      # general informations\n\n    # locks on memoization and miningstate structures\n    lmemolock::ReentrantLock\n    gmemolock::ReentrantLock\n    miningstatelock::ReentrantLock\nend\n\nConcrete AbstractMiner containing both the data, the logic and the parameterization to perform association rule mining in the modal setting.\n\nExamples\n\njulia> using ModalAssociationRules\njulia> using SoleData\n\n# Load NATOPS DataFrame\njulia> X_df, y = load_NATOPS();\n\n# Convert NATOPS DataFrame to a Logiset\njulia> X = scalarlogiset(X_df)\n\n# Prepare some propositional atoms\njulia> p = Atom(ScalarCondition(VariableMin(1), >, -0.5))\njulia> q = Atom(ScalarCondition(VariableMin(2), <=, -2.2))\njulia> r = Atom(ScalarCondition(VariableMin(3), >, -3.6))\n\n# Prepare modal atoms using later relationship - see [`SoleLogics.IntervalRelation`](@ref))\njulia> lp = box(IA_L)(p)\njulia> lq = diamond(IA_L)(q)\njulia> lr = box(IA_L)(r)\n\n# Compose a vector of items, regrouping the atoms defined before\njulia> my_alphabet = Vector{Item}([p, q, r, lp, lq, lr])\n\n# Establish which meaningfulness measures you want to define the notion of itemset and\n# association rule holding on an instance and on a modal dataset\njulia> my_itemsetmeasures = [(gsupport, 0.1, 0.1)]\njulia> my_rulemeasures = [(gconfidence, 0.1, 0.1)]\n\n# (optional) Establish a filter to iterate the worlds in a generic modal instance\njulia> my_worldfilter = SoleLogics.FunctionalWorldFilter(\n        x -> length(x) >= 3 && length(x) <= 10, Interval{Int}\n    )\n\n# (optional) Establish a policy to further restrict itemsets that can be considered frequent\njulia> my_itemset_policies = [islimited_length_itemset()]\n\n# (optional) Establish a policy to further restrict rules that can be considered\n# association rules\njulia> my_arule_policies = [\n        islimited_length_arule(), isanchored_arule(), isheterogeneous_arule()\n    ]\n\n# Create an association rule miner wrapping `fpgrowth` algorithm - see [`fpgrowth`](@ref);\njulia> miner = Miner(X, fpgrowth, my_alphabet,\n        my_itemsetmeasures, my_rulemeasures,\n        worldfilter=my_worldfilter,\n        itemset_policies=my_itemset_policies,\n        arule_policies=my_arule_policies\n    )\n\n# We mine using mine!\n# (optional) We could pass kwargs to forward them to the mining algorithm\njulia> mine!(miner)\n\n# Print all the mined association rules\njulia> for arule in generaterules(miner)\n    println(arule)\nend\n\nSee also  ARule, Bulldozer, MeaningfulnessMeasure, Info, isanchored_arule, isheterogeneous_arule, islimited_length_arule(), islimited_length_itemset(), Item, Itemset, GmeasMemo, LmeasMemo, MiningState, SoleLogics.WorldFilter.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let us see which getters and setters are available for Miner.","category":"page"},{"location":"getting-started/#ModalAssociationRules.data-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.data","text":"data(miner::Miner)::MineableData\n\nSee data(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.algorithm-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.algorithm","text":"algorithm(miner::Miner)::Function\n\nSee algorithm(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.items-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.items","text":"items(miner::Miner)\n\nSee items(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.measures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.measures","text":"measures(miner::AbstractMiner)::Vector{<:MeaningfulnessMeasure}\n\nReturn all the MeaningfulnessMeasures wrapped by miner.\n\nSee also AbstractMiner, itemsetmeasures, MeaningfulnessMeasure, arulemeasures.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.findmeasure-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.findmeasure","text":"findmeasure(\n    miner::AbstractMiner,\n    meas::Function;\n    recognizer::Function=islocalof\n)::MeaningfulnessMeasure\n\nRetrieve the MeaningfulnessMeasure associated with meas within miner.\n\nSee also isglobalof, islocalof, MeaningfulnessMeasure, AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemsetmeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.itemsetmeasures","text":"itemsetmeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nSee [itemsetmeasures(::AbstractMiner)]\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.arulemeasures-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.arulemeasures","text":"arulemeasures(miner::Miner)::Vector{<:MeaningfulnessMeasure}\n\nSee arulemeasures(miner::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getlocalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getlocalthreshold","text":"getlocalthreshold(miner::AbstractMiner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work locally (that is, analyzing \"the inside\" of a dataset's instances) in miner.\n\nSee AbstractMiner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.getglobalthreshold-Tuple{Miner, Function}","page":"Getting started","title":"ModalAssociationRules.getglobalthreshold","text":"getglobalthreshold(miner::AbstractMiner, meas::Function)::Threshold\n\nGetter for the Threshold associated with the function wrapped by some MeaningfulnessMeasure tailored to work globally (that is, measuring the behavior of a specific local-measure across all dataset's instances) in miner.\n\nSee AbstractMiner, MeaningfulnessMeasure, Threshold.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"After a Miner ends mining (we will see how to mine in a second), frequent Itemsets and ARule are accessible through the getters below.","category":"page"},{"location":"getting-started/#ModalAssociationRules.freqitems-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.freqitems","text":"freqitems(miner::Miner)\n\nSee freqitems(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.arules-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.arules","text":"arules(miner::Miner) See arules(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To start the mining algorithm, simply call the following:","category":"page"},{"location":"getting-started/#ModalAssociationRules.mine!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.mine!","text":"mine!(miner::AbstractMiner; kwargs...)\n\nSynonym for `apply!.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The mining call returns an ARule generator. Since the extracted rules could be several, it's up to you to collect all the rules in a step or arule_analysis them lazily, collecting them one at a time. You can also call the mining function ignoring it's return value, and then generate the rules later by calling the following.","category":"page"},{"location":"getting-started/#ModalAssociationRules.generaterules!-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.generaterules!","text":"generaterules!(miner::Miner)\n\nSee generaterules(::AbstractVector{Itemset}, ::Miner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"During both the mining and the rules generation phases, the values returned by MeaningfulnessMeasure applied on a certain ARMSubject are saved (memoized) inside the Miner. Thanks to the methods hereafter, a Miner can avoid useless recomputations.","category":"page"},{"location":"getting-started/#ModalAssociationRules.localmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.localmemo","text":"localmemo(miner::Miner)::LmeasMemo\n\nSee localmemo(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject, Integer}, Float64}","page":"Getting started","title":"ModalAssociationRules.localmemo!","text":"localmemo!(miner::Miner, key::LmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the local memoization structure wrapped by miner.\n\nSee also Miner, LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.globalmemo","text":"globalmemo(miner::Miner)::GmeasMemo\n\nSee globalmemo(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.globalmemo!-Tuple{Miner, Tuple{Symbol, ARMSubject}, Float64}","page":"Getting started","title":"ModalAssociationRules.globalmemo!","text":"globalmemo!(miner::Miner, key::GmeasMemoKey, val::Threshold)\n\nSetter for a specific entry key inside the global memoization structure wrapped by miner.\n\nSee also Miner, GmeasMemo, GmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Miner-customization","page":"Getting started","title":"Miner customization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A Miner also contains two fields to keep additional information, those are info and miningstate.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The info field in Miner is a dictionary used to store extra information about the miner, such as statistics about mining. Currently, since the package is still being developed, the info field only contains a flag indicating whether the miner has been used for mining or not.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Info","page":"Getting started","title":"ModalAssociationRules.Info","text":"const Info = Dict{Symbol,Any}\n\nStorage reserved to metadata about mining (e.g., execution time).\n\nSee also info, info!, hasinfo, Miner.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.info-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.info","text":"info(miner::Miner)::Info = miner.info\n\nGetter for miner's structure holding meta informations about mining.\n\nSee also Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.info!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.info!","text":"info!(miner::Miner, key::Symbol, val)\n\nSetter for miner's metadata.\n\nSee also hasinfo, info, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasinfo-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasinfo","text":"hasinfo(miner::AbstractMiner, key::Symbol)\n\nReturn whether miner additional informations field contains an entry key.\n\nSee also AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"When writing your own mining algorithm, or when mining with a particular kind of dataset, you might need to specialize the Miner, keeping, for example, custom metadata and data structures. To specialize a Miner, you can fill a MiningState structure to fit your needs.","category":"page"},{"location":"getting-started/#ModalAssociationRules.MiningState","page":"Getting started","title":"ModalAssociationRules.MiningState","text":"const MiningState = Dict{Symbol,Any}\n\nAdditional informations associated with an ARMSubject that can be used to specialize any concrete type deriving from AbstractMiner, thus augmenting its capabilities.\n\nTo understand how to specialize a Miner, see hasminingstate, initminingstate, 'miningstate`, miningstate!.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.miningstate-Tuple{Miner}","page":"Getting started","title":"ModalAssociationRules.miningstate","text":"miningstate(miner::Miner)\n\nSee miningstate(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstate!-Tuple{Miner, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.miningstate!","text":"miningstate!(miner::Miner, key::Symbol, val)\n\nSetter for the content of a specific field of miner's miningstate.\n\nSee also Miner, hasminingstate, initminingstate, MiningState.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasminingstate-Tuple{Miner, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasminingstate","text":"hasminingstate(miner::Miner, key::Symbol)\n\nReturn whether miner miningstate contains a field key.\n\nSee also Miner, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.initminingstate-Tuple{Function, AbstractDataset}","page":"Getting started","title":"ModalAssociationRules.initminingstate","text":"initminingstate(::Function, ::MineableData)\n\nThis trait defines how to initialize the MiningState structure of an AbstractMiner, in order to customize it to your needings depending on a specific function/data pairing.\n\nSee ealso hasminingstate, AbstractMiner, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Parallelization","page":"Getting started","title":"Parallelization","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To support parallel mining, we provide a Bulldozer miner, that is, a lightweight copy of Miner which mines a specific section of the data in its own thread.","category":"page"},{"location":"getting-started/#ModalAssociationRules.Bulldozer","page":"Getting started","title":"ModalAssociationRules.Bulldozer","text":"struct Bulldozer{\n    I<:Item,\n    IMEAS<:MeaningfulnessMeasure\n} <: AbstractMiner\n    # data mineable by the Bulldozer\n    data::D\n\n    # original instance ids associated with the current slice of data\n    # if this is 5:10, this this means that the first instance of the slice is\n    # the original fifth and so on.\n    instancesrange::UnitRange{<:Integer}\n\n    # alphabet\n    items::Vector{I}\n\n    # measures associated with mined itemsets\n    itemsetmeasures::Vector{<:MeaningfulnessMeasure}\n\n    # meaningfulness measures memoization structure\n    localmemo::LmeasMemo\n\n    # special fields related to mining algorithms\n    worldfilter::Union{Nothing,WorldFilter}\n    itemset_policies::Vector{<:Function}\n    miningstate::MiningState\n\n    # locks on data, memoization structure and miningstate structure\n    datalock::ReentrantLock\n    memolock::ReentrantLock\n    miningstatelock::ReentrantLock\n}\n\nConcrete AbstractMiner specialized to mine a single modal instance.\n\nBulldozer's interface is similar to Miner's one, but contains only the essential fields necessary to work locally within a Kripke structure, and is designed to be thread-safe.\n\nnote: Note\nBulldozers are designed to easily implement multi-threaded mining algorithms. When doing so, you can use a monolithic miner structure to collect the initial parameterization, map the computation on many bulldozers, each of which can be easily constructed from the miner itself, and then reduce the results together.\n\nSee also AbstractMiner, Miner.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#ModalAssociationRules.datalock-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.datalock","text":"datalock(bulldozer::Bulldozer)\n\nGetter for the ReentrantLock associated with the SoleLogics.LogicalInstance wrapped by a Bulldozer.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.memolock-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.memolock","text":"memolock(bulldozer::Bulldozer)\n\nGetter for the ReentrantLock associated with the inner Bulldozer's memoization structure\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstatelock-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.miningstatelock","text":"miningstatelock(bulldozer::Bulldozer)\n\nGetter for the ReentrantLock associated with the customizable dictionary within a Bulldozer.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.datatype-Union{Tuple{Bulldozer{D}}, Tuple{D}} where D<:AbstractDataset","page":"Getting started","title":"ModalAssociationRules.datatype","text":"datatype(::Bulldozer{D}) where {D<:MineableData} = D\n\nReturn the type of the MineableData given by data(::Bulldozer).\n\nSee also Bulldozer, data(::Bulldozer), MineableData.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemtype-Union{Tuple{Bulldozer{D, I}}, Tuple{I}, Tuple{D}} where {D, I<:Item}","page":"Getting started","title":"ModalAssociationRules.itemtype","text":"itemtype(::Bulldozer{D,I}) where {D,I<:Item} = I\n\nReturn the type of the Items given by items(::Bulldozer).\n\nSee also Bulldozer, items(::Bulldozer), MineableData.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.instancesrange-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.instancesrange","text":"instancesrange(bulldozer::Bulldozer)\n\nReturn the instance slice range on which bulldozer is working.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.instanceprojection-Tuple{Bulldozer, Integer}","page":"Getting started","title":"ModalAssociationRules.instanceprojection","text":"instanceprojection(bulldozer::Bulldozer, ith_instance::Integer)\n\nMaps the ith_instance on a range starting from 1, instead of instancerange.\n\nSee also Bulldozer, instancerange.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.data-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.data","text":"data(bulldozer::Bulldozer)\ndata(bulldozer::Bulldozer, ith_instance::Integer)\n\nGetter for the MineableData wrapped within bulldozer, or a specific instance.\n\nSee data(::AbstractMiner), SoleLogics.LogicalInstance, MineableData.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.items-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.items","text":"items(bulldozer::Bulldozer)\n\nSee items(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemsetmeasures-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.itemsetmeasures","text":"itemsetmeasures(bulldozer::Bulldozer)::Vector{<:MeaningfulnessMeasure}\n\nSee also itemsetmeasures(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.localmemo-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.localmemo","text":"localmemo(bulldozer::Bulldozer)\nlocalmemo(bulldozer::Bulldozer, key::LmeasMemoKey)\n\nSee localmemo(::AbstractMiner), LmeasMemo, LmeasMemoKey.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.worldfilter-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.worldfilter","text":"worldfilter(bulldozer::Bulldozer) = bulldozer.worldfilter\n\nSee also worldfilter(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.itemset_policies-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.itemset_policies","text":"itemset_policies(bulldozer::Bulldozer)\n\nSee also itemset_policies(::AbstractMiner).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstate-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.miningstate","text":"miningstate(bulldozer::Bulldozer)::MiningState\nminingstate(bulldozer::Bulldozer, key::Symbol)::Any\nminingstate(bulldozer::Bulldozer, key::Symbol, inner_key)::Any\n\nGetter for the customizable dictionary wrapped by a Bulldozer.\n\nSee also [miningstate!(::Bulldozer)].\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miningstate!-Tuple{Bulldozer, Symbol, Any}","page":"Getting started","title":"ModalAssociationRules.miningstate!","text":"miningstate!(bulldozer::Bulldozer, key::Symbol, val)\nminingstate!(bulldozer::Bulldozer, key::Symbol, inner_key, val)\n\nSetter for the content of a specific bulldozer's miningstate.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.hasminingstate-Tuple{Bulldozer, Symbol}","page":"Getting started","title":"ModalAssociationRules.hasminingstate","text":"hasminingstate(bulldozer::Bulldozer, key::Symbol)\n\nReturn whether bulldozer miningstate field contains a field key.\n\nSee also Bulldozer, miningstate, miningstate!.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.measures-Tuple{Bulldozer}","page":"Getting started","title":"ModalAssociationRules.measures","text":"measures(bulldozer::Bulldozer)\n\nSynonym for itemsetmeasures. This exists to adhere to Miner's interface.\n\nSee also Bulldozer, itemsetmeasures, Miner.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.miner_reduce!-Union{Tuple{AbstractVector{B}}, Tuple{B}} where B<:Bulldozer","page":"Getting started","title":"ModalAssociationRules.miner_reduce!","text":"function miner_reduce!(b1::Bulldozer, b2::Bulldozer)::LmeasMemo\n\nReduce many Bulldozers together, merging their local memo structures in linear time.\n\nnote: Note\nThis method will soon be deprecated in favour of a general dispatch miner_reduce!(::AbstractVector{M})\n\nSee also LmeasMemo, localmemo(::Bulldozer);\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#ModalAssociationRules.load_localmemo!-Tuple{AbstractMiner, Dict{Tuple{Symbol, ARMSubject, Integer}, Float64}}","page":"Getting started","title":"ModalAssociationRules.load_localmemo!","text":"function load_localmemo!(miner::AbstractMiner, localmemo::LmeasMemo)\n\nLoad a local memoization structure inside miner. Also, returns a dictionary associating each loaded local Itemset loaded to its its global support, in order to simplify miner's job when working in the global setting.\n\nSee also Itemset, LmeasMemo, lsupport, Miner.\n\n\n\n\n\n","category":"method"},{"location":"advanced/#man-advanced","page":"Advanced usage","title":"Advanced usage","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The following utilities often involve performing some combinatoric trick between Itemsets and ARules, and might be useful to avoid reinventing the wheel.","category":"page"},{"location":"advanced/#Items-and-Itemsets","page":"Advanced usage","title":"Items and Itemsets","text":"","category":"section"},{"location":"advanced/#ModalAssociationRules.combine_items","page":"Advanced usage","title":"ModalAssociationRules.combine_items","text":"combine_items(itemsets::AbstractVector{<:Itemset}, newlength::Integer)\n\nReturn a generator which combines Itemsets from itemsets into new itemsets of length newlength by taking all combinations of two itemsets and joining them.\n\nSee also Itemset.\n\n\n\n\n\ncombine_items(variable::AbstractVector{<:Item}, fixed::AbstractVector{<:Item})\n\nReturn a generator of Itemset, which iterates the combinations of Items in variable and prepend them to fixed vector.\n\nSee also Item, Itemset.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.grow_prune","page":"Advanced usage","title":"ModalAssociationRules.grow_prune","text":"grow_prune(\n    candidates::AbstractVector{Itemset},\n    frequents::AbstractVector{Itemset},\n    k::Integer\n)\n\nReturn a generator, which yields only the candidates for which every (k-1)-length subset is in frequents.\n\nSee also Itemset.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#Association-rules","page":"Advanced usage","title":"Association rules","text":"","category":"section"},{"location":"advanced/#ModalAssociationRules.generaterules-Tuple{Vector{Vector{I} where I<:Item}, Miner}","page":"Advanced usage","title":"ModalAssociationRules.generaterules","text":"generaterules(itemsets::AbstractVector{Itemset}, miner::AbstractMiner)\n\nRaw subroutine of generaterules!(miner::AbstractMiner; kwargs...).\n\nGenerates ARule from the given collection of itemsets and miner.\n\nThe strategy followed is described here at section 2.2.\n\nTo establish the meaningfulness of each association rule, check if it meets the global constraints specified in arulemeasures(miner), and yields the rule if so.\n\nSee also AbstractMiner, ARule, Itemset, arulemeasures.\n\n\n\n\n\ngeneraterules(itemsets::AbstractVector{Itemset}, miner::Miner)\n\nReturn a generator for the ARules that can be generated starting from the itemsets in itemsets, using the mining state saved within the miner structure.\n\nSee Itemset, Miner.\n\n\n\n\n\n","category":"method"},{"location":"advanced/#Mining-Policies","page":"Advanced usage","title":"Mining Policies","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"It is possible to limit the action of the mining, to force an AbstractMiner to only consider a subset of the available data.","category":"page"},{"location":"advanced/#ModalAssociationRules.worldfilter","page":"Advanced usage","title":"ModalAssociationRules.worldfilter","text":"worldfilter(::AbstractMiner)\n\nReturn the world filter policy wrapped within the AbstractMiner. This specifies how the worlds of a modal instance must be iterated.\n\nSee also AbstractMiner, data(::AbstractMiner), SoleLogics.WorldFilter.\n\n\n\n\n\nworldfilter(miner::Miner)\n\nSee also worldfilter(::AbstractMiner).\n\n\n\n\n\nworldfilter(bulldozer::Bulldozer) = bulldozer.worldfilter\n\nSee also worldfilter(::AbstractMiner).\n\n\n\n\n\n","category":"function"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"We can also constrain the generation of new itemsets and rules, by defining a vector of policies. For what regards itemsets, the following dispatches are available:","category":"page"},{"location":"advanced/#ModalAssociationRules.itemset_policies","page":"Advanced usage","title":"ModalAssociationRules.itemset_policies","text":"function itemset_policies(::AbstractMiner)\n\nReturn the mining policies vector wrapped within an AbstractMiner. Each mining policies is a meta-rule describing which Itemset are accepted during the mining phase and which are discarded.\n\nwarning: Warning\nThese policies often require to be tailored ad-hoc for a specific mining algorithm, and have the role of pruning unwanted explorations of the search space as early as possible.Keep in mind that you may need to modify some existing policies to make them correct and effective for your custom algorithm.As far as the algorithms already implemented in this package are concerned, generation policies are applied before saving an itemset inside the miner: thus, they reduce the waste of memory, but not necessarily of computational time.\n\nSee also AbstractMiner, generaterules, arule_policies.\n\n\n\n\n\nfunction itemset_policies(miner::Miner)\n\nSee itemset_policies(::AbstractMiner).\n\n\n\n\n\nitemset_policies(bulldozer::Bulldozer)\n\nSee also itemset_policies(::AbstractMiner).\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.islimited_length_itemset","page":"Advanced usage","title":"ModalAssociationRules.islimited_length_itemset","text":"function islimited_length_itemset(; maxlength::Union{Nothing,Integer}=nothing)::Function\n\nClosure returning a boolean function F with one argument itemset::Itemset.\n\nF is true if the length of the given itemset does not exceed the given thresholds.\n\nArguments\n\nmaxlength::Union{Nothing,Integer}=nothing: maximum itemset's length; when nothing,   defaults to typemax(Int16).\n\nSee also Itemset, itemset_policies.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isanchored_itemset","page":"Advanced usage","title":"ModalAssociationRules.isanchored_itemset","text":"function isanchored_itemset(;\n    npropositions::Integer=1,\n    ignoreuntillength::Integer=1\n)::Function\n\nClosure returning a boolean function F with one argument rule::Itemset.\n\nF is true if the given itemset contains atleast npropositions propositional anchors (that is, propositions without modal operators).\n\nArguments\n\nnpropositions::Integer=1: minimum number of propositional anchors (propositions with   no modal operators) in the antecedent of the given rule.\nignoreuntillength::Integer=1: avoid applying the policy to isolated Items, or   Itemset short enough.\n\nSee Item, Itemset, itemset_policies, isanchored_arule.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isdimensionally_coherent_itemset","page":"Advanced usage","title":"ModalAssociationRules.isdimensionally_coherent_itemset","text":"function isdimensionally_coherent_itemset(;)::Function\n\nClosure returning a boolean function F with one argument itemset::Itemset.\n\nThis is needed to ensure the Itemset is coherent with the dimensional definition of local support. All the propositions (or anchors) in an itemset must be VariableDistances wrapping references of the same size.\n\nSee also Itemset, itemset_policies, SoleData.VariableDistance.\n\n\n\n\n\n","category":"function"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The following are referred to association rules:","category":"page"},{"location":"advanced/#ModalAssociationRules.arule_policies","page":"Advanced usage","title":"ModalAssociationRules.arule_policies","text":"arule_policies(::AbstractMiner)\n\nReturn the association rules generation policies vector wrapped within an AbstractMiner. Each generation policies is a meta-rule describing which ARule are accepted during the generation algorithm and which are discarded.\n\nSee also AbstractMiner, generaterules, itemset_policies.\n\n\n\n\n\narule_policies(miner::Miner)\n\nSee itemset_policies(::AbstractMiner).\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.islimited_length_arule","page":"Advanced usage","title":"ModalAssociationRules.islimited_length_arule","text":"function islimited_length_arule(;\n    antecedent_maxlength::Union{Nothing,Integer}=nothing,\n    consequent_maxlength::Union{Nothing,Integer}=1\n)::Function\n\nClosure returning a boolean function F with one argument rule::ARule.\n\nF is true if the length of rule's antecedent (and consequent) does not exceed the given thresholds.\n\nArguments\n\nantecedent_maxlength::Union{Nothing,Integer}=nothing: maximum antecedent length of   the given rule; when nothing, defaults to typemax(Int16);\nconsequent_maxlength::Union{Nothing,Integer}=1: maximum consequent length of the given   rule; when nothing, defaults to typemax(Int16).\n\nSee also antecedent, ARule, arule_policies, consequent.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isanchored_arule","page":"Advanced usage","title":"ModalAssociationRules.isanchored_arule","text":"function isanchored_arule(; npropositions::Integer=1)::Function\n\nClosure returning a boolean function F with one argument rule::ARule.\n\nF is true if the given rule contains atleast npropositions propositional anchors (that is, propositions without modal operators).\n\nArguments\n\nnpropositions::Integer=1: minimum number of propositional anchors (propositions with   no modal operators) in the antecedent of the given rule.\n\nSee antecedent, ARule, arule_policies, generaterules, Item, Miner.\n\n\n\n\n\n","category":"function"},{"location":"advanced/#ModalAssociationRules.isheterogeneous_arule","page":"Advanced usage","title":"ModalAssociationRules.isheterogeneous_arule","text":"function isheterogeneous_arule(;\n    antecedent_nrepetitions::Integer=1,\n    consequent_nrepetitions::Integer=0,\n    consider_thresholds::Bool=false\n)::Function\n\nClosure returning a boolean function F with one argument rule::ARule.\n\nF is true if the given rule is heterogeneous, that is, across all the Item in rule antecedent and consequent, the number of identical variables V is at most nrepetitions.\n\nArguments\n\nantecedent_nrepetitions::Integer=1: maximum allowed number of identical variables in the   antecedent of the given rule.\nconsequent_nrepetitions::Integer=0: maximum allowed number of identical variables   between the antecedent and the consequent of the given rule.\nconsider_thresholds::Bool=false: if true, both identical variables and thresholds   are considered in the counting.\n\nSee antecedent, ARule, consequent, generaterules, Item, Miner.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#man-modal-generalization","page":"Mining with modal logic","title":"Association rule mining with modal logic","text":"","category":"section"},{"location":"modal-generalization/#New-building-blocks","page":"Mining with modal logic","title":"New building blocks","text":"","category":"section"},{"location":"modal-generalization/#ModalAssociationRules.WorldMask","page":"Mining with modal logic","title":"ModalAssociationRules.WorldMask","text":"const WorldMask = BitVector\n\nVector whose i-th position stores how many times a certain MeaningfulnessMeasure applied on a specific Itemsets is true on the i-th world of multiple instances.\n\nIf a single instance is considered, then this acts as a bit mask.\n\nFor example, if we consider 5 Kripke structures of a modal dataset, each of which containing 3 worlds, then the WorldMask of an itemset could be [5,2,0], meaning that the itemset is always true on the first world of every instance. In the second world, the same itemset is true on it only for two instances. Considering the third world, then the itemset is never true.\n\nSee also Itemset, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.EnhancedItemset","page":"Mining with modal logic","title":"ModalAssociationRules.EnhancedItemset","text":"const EnhancedItemset = Tuple{Itemset,UInt32}\n\nCompressed representation of multiple, identical Itemsets.\n\nSee also Itemset.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#ModalAssociationRules.ConditionalPatternBase","page":"Mining with modal logic","title":"ModalAssociationRules.ConditionalPatternBase","text":"const ConditionalPatternBase = Vector{EnhancedItemset}\n\nCollection of EnhancedItemset.\n\nnote: Note\nThis plays a central role in the state-of-the-art algorithm fpgrowth, where a ConditionalPatternBase embodies all the information needed to build an FPTree data structure in the algorithm.\n\nSee also EnhancedItemset, fpgrowth, FPTree.\n\n\n\n\n\n","category":"type"},{"location":"modal-generalization/#Modal-logic-in-action","page":"Mining with modal logic","title":"Modal logic in action","text":"","category":"section"},{"location":"modal-generalization/#Meaningfulness-measures","page":"Mining with modal logic","title":"Meaningfulness measures","text":"","category":"section"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"In general, we can define new meaningfulness measures by leveraging the following macros.","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.@localmeasure","page":"Mining with modal logic","title":"ModalAssociationRules.@localmeasure","text":"macro localmeasure(measname, measlogic)\n\nBuild a generic local meaningfulness measure, levering the optimizations provided by any AbstractMiner.\n\nArguments\n\nmeasname: the name of the local measure you are defining (e.g., lsupport);\nmeaslogic: a lambda function whose arguments are (itemset, data, ith_instance, miner) -\n\nsee the note below to know more about this.\n\nnote: Note\nWhen defining a new local measure, you only need to write its essential logic through a lambda function (itemset, X, ith_instance, miner).In particular, itemset is an Itemset, X is a reference to the dataset, ith_instance is an integer defining on which instance you want to compute the measure, and miner is the AbstractMiner in which you want to save the measure.Also, miner argument can be used to leverage its miningstate structure. A complete example of the logic behind local support is shown below:_lsupport_logic = (itemset, X, ith_instance, miner) -> begin\n    # vector representing on which world an Itemset holds\n    wmask = [\n        check(formula(itemset), X, ith_instance, w) for w in allworlds(X, ith_instance)]\n\n    # return the result enriched with more informations, that will eventually will be\n    # used if miner's miningstate has specific fields (e.g., :instance_item_toworlds).\n    return Dict(\n        :measure => count(wmask) / length(wmask),\n        :instance_item_toworlds => wmask,\n    )\nend\n\nSee also AbstractMiner, hasminingstate, lsupport, miningstate.\n\n\n\n\n\n","category":"macro"},{"location":"modal-generalization/#ModalAssociationRules.@globalmeasure","page":"Mining with modal logic","title":"ModalAssociationRules.@globalmeasure","text":"macro globalmeasure(measname, measlogic)\n\nBuild a generic global meaningfulness measure, levering the optimizations provided by any AbstractMiner.\n\nArguments\n\nmeasname: the name of the global measure you are defining (e.g., gsupport);\nmeaslogic: a lambda function whose arguments are (rule, X, threshold, miner) - see the\n\nnote below to know more about this.\n\nnote: Note\nWhen defining a new global measure, you only need to write its essential logic through a lambda function (itemset, X, ith_instance, miner).In particular, itemset is an Itemset, X is a reference to the dataset and miner is the AbstractMiner in which you want to save the measure.Also, miner argument can be used to leverage its miningstate structure. A complete example of the logic behind global support is shown below:_gsupport_logic = (itemset, X, threshold, miner) -> begin\n    _measure = sum([\n        lsupport(itemset, getinstance(X, ith_instance), miner) >= threshold\n        for ith_instance in 1:ninstances(X)\n    ]) / ninstances(X)\n\n    # at the moment, no `miningstate` fields in miner are leveraged\n    return Dict(:measure => _measure)\nend\n\nSee also AbstractMiner, hasminingstate, gsupport, miningstate.\n\n\n\n\n\n","category":"macro"},{"location":"modal-generalization/#ModalAssociationRules.@linkmeas","page":"Mining with modal logic","title":"ModalAssociationRules.@linkmeas","text":"macro linkmeas(gmeasname, lmeasname)\n\nLink together two MeaningfulnessMeasure, automatically defining globalof/localof and isglobalof/islocalof traits.\n\nSee also globalof, isglobalof, islocalof, localof, MeaningfulnessMeasure.\n\n\n\n\n\n","category":"macro"},{"location":"modal-generalization/","page":"Mining with modal logic","title":"Mining with modal logic","text":"We already introduced lsupport, gsupport, lconfidence and gconfidence in the Getting started section. Other measures that are already built into the package, are the following; note how they are always organized in both local and global versions.","category":"page"},{"location":"modal-generalization/#ModalAssociationRules.llift","page":"Mining with modal logic","title":"ModalAssociationRules.llift","text":"function llift(\n    rule::ARule,\n    ith_instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local lift for the given rule.\n\nLocal lift measures how far from independence are rule's antecedent and consequent on a modal logic instance.\n\nGiven an ARule X ⇒ Y, if local lift value is around 1, then this means that P(X ⋃ Y) = P(X)P(Y), and hence, the two Itemsets X and Y are independant. If value is greater than (lower than) 1, then this means that X and Y are dependant and positively (negatively) correlated Itemsets.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also AbstractMiner, antecedent, ARule, glift, LogicalInstance, llift, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.glift","page":"Mining with modal logic","title":"ModalAssociationRules.glift","text":"function glift(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nSee also llift.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.lconviction","page":"Mining with modal logic","title":"ModalAssociationRules.lconviction","text":"function lconviction(\n    rule::ARule,\n    ith_instance::LogicalInstance;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local conviction for the given rule.\n\nConviction attempts to measure the degree of implication of a rule. It's value ranges from 0 to +∞. Unlike lift, conviction is sensitive to rule direction; like lift, values far from 1 indicate interesting rules.\n\nIf a miner is provided, then its internal state is updated and used to leverage memoization.\n\nSee also AbstractMiner, antecedent, ARule, LogicalInstance, llift, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.gconviction","page":"Mining with modal logic","title":"ModalAssociationRules.gconviction","text":"function gconviction(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nSee also lconviction.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.lleverage","page":"Mining with modal logic","title":"ModalAssociationRules.lleverage","text":"function lleverage(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nCompute the local leverage for the given rule.\n\nMeasures how much more counting is obtained from the co-occurrence of the antecedent and consequent from the expected (from independence).\n\nThis value ranges between [-0.25,0.25].\n\nSee also AbstractMiner, antecedent, ARule, consequent, LogicalInstance, Threshold.\n\n\n\n\n\n","category":"function"},{"location":"modal-generalization/#ModalAssociationRules.gleverage","page":"Mining with modal logic","title":"ModalAssociationRules.gleverage","text":"function gleverage(\n    rule::ARule,\n    X::SupportedLogiset,\n    threshold::Threshold;\n    miner::Union{Nothing,AbstractMiner}=nothing\n)::Float64\n\nSee also lleverage.\n\n\n\n\n\n","category":"function"},{"location":"data-loaders/#data-loaders","page":"Dataset loaders","title":"Dataset loaders","text":"","category":"section"},{"location":"data-loaders/#NATOPS","page":"Dataset loaders","title":"NATOPS","text":"","category":"section"},{"location":"data-loaders/#ModalAssociationRules.load_NATOPS","page":"Dataset loaders","title":"ModalAssociationRules.load_NATOPS","text":"function load_NATOPS(     dirpath::String=joinpath(dirname(pathof(ModalAssociationRules)), \"../test/data/NATOPS\"),     fileprefix::String=\"NATOPS\" )\n\nLoader for NATOPS dataset. More on the official GitHub repository.\n\n\n\n\n\n","category":"function"},{"location":"data-loaders/#Libras","page":"Dataset loaders","title":"Libras","text":"","category":"section"},{"location":"data-loaders/#ModalAssociationRules.load_libras","page":"Dataset loaders","title":"ModalAssociationRules.load_libras","text":"function load_libras(     dirpath::String=joinpath(dirname(pathof(ModalAssociationRules)), \"../test/data/Libras\"),     fileprefix::String=\"Libras\" )\n\nLoader for Libras dataset. More information on UCI Archive.\n\n\n\n\n\n","category":"function"},{"location":"data-loaders/#HuGaDB","page":"Dataset loaders","title":"HuGaDB","text":"","category":"section"},{"location":"data-loaders/#ModalAssociationRules.load_hugadb","page":"Dataset loaders","title":"ModalAssociationRules.load_hugadb","text":"load_hugadb(;\n    filepath::String=HUGADB_FILEPATH,\n    filename::String=\"HuGaDB_v2_various_01_00.txt\",\n)\n\nLoader for HuGaDB dataset. More information on the official GitHub repository.\n\n\n\n\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"data-loaders/#ModalAssociationRules.filter_hugadb","page":"Dataset loaders","title":"ModalAssociationRules.filter_hugadb","text":"filter_hugadb(X::DataFrame, id)\n\nIsolate from X, which is a DataFrame encoding a set of HuGaDB instances, the only parts corresponding to a specific movement id.\n\n\n\n\n\n","category":"function"},{"location":"data-loaders/#Epilepsy","page":"Dataset loaders","title":"Epilepsy","text":"","category":"section"},{"location":"data-loaders/#ModalAssociationRules.load_epilepsy","page":"Dataset loaders","title":"ModalAssociationRules.load_epilepsy","text":"function load_epilepsy(     dirpath::String=joinpath(dirname(pathof(ModalAssociationRules)), \"../test/data/Epilepsy\"),     fileprefix::String=\"Epilepsy\" )\n\nLoader for Epilepsy dataset. More information on timeseriesclassification.com.\n\n\n\n\n\n","category":"function"},{"location":"#ModalAssociationRules","page":"Home","title":"ModalAssociationRules","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for ModalAssociationRules (or MAS), a Julia package for mining (modal) association rules in ModalAssociationRules.jl. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install ModalAssociationRules.jl, simply launch:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModalAssociationRules\")","category":"page"},{"location":"#feature-summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Define atomic facts, called items, that can be true or false with respect to some instance data; for example, given a collection of signals I=[[1,2,3], [4,5,6], [7,8,9]], an item p could encode the fact that sum(I[2]) < 16.\nEnhance the expressivity of each item and combine them in sets, called itemsets, leveraging more-than-propositional logical formalisms; considering the instance data I above, for example, an item q could encode the fact that mean(I[3]) = 8 and q and <A>p encodes the fact that q is true for the i-th dimension of the instance and p is true at the same time on the (i+1)-th dimension.\nExtract the association rules hidden in data; for example, the rule p => q encodes the fact that, if p is true, then q is true too. The extraction process is easily configurable via a Miner object, and can be executed with the parallel implementation of state-of-the-art algorithms.\nAnalyze and recap the extract rules in a succinct manner.","category":"page"},{"location":"#Diagrams","page":"Home","title":"Diagrams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"What follows are the system and container context diagrams, delineating the environment of this package and its main components from an high level perspective.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: system context diagram, relating the user to this package which, in turn, interfaces with SoleLogics.jl and SoleData.jl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As shown in the schema above, MAS interfaces with two main dependencies. In fact, while the main purpose of this package is to extract constrained co-occurrence relations from data, the representation layer of logical facts and data is almost entirely provided by two packages. SoleLogics.jl provides both the syntactical and semantical aspects related to various logical formalisms; the q and <A>p example in the Feature Summary section is not casual, and refers to Halpern and Shoham's modal logic for time intervals, which SoleLogics provide. SoleData.jl is used to automatically create Kripke structures from the given data, that is, expliciting the latter in the form of relational data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: container context diagram, showing the main components of this package)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each of the components above is explained exhaustively in the Use cases(TODO) and Contributing(TODO) sections. The first one is a complement to the Getting started section, while the second one is designed for developers that who are willing to contribute to this package.","category":"page"},{"location":"#Package-potential-at-a-glance","page":"Home","title":"Package potential at a glance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider a time series dataset obtained by recording the hand movements of an operator. Instead of working it through propositional logic, we decide to segment each time series in intervals, and we build relationships between intervals through a specific modal logic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particular, we choose HS Interval Logic in order to establish relationships such as \"interval X OVERLAPS with Y\", or \"interval Y comes AFTER X\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that the dataset is ready, we define some itemset. An itemset is a conjunction of facts (possibly, one fact, called item in the jargon). For example, we define the two following itemsets called A and B:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A coloneqq textmaxΔtextYHand tip r and thumb r  00\nB coloneqq textOtextmintextYHand tip r  -05","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first one could be translated as in the current interval, the right hand is oriented downward. We could also read it as the vertical distance between the right-hand middle finger tip and the right-hand thumb tip is negative.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the second fact, the relation OVERLAPS must be considered universally because of the square brackets. It can be translated into the phrase in all the intervals overlapping with the current one, the hand is located higher than -05.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now that we have arranged two itemsets, we want to establish if they are interesting based of a frequentist approach. In particular, we want to compute the support of each itemset, that is, the relative frequency of how many times the itemset is true within the data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"By leveraging a mining algorithm, we can join frequent itemsets two by two, iterating until it is not possible to join itemsets anymore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let us say that the itemset AB turns out to be frequent. At this point, we can generate two rules A Rightarrow B and B Rightarrow A. Now, we can compute specific meaningfulness measures to determine whether a rule is an association rule or not.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModalAssociationRules.jl lives in the context of Sole.jl, an open-source framework for symbolic machine learning, originally designed for machine learning based on modal logics (see Eduard I. Stan's PhD thesis 'Foundations of Modal Symbolic Learning' here).","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleBase.jl\nSoleLogics.jl\nMultiData.jl\nSoleModels.jl\nSoleData.jl\nSoleFeatures.jl \nSolePostHoc.jl","category":"page"},{"location":"hands-on/#hands-on","page":"Hands on","title":"Hands-on","text":"","category":"section"},{"location":"hands-on/#A-real-case-usage-scenario","page":"Hands on","title":"A real case usage scenario","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - retrace the experiments for TIME 2025","category":"page"},{"location":"hands-on/#Implementing-a-new-meaningfulness-measure","page":"Hands on","title":"Implementing a new meaningfulness measure","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - implement a new measure, leveraging @localmemo and @globalmemo, and explaining what optimizations they introduce.","category":"page"},{"location":"hands-on/#Writing-a-new-mining-algorithm","page":"Hands on","title":"Writing a new mining algorithm","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - Write a new mining algorithm (e.g., Eclat)","category":"page"},{"location":"hands-on/#Write-a-new-AbstractMiner","page":"Hands on","title":"Write a new AbstractMiner","text":"","category":"section"},{"location":"hands-on/","page":"Hands on","title":"Hands on","text":"TODO - E.g., to implement an heuristic approach such as NSGA-II.","category":"page"},{"location":"algorithms/#algorithms","page":"Available algorithms","title":"Available algorithms","text":"","category":"section"},{"location":"algorithms/#Candidate-generation-based","page":"Available algorithms","title":"Candidate generation based","text":"","category":"section"},{"location":"algorithms/#ModalAssociationRules.apriori","page":"Available algorithms","title":"ModalAssociationRules.apriori","text":"apriori(miner::Miner, X::MineableData; verbose::Bool=true)::Nothing\n\nApriori algorithm, as described here but generalized to also work with modal logic.\n\nArguments\n\nminer::M: miner containing the data and the extraction parameterization;\nprune_strategy::Function=grow_prune: strategy to prune candidates between one iteration\n\nand the successive;\n\nverbose::Bool=false: print informations about each iteration.\n\nSee also grow_prune, Miner, SoleBase.MineableData.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TreeProjection-based","page":"Available algorithms","title":"TreeProjection based","text":"","category":"section"},{"location":"algorithms/#FPGrowth","page":"Available algorithms","title":"FPGrowth","text":"","category":"section"},{"location":"algorithms/#ModalAssociationRules.fpgrowth","page":"Available algorithms","title":"ModalAssociationRules.fpgrowth","text":"fpgrowth(miner::AbstractMiner, X::MineableData; verbose::Bool=true)::Nothing\n\n(Modal) FP-Growth algorithm, as described here.\n\nArguments\n\nminer: miner containing the extraction parameterization;\nX: data from which you want to mine association rules;\nparallel: enable multi-threaded execution, using Threads.nthreads() threads;\ndistributed: enable multi-processing execution, with Distributed.nworkers() processes;\nverbose: print detailed informations while the algorithm runs.\n\nRequirements\n\nThis implementation requires a custom Bulldozer constructor capable of handling the given AbstractMiner. In particular, the following dispatch must be implemented:\n\nBulldozer(miner::MyMinerType, ith_instance::Integer)\n\nSee also AbstractMiner, Bulldozer, FPTree, HeaderTable, SoleBase.AbstractDataset\n\n\n\n\n\n","category":"function"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on two data structures, FPTree and HeaderTable. To know more about them and their, please refer to the documentation here data-structures.","category":"page"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"FPGrowth algorithm relies on the following two routines.","category":"page"},{"location":"algorithms/#ModalAssociationRules.patternbase-Tuple{Item, HeaderTable, Miner}","page":"Available algorithms","title":"ModalAssociationRules.patternbase","text":"patternbase(\n    item::Item,\n    htable::HeaderTable,\n    miner::AbstractMiner\n)::ConditionalPatternBase\n\nRetrieve the ConditionalPatternBase of fptree based on item.\n\nThe conditional pattern based on a FPTree is the set of all the paths from the tree root to nodes containing item (not included). Each of these paths is represented by an EnhancedItemset.\n\nThe EnhancedItemsets in the returned ConditionalPatternBase are sorted decreasingly by gsupport.\n\nSee also AbstractMiner, ConditionalPatternBase, EnhancedItemset, fpgrowth, FPTree, Item, Itemset, WorldMask.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#ModalAssociationRules.projection-Tuple{Vector{Tuple{Vector{I} where I<:Item, Integer}}, Miner}","page":"Available algorithms","title":"ModalAssociationRules.projection","text":"function projection(pbase::ConditionalPatternBase, miner::AbstractMiner)\n\nReturn respectively a FPTree and a HeaderTable starting from pbase. An AbstractMiner must be provided to guarantee the generated header table internal state is OK, that is, its items are sorted decreasingly by gsupport.\n\nSee also ConditionalPatternBase, FPTree, gsupport, HeaderTable, AbstractMiner.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/","page":"Available algorithms","title":"Available algorithms","text":"Also, FPGrowth requires the Miner to remember the worlds associated with the extracted frequent itemsets. To add this functionality, we can define a new dispatch of initminingstate: it is automatically considered to enrich the miner, while building it together with fpgrowth as mining algorithm.","category":"page"},{"location":"algorithms/#ModalAssociationRules.initminingstate-Tuple{typeof(fpgrowth), AbstractDataset}","page":"Available algorithms","title":"ModalAssociationRules.initminingstate","text":"initminingstate(::typeof(fpgrowth), ::MineableData)::MiningState\n\nMiningState fields levereged when executing FP-Growth algorithm.\n\nSee also hasminingstate, MiningState, miningstate.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#Anchored-semantics","page":"Available algorithms","title":"Anchored semantics","text":"","category":"section"},{"location":"algorithms/#ModalAssociationRules.anchored_semantics","page":"Available algorithms","title":"ModalAssociationRules.anchored_semantics","text":"anchored_semantics(miner::M; kwargs...)::M where {M<:AbstractMiner}\n\nLogic to be executed before the the algorithm wrapped within the miner; the goal is to make such an algorithm coherent with anchored semantics.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#ModalAssociationRules.anchored_apriori","page":"Available algorithms","title":"ModalAssociationRules.anchored_apriori","text":"anchored_apriori(miner::AbstractMiner, X::MineableData; kwargs...)::Nothing\n\nAnchored version of apriori algorithm, that is exactly apriori but assuring that miner possess atleast isanchored_itemset policy, with ignoreuntillength parameter set to 1 or higher.\n\nTODO - insert a reference to TIME2025 article.\n\nSee also AbstractMiner, apriori, isanchored_itemset, MineableData.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#ModalAssociationRules.anchored_fpgrowth","page":"Available algorithms","title":"ModalAssociationRules.anchored_fpgrowth","text":"function anchored_fpgrowth(miner::M; kwargs...)::M where {M<:AbstractMiner}\n\nImplementation of fpgrowth with anchored semantics. Essentially, Items are SoleData.VariableDistances wrapping motifs.\n\nMore information about motifs: <insert-link> More information about the implementation: <insert-link>\n\nSee also AbstractMiner, 'fpgrowth`, Item.\n\n\n\n\n\n","category":"function"}]
}
