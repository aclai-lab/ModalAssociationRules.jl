Critical:
  ✔ fpgrowth is not correct. formalize it and come back here. @done(24-04-26 13:53)
    ☐ tests are correct, but leveraging gsupport memoization brings up inconsistent confidences (a.k.a, confidences are > 1.0).
      # misteriously, this is resolved when gsupport memoization is not enabled...
      How to mitigate the problem: disable memoization for confidence computation
      What causes the problem: memo call inside gsupport
      What really causes the problem: probably how frequencies are summed up in fpgrowth
      Other ideas?: 12k tests works, apriori and fpgrowth seems to coincide. Maybe experiments are incorrect?
          - attempt1: maybe logiset internal memo structure is the problem? No, Logiset is deepcopied from a fresh one everytime we start a new experiment.
      note:
        - <L>min[V4] >= 1.8 \wedge <L>max[V6] >= 1 should be counted 23 times (correct answer with apriori) but is counted 8
    ☐ 01-right-hand-tip-only-apriori.exp, 01-right-hand-tip-only.exp, 02-right-hand-tip-later-apriori.exp, 02-right-hand-tip-only.exp
      # check if measures in (max[Z[Hand tip r]] ≥ 0) => (min[Y[Hand tip r]] ≥ -0.5) are always the same
      # see at the end of the file
  ☐ fpgrowth.jl refactoring
    ✔ remove unecessary powerups @done(24-04-28 18:48)
    ☐ recursion base case is too cumbersome
    ☐ remove `fpgrowth_fragments` support structure and clean deprecated code in the section at the end of fpgrowth function (where global supports are computed)
  ✔ more tests, better organized @done(24-04-29 12:34)
    ✔ redundant mining with apriori-based miner removed - tests are too slow @done(24-04-29 12:34)
  ✔ leverage Itemset and ARule hashing to avoid missing entries in dictionary (e.g., itemsets given with different item sorting must have same hash) @done(24-05-06 15:40)
  ✔ implement a smarter method for arules generation @done(24-05-16 09:40)
  ☐ consider high gsupport and gconfidence. consider O,B,E,D (+ inverses). Extract arules from one class, then model-check them with other class.
  #= obtain the following matrix
                        tested on:          
  rule extracted from:  
                        c0 c1 c2...
    c0
    c1
    c2...
  =#

Main:
  ✔ define Item, Itemset and its interface @done(24-01-15 16:16)
    # getters, setters, merge method
  ✔ define meaningfulness measures in an extensible way @done(24-01-15 16:16)
    # local and global support, confidence and write tests
  ✔ uniform algorithms interface (apply) @done(24-01-16 13:54)
  ✔ think about which parameters are needed and how they can be customized @done(24-01-16 13:54)
    # maybe a configuration structure with an array of local measures?
    # also, each measure can be activated locally or globally
    # localdict{string(local measure) -> counter} # if local measure is given
    # globldict{string(local measure) -> counter} # if local measure is given with globality on
  ✔ write an initial apriori implementation @done(24-02-05 23:52)
    ✔ leverage the fact that `prune` is a generator @done(24-02-17 01:40)
    ✔ remove FunctionWrappers, and simply convert `algorithm` in a miner into `Function` @done(24-03-08 00:15)
    ✔ change prune! to generate_and_prune! or something @done(24-02-19 00:46)
  ✔ write an initial fpgrowth implementation @done(24-03-08 00:15)
    ✔ in FPTree, realize a getcontributors function to hash the worlds in which an Item is true @done(24-02-10 21:12)
    ✔ FPTree getters, setters and utilities @done(24-02-10 21:13)
    ✔ HeaderTable with link! and follow @done(24-02-10 21:13)
    ✔ FPTree Base.push! overloading @done(24-02-10 21:35)
    ✔ Modal FPTree (see contributors) @done(24-02-12 02:30)
    ✔ pattern base constructor (enhanced itemset type, conditional pattern base type) @done(24-02-13 12:51)
    ✔ packing simultaneous FPTree and HeaderTable construction, then follow the algorithm described in the thesis "Algorithm for association rules mining from modal, temporal, spatial datasets" @done(24-02-13 15:13)
    ✔ guarantee HeaderTable internal state is correct when projecting an FPTree @done(24-02-13 15:57)
      # that is, check if items are sorted decreasingly by global support. This can be done only if a miner is provided!
    ✔ pack `patternbase` inside `projection` @done(24-02-19 00:44)
    ✔ `patternbase` must filter out the items inside the conditional pattern base which are not enough frequents @done(24-02-19 00:44)
    ☐ avoid instantiating two dictionaries in `patternbase`. Dict{Item,Pair{Int64,WorldMask}} could be an idea, but updating immutable structures is a bad idea, since WorldMask is very long.
    ☐ save the FPTree associated with the entire dataset in the info section
      # this might be useful? maybe a @debug macro enabling these savings could be an idea
    ✔ memoize gsupport and lsupport: infer it by projection WorldMasks @done(24-02-25 16:15)
    ☐ currently, this works only for local and global support. Add a for cycle to also consider user custom item measure.
    ☐ threshold must be considered when memoizing
    ✔ clean fpgrowth algorithm, removing contributors powerup system since it is not necessary to write a correct fpgrowth @done(24-04-23 09:35)
    ✔ remove all the unecessary dependencies from miner inside all fpgrowth subroutine calls @done(24-04-24 18:42)
      ☐ is the current global reference to miner inside sort! calls correct? I don't think so, since the order of the frequent items could change depending on which instance it's currently being fixed
    ☐ considering local support, frequent itemsets are identified but it is also necessary to compute the measure exact value.
  ☐ a miner should expose which lexicographic ordering he is using, and the same ordering has to ALWAYS be used when changing miner's internal state
    # maybe he could save it in the info field when is created?
    ☐ is this really necessary? try to remove :lexicographic_ordering powerup field from fpgrowth
  ☐ user custom meaningfulness measures should be checked too
  ☐ parallelize apriori and fpgrowth
  ☐ write a loader for NATOPS, in order to execute experiments also if timeseriesclassification.com is offline

Generic:
  ✔ move memoization accountability to Miner @done(24-02-07 23:58)
  ✔ call meaningfulness measures with Miner as optional argument @done(24-02-07 23:58)
  ✔ association rules generator (add and leverage ResumableFunction) @done(24-02-07 23:58)
  ☐ override Base.show for itemsets and association rules
  ✔ measures inside an Miner should be unique @done(24-03-08 00:16)
  ✔ miner.alphbaet should be renamed to represent a vector of item @done(24-02-18 23:40)
  ☐ Base.push!(fptree::FPTree etc...) dispatches for `Itemset` and `EnhancedItemset` are very similar... think about avoid repetitions
    # check push! docstrings
  ✔ make more macros like @equip_contributors (e.g., to handle mining timing). This is not trivial, as these macros can be chained @done(24-02-25 16:40)
    # changed in powerup and @initpowerup
  ☐ show for Item, Itemset, ARule, EnhancedItemset, Miner, FPTree, HeaderTable
  ☐ sort/issort by globalmemo, managing correct casting from Item, Itemset and EnhancedItemset
  ✔ contributors array should not be in Miner.info, but rather a proper attribute @done(24-02-27 11:36)
    # or maybe not?
  ✔ enrich info field inside Miner @done(24-02-27 11:36)
  ✔ remove nonfreqitems from Miner (this could be an optional info field?) @done(24-02-27 11:36)
  ✔ miner.algo and algorithm(miner) should coincide @done(24-02-27 11:37)
  ✔ ARuleMiner to Miner @done(24-02-25 16:18)
  ☐ test on iris dataset
  ✔ change mine to mine! and apply to apply! @done(24-03-08 00:16)
  ✔ make an Itemset struct instead of Vector{Item} @done(24-03-08 00:25)
  ☐ use make_lmeas and make_gmeas decorators in idea.jl, to define meaningfulness measures in a more compact and robust way
  ☐ move `isless` between `Item`s to SoleLogics
  ☐ rename getglobalthreshold_integer to global_threshold_integer; do the same for local support

Renamings:
  ☐ link property to nextcousin
  ✔ push to grow or something similar @done(24-04-03 17:30)

Optimizations:
  ☐ miner.items should be treated as a generator
  ☐ global memoization should check if memoized treshold is larger than requested one
  ☐ check whether sum between two vectors in addcontributors!(fptree::FPTree, contribution::WorldMask) is optimized
  ☐ give the possiblity to consider a dataset slice to extract rules without trivial items (see `EnhancedItemset`)

Utility:
  ✔ Base.in between two itemsets @done(24-02-19 14:18)
  ☐ build a macro to implement decorator pattern to build local and global measures, optionally exploiting Miner memoization
  ☐ better design how an Miner keeps track of local measures. Local and global measures CAN be independent.
    # maybe this is something we don't want to permit! Find one example of useful local measure independent from a global one
  ☐ Base.push!(fptree::FPTree, itemset::Itemset, miner::Miner) doesn't check if itemset is sorted by gsupport. Add a safe=false flag.
  ✔ expose a simple-to-understand pool of utility methods to perform combinatorics over itemsets @done(24-02-08 20:30)
    ✔ # (Itemset changed to Vector type from custom) @done(24-02-08 20:28)
    ✔ combine @done(24-02-08 20:30)
    ✔ prune @done(24-02-08 20:30)
    ✔ arules generation with powerset @done(24-02-08 20:30)
  ✔ contributors-related consts, contributors getter and addcontributors! setter (to implement modal FPTree) @done(24-02-12 02:31)
  ✔ prune! in fpgrowth must be an utility function, getting gsupp_integer_threshold and lsupp_integer_threshold as arguments
  ☐ gsupport and lsupport comparison with a threshold must be an utility function
  ✔ getter for gsupport and lsupport measure threshold as integer

To SoleModels or SoleData:
  ✔ consider feature when binning @done(24-02-02 15:52)
  ✔ organize the items generation system @done(24-02-05 23:52)
  ☐ find out how to extract interesting literals from which mine association rules

Testing:
  ✔ measure apriori algorithms execution time, leveraging SupportedLogiset optimization capabilities @done(24-02-26 10:18)
  ✔ write unit tests @done(24-02-26 10:18)
  ✔ codecov > 90% @done(24-02-26 11:41)
  ☐ association rules is tested for natops too

Future:
  ☐ item_contrained_measures and rule_constrained_measures fields in Miner could be dictionaries
  ☐ instead of just (gmeas, lthreshold, gthreshold), maybe a collection of indipendent (lmeas, lthreshold) could be better?
  ☐ leverage OneStepMemo
    # X_df, y = load_NATOPS();
    # X = scalarlogiset(X_df; relations = [IA_L], conditions =
    #     Vector{ScalarMetaCondition}(
    #         collect(Iterators.flatten([
    #             [ScalarMetaCondition(f, <=) for f in UnivariateMin.(1:24)],
    #             [ScalarMetaCondition(f, >) for f in UnivariateMin.(1:24)],
    #             [ScalarMetaCondition(f, <=) for f in UnivariateMax.(1:24)],
    #             [ScalarMetaCondition(f, >) for f in UnivariateMax.(1:24)],
    #         ]))
    #     )
    # )

Documentation:
  ✔ write a v0.1 documentation @done(24-02-23 15:11)
  ✔ WorldsMask to WorldMask @done(24-02-19 17:21)
  ✔ remove algorithm after algorithms name @done(24-02-19 17:21)
  ✔ Miner fix parametric types (isconcretetype) @done(24-02-19 17:21)
  ☐ remove setlocalthreshold/setglobalthreshold, add measures, getmeasure, getlocalmeasure, getglobalmeasure
  ☐ write a v0.2 documentation, including hands on section

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Frequent itemsets extracted by both (modal) apriori and fpgrowth.
What follows is last checkpoint.

julia> apriori_miner.gmemo
Dict{Tuple{Symbol, ARMSubject}, Float64} with 27 entries:
    (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2])                    => 0.102778
    (:gsupport, [min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6])                 => 0.136111
    (:gsupport, [min[V3] > -3.6, [L]min[V3] > -3.6])                              ☐ a miner should expose which lexicographic ordering he is using, and the same ordering has to ALWAYS be used when changing miner's internal state
    # maybe he could save it in the info field when is created?
    ☐ is this really necessary? try to remove :lexicographic_ordering powerup field from fpgrowth
          => 1.0
    (:gsupport, [min[V1] > -0.5, [L]min[V1] > -0.5])                                    => 0.172222
    (:gsupport, [min[V1] > -0.5, [L]min[V1] > -0.5, [L]min[V3] > -3.6])                 => 0.172222
    (:gsupport, [[L]min[V1] > -0.5, [L]min[V3] > -3.6])                                 => 0.241667
    (:gsupport, [min[V1] > -0.5, min[V3] > -3.6, [L]min[V1] > -0.5])                    => 0.172222
    (:gsupport, [min[V2] ≤ -2.2, ⟨L⟩min[V2] ≤ -2.2])                                    => 0.105556
    (:gsupport, [⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6])                                 => 0.136111
    (:gsupport, [min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2])                                    => 0.136111
    (:gsupport, [min[V3] > -3.6, [L]min[V1] > -0.5])                                    => 0.241667
    (:gsupport, [min[V1] > -0.5])                                                       => 0.561111
    (:gsupport, [min[V1] > -0.5, min[V3] > -3.6, [L]min[V3] > -3.6])                    => 0.561111
    (:gsupport, [min[V1] > -0.5, [L]min[V3] > -3.6])                                    => 0.561111
    (:gsupport, [min[V3] > -3.6, [L]min[V1] > -0.5, [L]min[V3] > -3.6])                 => 0.241667
    (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6]) => 0.102778
    (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6, [L]min[V3] > -3.6])                    => 0.158333
    (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6])                                       => 0.158333
    (:gsupport, [min[V1] > -0.5, min[V3] > -3.6, [L]min[V1] > -0.5, [L]min[V3] > -3.6]) => 0.172222
    (:gsupport, [[L]min[V1] > -0.5])                                                    => 0.241667
    (:gsupport, [⟨L⟩min[V2] ≤ -2.2])                                                    => 0.136111
    (:gsupport, [min[V2] ≤ -2.2, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6])                 => 0.105556
    (:gsupport, [[L]min[V3] > -3.6])                                                    => 1.0
    (:gsupport, [min[V1] > -0.5, min[V3] > -3.6])                                       => 0.561111
    (:gsupport, [min[V2] ≤ -2.2])                                                       => 0.158333
    (:gsupport, [min[V3] > -3.6])                                                       => 1.0
    (:gsupport, [min[V2] ≤ -2.2, [L]min[V3] > -3.6])                                    => 0.158333

Dict{Tuple{Symbol, ARMSubject}, Float64} with 27 entries:
  (:gsupport, [min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6])                 => 0.136111
  (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2])                    => 0.102778
  (:gsupport, [min[V3] > -3.6, [L]min[V3] > -3.6])                                    => 1.0
  (:gsupport, [min[V1] > -0.5, [L]min[V1] > -0.5])                                    => 0.172222
  (:gsupport, [min[V1] > -0.5, [L]min[V1] > -0.5, [L]min[V3] > -3.6])                 => 0.172222
  (:gsupport, [[L]min[V1] > -0.5, [L]min[V3] > -3.6])                                 => 0.241667
  (:gsupport, [min[V1] > -0.5, min[V3] > -3.6, [L]min[V1] > -0.5])                    => 0.172222
  (:gsupport, [min[V2] ≤ -2.2, ⟨L⟩min[V2] ≤ -2.2])                                    => 0.105556
  (:gsupport, [⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6])                                 => 0.136111
  (:gsupport, [min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2])                                    => 0.136111
  (:gsupport, [min[V3] > -3.6, [L]min[V1] > -0.5, [L]min[V3] > -3.6])                 => 0.241667
  (:gsupport, [min[V3] > -3.6, [L]min[V1] > -0.5])                                    => 0.241667
  (:gsupport, [min[V1] > -0.5])                                                       => 0.561111
  (:gsupport, [min[V1] > -0.5, [L]min[V3] > -3.6])                                    => 0.561111
  (:gsupport, [min[V1] > -0.5, min[V3] > -3.6, [L]min[V3] > -3.6])                    => 0.561111
  (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6]) => 0.102778
  (:gsupport, [min[V1] > -0.5, min[V3] > -3.6, [L]min[V1] > -0.5, [L]min[V3] > -3.6]) => 0.172222
  (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6])                                       => 0.158333
  (:gsupport, [min[V2] ≤ -2.2, min[V3] > -3.6, [L]min[V3] > -3.6])                    => 0.158333
  (:gsupport, [[L]min[V1] > -0.5])                                                    => 0.241667
  (:gsupport, [⟨L⟩min[V2] ≤ -2.2])                                                    => 0.136111
  (:gsupport, [min[V2] ≤ -2.2, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6])                 => 0.105556
  (:gsupport, [[L]min[V3] > -3.6])                                                    => 1.0
  (:gsupport, [min[V1] > -0.5, min[V3] > -3.6])                                       => 0.561111
  (:gsupport, [min[V2] ≤ -2.2])                                                       => 0.158333
  (:gsupport, [min[V3] > -3.6])                                                       => 1.0
  (:gsupport, [min[V2] ≤ -2.2, [L]min[V3] > -3.6])                                    => 0.158333



Cursed configuration to trigger fpgrowth inconsistency:
  _1_right_hand_tip_propositional_items_short = [
      Atom(ScalarCondition(UnivariateMin(4), >=, 1))
      Atom(ScalarCondition(UnivariateMin(4), >=, 1.8))
      Atom(ScalarCondition(UnivariateMin(5), >=, -0.5))
      Atom(ScalarCondition(UnivariateMax(6), >=, 0))
  ] |> Vector{Item}

  _2_right_hand_tip_X_items_later_short = diamond(IA_L).(
      _1_right_hand_tip_propositional_items_short)

  _2_right_hand_tip_later_items = vcat(
      _1_right_hand_tip_propositional_items_short[1:4],
      diamond(IA_L).(_1_right_hand_tip_propositional_items_short)[1:4],
      # box(IA_L).(_1_right_hand_tip_propositional_items_short)[1:4],
  ) |> Vector{Formula}

  _2_items = _2_right_hand_tip_later_items
  _2_itemsetmeasures = [(gsupport, 0.1, 0.1)]
  _2_rulemeasures = [(gconfidence, 0.1, 0.1)]

  runexperiment(
    X_1_have_command,
    fpgrowth,
    _2_items,
    _2_itemsetmeasures,
    _2_rulemeasures;
    reportname = "02-right-hand-tip-with-later.exp",
    variable_names = VARIABLE_NAMES,
  )

Cursed configuration to trigger fpgrowth inconsistency part2:
runexperiment(
	X_1_have_command,
	fpgrowth,
	_2_items[3:6],
	_2_itemsetmeasures,
	_2_rulemeasures;
	reportname = "02-have-command-hand-tip-with-later-relation.exp",
	variable_names = VARIABLE_NAMES,
)