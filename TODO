Main:
  ✔ define Item, Itemset and its interface @done(24-01-15 16:16)
    # getters, setters, merge method
  ✔ define meaningfulness measures in an extensible way @done(24-01-15 16:16)
    # local and global support, confidence and write tests
  ✔ uniform algorithms interface (apply) @done(24-01-16 13:54)
  ✔ think about which parameters are needed and how they can be customized @done(24-01-16 13:54)
    # maybe a configuration structure with an array of local measures?
    # also, each measure can be activated locally or globally
    # localdict{string(local measure) -> counter} # if local measure is given
    # globldict{string(local measure) -> counter} # if local measure is given with globality on
  ✔ write an initial apriori implementation @done(24-02-05 23:52)
    ✔ leverage the fact that `prune` is a generator @done(24-02-17 01:40)
    ☐ remove FunctionWrappers, and simply convert `algo` in a miner into `Function`
    ✔ change prune! to generate_and_prune! or something @done(24-02-19 00:46)
  ☐ write an initial fpgrowth implementation
    ✔ in FPTree, realize a getcontributors function to hash the worlds in which an Item is true @done(24-02-10 21:12)
    ✔ FPTree getters, setters and utilities @done(24-02-10 21:13)
    ✔ HeaderTable with link! and follow @done(24-02-10 21:13)
    ✔ FPTree Base.push! overloading @done(24-02-10 21:35)
    ✔ Modal FPTree (see contributors) @done(24-02-12 02:30)
    ✔ pattern base constructor (enhanced itemset type, conditional pattern base type) @done(24-02-13 12:51)
    ✔ packing simultaneous FPTree and HeaderTable construction, then follow the algorithm described in the thesis "Algorithm for association rules mining from modal, temporal, spatial datasets" @done(24-02-13 15:13)
    ✔ guarantee HeaderTable internal state is correct when projecting an FPTree @done(24-02-13 15:57)
      # that is, check if items are sorted decreasingly by global support. This can be done only if a miner is provided!
    ☐ in a FPTree, instead of counting how many integers inside `contributors` are different from 0, use a counter `contributors_count`
      # maybe the counting overhead is the same and this todo is useless?
    ✔ pack `patternbase` inside `projection` @done(24-02-19 00:44)
    ✔ `patternbase` must filter out the items inside the conditional pattern base which are not enough frequents @done(24-02-19 00:44)
    ☐ avoid instantiating two dictionaries in `patternbase`. Dict{Item,Pair{Int64,WorldMask}} could be an idea, but updating immutable structures is a bad idea, since WorldMask is very long.
    ☐ save the FPTree associated with the entire dataset in the info section
      # this might be useful? maybe a @debug macro enabling these savings could be an idea
    ☐ memoize gsupport and lsupport: infer it by projection WorldMasks

Generic:
  ✔ move memoization accountability to ARuleMiner @done(24-02-07 23:58)
  ✔ call meaningfulness measures with ARuleMiner as optional argument @done(24-02-07 23:58)
  ✔ association rules generator (add and leverage ResumableFunction) @done(24-02-07 23:58)
  ☐ override Base.show for itemsets and association rules
  ☐ measures inside an ARuleMiner should be unique
  ✔ miner.alphbaet should be renamed to represent a vector of item @done(24-02-18 23:40)
  ☐ Base.push!(fptree::FPTree etc...) dispatches for `Itemset` and `EnhancedItemset` are very similar... think about avoid repetitions
    # check push! docstrings
  ☐ make more macros like @equip_contributors (e.g., to handle mining timing). This is not trivial, as these macros can be chained
  ☐ show for Item, Itemset, EnhancedItemset, ARuleMiner, FPTree, HeaderTable
  ☐ sort/issort by globalmemo, managing correct casting from Item, Itemset and EnhancedItemset
  ☐ contributors array should not be in ARuleMiner.info, but rather a proper attribute 
    # or maybe not?
  ☐ enrich info field inside ARuleMiner
  ☐ remove nonfreqitems from ARuleMiner (this could be an optional info field?)

Optimizations:
  ☐ miner.items should be treated as a generator
  ☐ global memoization should check if memoized treshold is larger than requested one
  ☐ check whether sum between two vectors in addcontributors!(fptree::FPTree, contribution::WorldMask) is optimized
  ☐ give the possiblity to consider a dataset slice to extract rules without trivial items (see `EnhancedItemset`)

  Utility:
  ✔ Base.in between two itemsets @done(24-02-19 14:18)
  ☐ build a macro to implement decorator pattern to build local and global measures, optionally exploiting ARuleMiner memoization
  ☐ better design how an ARuleMiner keeps track of local measures. Local and global measures CAN be independent. 
    # maybe this is something we don't want to permit! Find one example of useful local measure independent from a global one
  ☐ Base.push!(fptree::FPTree, itemset::Itemset, miner::ARuleMiner) doesn't check if itemset is sorted by gsupport. Add a safe=false flag.
  ✔ expose a simple-to-understand pool of utility methods to perform combinatorics over itemsets @done(24-02-08 20:30)
    ✔ # (Itemset changed to Vector type from custom) @done(24-02-08 20:28)
    ✔ combine @done(24-02-08 20:30)
    ✔ prune @done(24-02-08 20:30)
    ✔ arules generation with powerset @done(24-02-08 20:30)
  ✔ contributors-related consts, contributors getter and addcontributors! setter (to implement modal FPTree) @done(24-02-12 02:31)
  
Global:
  ☐ make association rule mining a SoleRules submodule

To SoleModels or SoleData:
  ✔ consider feature when binning @done(24-02-02 15:52)
  ✔ organize the items generation system @done(24-02-05 23:52)
  ☐ find out how to extract interesting literals from which mine association rules

Testing:
  ☐ measure apriori algorithms execution time, leveraging SupportedLogiset optimization capabilities
  ☐ write unit tests

Future:
  ☐ item_contrained_measures and rule_constrained_measures fields in ARuleMiner could be dictionaries
  ☐ instead of just (gmeas, lthreshold, gthreshold), may a collection of indipendent (lmeas, lthreshold) be useful?

Documentation:
  ☐ write a v0.1 documentation
  ✔ WorldsMask to WorldMask @done(24-02-19 17:21)
  ✔ remove algorithm after algorithms name @done(24-02-19 17:21)
  ✔ ARuleMiner fix parametric types (isconcretetype) @done(24-02-19 17:21)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Notes

MODAL APRIORI - 27-element Vector{Vector{Formula}}:
  ✔ [min[V1] > -0.5] @done(24-02-18 04:18)
  ✔ [min[V2] ≤ -2.2] @done(24-02-18 04:18)
  ✔ [min[V3] > -3.6] @done(24-02-18 04:18)
  ✔ [[L]min[V1] > -0.5] @done(24-02-18 04:18)
  ✔ [⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:18)
  ✔ [[L]min[V3] > -3.6] @done(24-02-18 04:18)
  ✔ [min[V1] > -0.5, min[V3] > -3.6] @done(24-02-18 04:19)
  ✔ [min[V1] > -0.5, [L]min[V1] > -0.5] @done(24-02-18 04:19)
  ✔ [min[V1] > -0.5, [L]min[V3] > -3.6] @done(24-02-18 04:19)
  ✔ [min[V2] ≤ -2.2, min[V3] > -3.6] @done(24-02-18 04:20)
  ✔ [min[V2] ≤ -2.2, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:20)
  ✔ [min[V2] ≤ -2.2, [L]min[V3] > -3.6] @done(24-02-18 04:21)
  ✔ [min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:21)
  ✔ [min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:21)
  ✔ [min[V3] > -3.6, [L]min[V3] > -3.6] @done(24-02-18 04:20)
  ✔ [[L]min[V1] > -0.5, [L]min[V3] > -3.6] @done(24-02-18 04:21)
  ✔ [⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6] @done(24-02-18 04:21)
  ✔ [min[V1] > -0.5, min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:22)
  ✔ [min[V1] > -0.5, min[V3] > -3.6, [L]min[V3] > -3.6] @done(24-02-18 04:22)
  ✔ [min[V1] > -0.5, [L]min[V1] > -0.5, [L]min[V3] > -3.6] @done(24-02-18 04:22)
  ✔ [min[V2] ≤ -2.2, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:22)
  ✔ [min[V2] ≤ -2.2, min[V3] > -3.6, [L]min[V3] > -3.6] @done(24-02-18 04:24)
  ✔ [min[V2] ≤ -2.2, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6] @done(24-02-18 04:23)
  ✔ [min[V3] > -3.6, [L]min[V1] > -0.5, [L]min[V3] > -3.6] @done(24-02-18 04:24)
  ✔ [min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6] @done(24-02-18 04:24)
  ✔ [min[V1] > -0.5, min[V3] > -3.6, [L]min[V1] > -0.5, [L]min[V3] > -3.6] @done(24-02-18 04:24)
  ✔ [min[V2] ≤ -2.2, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2, [L]min[V3] > -3.6] @done(24-02-18 04:24)

MODAL FP-GROWTH - 27-element Vector{Vector{Formula}}:
  ✔ [min[V1] > -0.5] @done(24-02-18 04:18)
  ✔ [min[V2] ≤ -2.2] @done(24-02-18 04:18)
  ✔ [min[V3] > -3.6] @done(24-02-18 04:18)
  ✔ [[L]min[V1] > -0.5] @done(24-02-18 04:18)
  ✔ [⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:18)
  ✔ [[L]min[V3] > -3.6] @done(24-02-18 04:18)
  ✔ [min[V3] > -3.6, [L]min[V3] > -3.6] @done(24-02-18 04:21)
  ✔ [min[V2] ≤ -2.2, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:20)
  ✔ [[L]min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:21)
  ✔ [min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:21)
  ✔ [min[V2] ≤ -2.2, [L]min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:23)
  ✔ [min[V2] ≤ -2.2, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:22)
  ✔ [[L]min[V3] > -3.6, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:24)
  ✔ [min[V2] ≤ -2.2, [L]min[V3] > -3.6, min[V3] > -3.6, ⟨L⟩min[V2] ≤ -2.2] @done(24-02-18 04:24)
  ✔ [min[V1] > -0.5, [L]min[V1] > -0.5] @done(24-02-18 04:19)
  ✔ [[L]min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:21)
  ✔ [min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:21)
  ✔ [min[V1] > -0.5, [L]min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:22)
  ✔ [min[V1] > -0.5, min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:22)
  ✔ [[L]min[V3] > -3.6, min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:24)
  ✔ [min[V1] > -0.5, [L]min[V3] > -3.6, min[V3] > -3.6, [L]min[V1] > -0.5] @done(24-02-18 04:24)
  ✔ [[L]min[V3] > -3.6, min[V2] ≤ -2.2] @done(24-02-18 04:20)
  ✔ [min[V3] > -3.6, min[V2] ≤ -2.2] @done(24-02-18 04:20)
  ✔ [[L]min[V3] > -3.6, min[V3] > -3.6, min[V2] ≤ -2.2] @done(24-02-18 04:24)
  ✔ [[L]min[V3] > -3.6, min[V1] > -0.5] @done(24-02-18 04:19)
  ✔ [min[V3] > -3.6, min[V1] > -0.5] @done(24-02-18 04:19)
  ✔ [[L]min[V3] > -3.6, min[V3] > -3.6, min[V1] > -0.5] @done(24-02-18 04:22)