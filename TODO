Main:
  ✔ define Item, Itemset and its interface @done(24-01-15 16:16)
    # getters, setters, merge method
  ✔ define meaningfulness measures in an extensible way @done(24-01-15 16:16)
    # local and global support, confidence and write tests
  ✔ uniform algorithms interface (apply) @done(24-01-16 13:54)
  ✔ think about which parameters are needed and how they can be customized @done(24-01-16 13:54)
    # maybe a configuration structure with an array of local measures?
    # also, each measure can be activated locally or globally
    # localdict{string(local measure) -> counter} # if local measure is given
    # globldict{string(local measure) -> counter} # if local measure is given with globality on
  ✔ write an initial apriori implementation @done(24-02-05 23:52)
    ☐ leverage the fact that `prune` is a generator
  ☐ write an initial fpgrowth implementation
    ✔ in FPTree, realize a getcontributors function to hash the worlds in which an Item is true @done(24-02-10 21:12)
    ✔ FPTree getters, setters and utilities @done(24-02-10 21:13)
    ✔ HeaderTable with link! and follow @done(24-02-10 21:13)
    ✔ FPTree Base.push! overloading @done(24-02-10 21:35)
    ☐ packing simultaneous FPTree and HeaderTable construction, then follow the algorithm described in the thesis "Algorithm for association rules mining from modal, temporal, spatial datasets"


Generic:
  ✔ move memoization accountability to ARuleMiner @done(24-02-07 23:58)
  ✔ call meaningfulness measures with ARuleMiner as optional argument @done(24-02-07 23:58)
  ✔ association rules generator (add and leverage ResumableFunction) @done(24-02-07 23:58)
  ☐ global memoization should check if memoized treshold is larger than requested one
  ☐ override Base.show for itemsets and association rules
  ☐ think about alphabet parameter in apriori
  ☐ measures inside an ARuleMiner should be unique

Utility:
  ☐ build a macro to implement decorator pattern to build local and global measures, optionally exploiting ARuleMiner memoization
  ☐ better design how an ARuleMiner keeps track of local measures. Local and global measures CAN be indipendent. 
  ☐ Base.push!(fptree::FPTree, itemset::Itemset, miner::ARuleMiner) doesn't check if itemset is sorted by gsupport. Add a safe=false flag.
  ✔ expose a simple-to-understand pool of utility methods to perform combinatorics over itemsets @done(24-02-08 20:30)
    ✔ # (Itemset changed to Vector type from custom) @done(24-02-08 20:28)
    ✔ combine @done(24-02-08 20:30)
    ✔ prune @done(24-02-08 20:30)
    ✔ arules generation with powerset @done(24-02-08 20:30)

To SoleModels or SoleData:
  ✔ consider feature when binning @done(24-02-02 15:52)
  ✔ organize the alphabet generation system @done(24-02-05 23:52)
  ☐ find out how to extract interesting literals from which mine association rules

Testing:
  ☐ measure apriori algorithms execution time, leveraging SupportedLogiset optimization capabilities
  ☐ write unit tests

Future:
  ☐ item_contrained_measures and rule_constrained_measures fields in ARuleMiner could be dictionaries
  ☐ instead of just (gmeas, lthreshold, gthreshold), may a collection of indipendent (lmeas, lthreshold) be useful?

Documentation:
  ☐ write a v0.1 documentation