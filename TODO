Critical:
  ✔ fpgrowth is not correct. formalize it and come back here. @done(24-04-26 13:53)
    ✔ tests are correct, but leveraging gsupport memoization brings up inconsistent confidences (a.k.a, confidences are > 1.0). @done(24-05-27 12:18)
      # misteriously, this is resolved when gsupport memoization is not enabled...
      How to mitigate the problem: disable memoization for confidence computation
      What causes the problem: memo call inside gsupport
      What really causes the problem: probably how frequencies are summed up in fpgrowth
      Other ideas?: 12k tests works, apriori and fpgrowth seems to coincide. Maybe experiments are incorrect?
          - attempt1: maybe logiset internal memo structure is the problem? No, Logiset is deepcopied from a fresh one everytime we start a new experiment.
      note:
        - <L>min[V4] >= 1.8 \wedge <L>max[V6] >= 1 should be counted 23 times (correct answer with apriori) but is counted 8
    ✔ 01-right-hand-tip-only-apriori.exp, 01-right-hand-tip-only.exp, 02-right-hand-tip-later-apriori.exp, 02-right-hand-tip-only.exp @done(24-05-27 12:18)
      # check if measures in (max[Z[Hand tip r]] ≥ 0) => (min[Y[Hand tip r]] ≥ -0.5) are always the same
      # see at the end of the file
  ✔ fpgrowth.jl refactoring @done(24-06-03 23:52)
    ✔ remove unecessary powerups @done(24-04-28 18:48)
    ✔ recursion base case is too cumbersome @done(24-06-03 23:52)
    ✔ remove `fpgrowth_fragments` support structure and clean deprecated code in the section at the end of fpgrowth function (where global supports are computed) @done(24-06-03 23:52)
  ✔ more tests, better organized @done(24-04-29 12:34)
    ✔ redundant mining with apriori-based miner removed - tests are too slow @done(24-04-29 12:34)
  ✔ leverage Itemset and ARule hashing to avoid missing entries in dictionary (e.g., itemsets given with different item sorting must have same hash) @done(24-05-06 15:40)
  ✔ implement a smarter method for arules generation @done(24-05-16 09:40)
  ✔ consider high gsupport and gconfidence. consider O,B,E,D (+ inverses). Extract arules from one class, then model-check them with other class. @done(24-06-03 23:52)
  #= obtain the following matrix
                        tested on:          
  rule extracted from:  
                        c0 c1 c2...
    c0
    c1
    c2...
  =#

Main:
  ✔ define Item, Itemset and its interface @done(24-01-15 16:16)
    # getters, setters, merge method
  ✔ define meaningfulness measures in an extensible way @done(24-01-15 16:16)
    # local and global support, confidence and write tests
  ✔ uniform algorithms interface (apply) @done(24-01-16 13:54)
  ✔ think about which parameters are needed and how they can be customized @done(24-01-16 13:54)
    # maybe a configuration structure with an array of local measures?
    # also, each measure can be activated locally or globally
    # localdict{string(local measure) -> counter} # if local measure is given
    # globldict{string(local measure) -> counter} # if local measure is given with globality on
  ✔ write an initial apriori implementation @done(24-02-05 23:52)
    ✔ leverage the fact that `prune` is a generator @done(24-02-17 01:40)
    ✔ remove FunctionWrappers, and simply convert `algorithm` in a miner into `Function` @done(24-03-08 00:15)
    ✔ change prune! to generate_and_prune! or something @done(24-02-19 00:46)
  ✔ write an initial fpgrowth implementation @done(24-03-08 00:15)
    ✔ in FPTree, realize a getcontributors function to hash the worlds in which an Item is true @done(24-02-10 21:12)
    ✔ FPTree getters, setters and utilities @done(24-02-10 21:13)
    ✔ HeaderTable with link! and follow @done(24-02-10 21:13)
    ✔ FPTree Base.push! overloading @done(24-02-10 21:35)
    ✔ Modal FPTree (see contributors) @done(24-02-12 02:30)
    ✔ pattern base constructor (enhanced itemset type, conditional pattern base type) @done(24-02-13 12:51)
    ✔ packing simultaneous FPTree and HeaderTable construction, then follow the algorithm described in the thesis "Algorithm for association rules mining from modal, temporal, spatial datasets" @done(24-02-13 15:13)
    ✔ guarantee HeaderTable internal state is correct when projecting an FPTree @done(24-02-13 15:57)
      # that is, check if items are sorted decreasingly by global support. This can be done only if a miner is provided!
    ✔ pack `patternbase` inside `projection` @done(24-02-19 00:44)
    ✔ `patternbase` must filter out the items inside the conditional pattern base which are not enough frequents @done(24-02-19 00:44)
    ☐ avoid instantiating two dictionaries in `patternbase`. Dict{Item,Pair{Int64,WorldMask}} could be an idea, but updating immutable structures is a bad idea, since WorldMask is very long.
    ☐ save the FPTree associated with the entire dataset in the info section
      # this might be useful? maybe a @debug macro enabling these savings could be an idea
    ✔ memoize gsupport and lsupport: infer it by projection WorldMasks @done(24-02-25 16:15)
    ☐ currently, this works only for local and global support. Add a for cycle to also consider user custom item measure.
    ☐ threshold must be considered when memoizing
    ✔ clean fpgrowth algorithm, removing contributors powerup system since it is not necessary to write a correct fpgrowth @done(24-04-23 09:35)
    ✔ remove all the unecessary dependencies from miner inside all fpgrowth subroutine calls @done(24-04-24 18:42)
      ☐ is the current global reference to miner inside `sort!` calls correct? I don't think so, since the order of the frequent items could change depending on which instance it's currently being fixed
    ☐ considering local support, frequent itemsets are identified but it is also necessary to compute the measure exact value.
  ☐ a miner should expose which lexicographic ordering he is using, and the same ordering has to ALWAYS be used when changing miner's internal state
    # maybe he could save it in the info field when is created?
    ☐ is this really necessary? try to remove :lexicographic_ordering powerup field from fpgrowth
  ☐ user custom meaningfulness measures should be checked too
  ☐ parallelize apriori and fpgrowth
  ✔ write a loader for NATOPS, in order to execute experiments also if timeseriesclassification.com is offline @done(24-07-26 22:35)
  ☐ @assert in Miner (when miner is used to compute a meaningfulness measure about some item it does not know)

Generic:
  ✔ move memoization accountability to Miner @done(24-02-07 23:58)
  ✔ call meaningfulness measures with Miner as optional argument @done(24-02-07 23:58)
  ✔ association rules generator (add and leverage ResumableFunction) @done(24-02-07 23:58)
  ☐ override Base.show for itemsets and association rules
  ✔ measures inside an Miner should be unique @done(24-03-08 00:16)
  ✔ miner.alphbaet should be renamed to represent a vector of item @done(24-02-18 23:40)
  ☐ Base.push!(fptree::FPTree etc...) dispatches for `Itemset` and `EnhancedItemset` are very similar... think about avoid repetitions
    # check push! docstrings
  ✔ make more macros like @equip_contributors (e.g., to handle mining timing). This is not trivial, as these macros can be chained @done(24-02-25 16:40)
    # changed in powerup and @initpowerup
  ☐ show for Item, Itemset, ARule, EnhancedItemset, Miner, FPTree, HeaderTable
  ☐ sort/issort by globalmemo, managing correct casting from Item, Itemset and EnhancedItemset
  ✔ contributors array should not be in Miner.info, but rather a proper attribute @done(24-02-27 11:36)
    # or maybe not?
  ✔ enrich info field inside Miner @done(24-02-27 11:36)
  ✔ remove nonfreqitems from Miner (this could be an optional info field?) @done(24-02-27 11:36)
  ✔ miner.algo and algorithm(miner) should coincide @done(24-02-27 11:37)
  ✔ ARuleMiner to Miner @done(24-02-25 16:18)
  ✔ test on iris dataset @done(24-07-26 22:36)
  ✔ change mine to mine! and apply to apply! @done(24-03-08 00:16)
  ✔ make an Itemset struct instead of Vector{Item} @done(24-03-08 00:25)
  ☐ move `isless` between `Item`s to SoleLogics
  ✔ use make_lmeas and make_gmeas decorators in idea.jl, to define meaningfulness measures in a more compact and robust way @done(24-07-28 14:39)
    ✔ a make_lmeas idea is ready (called just "lmeas") but it needs to be converted from builder function to macro @done(24-07-28 14:39)
      because the generated function name has to be the one request by the user (e.g., lsupport) and not a strange codification
      ✔ a first implementation is ready and tested for local support, now use it also for local confidence and repeat for global measures @done(24-07-28 15:58)
      ✔ remove miner keywords from lconfidence calls, since now the interface has changed @done(24-07-29 13:57)
      ☐ define lift and conviction measures
      ☐ maybe @generated macro is what we needed in the first place? Take a look
      ☐ define a @linkmeas macro to automatically generate linkings between a global measure and its associated local one

  Renamings:
    ☐ link property to nextcousin
    ✔ push to grow or something similar @done(24-04-03 17:30)
    ☐ rename getglobalthreshold_integer to global_threshold_integer; do the same for local support

Optimizations:
  ☐ miner.items should be treated as a generator
  ☐ global memoization should check if memoized treshold is larger than requested one
  ☐ check whether sum between two vectors in addcontributors!(fptree::FPTree, contribution::WorldMask) is optimized
  ☐ give the possiblity to consider a dataset slice to extract rules without trivial items (see `EnhancedItemset`)
  ☐ Why is WorldMask an integer vector? Make it a Bool vector, or atleast a Vector{Int8}

Utility:
  ✔ Base.in between two itemsets @done(24-02-19 14:18)
  ☐ build a macro to implement decorator pattern to build local and global measures, optionally exploiting Miner memoization
  ☐ better design how an Miner keeps track of local measures. Local and global measures CAN be independent.
    # maybe this is something we don't want to permit! Find one example of useful local measure independent from a global one
  ☐ Base.push!(fptree::FPTree, itemset::Itemset, miner::Miner) doesn't check if itemset is sorted by gsupport. Add a safe=false flag.
  ✔ expose a simple-to-understand pool of utility methods to perform combinatorics over itemsets @done(24-02-08 20:30)
    ✔ # (Itemset changed to Vector type from custom) @done(24-02-08 20:28)
    ✔ combine @done(24-02-08 20:30)
    ✔ prune @done(24-02-08 20:30)
    ✔ arules generation with powerset @done(24-02-08 20:30)
  ✔ contributors-related consts, contributors getter and addcontributors! setter (to implement modal FPTree) @done(24-02-12 02:31)
  ✔ prune! in fpgrowth must be an utility function, getting gsupp_integer_threshold and lsupp_integer_threshold as arguments
  ☐ gsupport and lsupport comparison with a threshold must be an utility function
  ✔ getter for gsupport and lsupport measure threshold as integer

To SoleModels or SoleData:
  ✔ consider feature when binning @done(24-02-02 15:52)
  ✔ organize the items generation system @done(24-02-05 23:52)
  ☐ find out how to extract interesting literals from which mine association rules

Testing:
  ✔ measure apriori algorithms execution time, leveraging SupportedLogiset optimization capabilities @done(24-02-26 10:18)
  ✔ write unit tests @done(24-02-26 10:18)
  ✔ codecov > 90% @done(24-02-26 11:41)
  ☐ association rules is tested for natops too

Future:
  ☐ item_contrained_measures and rule_constrained_measures fields in Miner could be dictionaries
  ☐ instead of just (gmeas, lthreshold, gthreshold), maybe a collection of indipendent (lmeas, lthreshold) could be better?
  ☐ leverage OneStepMemo
    # X_df, y = load_NATOPS();
    # X = scalarlogiset(X_df; relations = [IA_L], conditions =
    #     Vector{ScalarMetaCondition}(
    #         collect(Iterators.flatten([
    #             [ScalarMetaCondition(f, <=) for f in UnivariateMin.(1:24)],
    #             [ScalarMetaCondition(f, >) for f in UnivariateMin.(1:24)],
    #             [ScalarMetaCondition(f, <=) for f in UnivariateMax.(1:24)],
    #             [ScalarMetaCondition(f, >) for f in UnivariateMax.(1:24)],
    #         ]))
    #     )
    # )

Documentation:
  ✔ write a v0.1 documentation @done(24-02-23 15:11)
  ✔ WorldsMask to WorldMask @done(24-02-19 17:21)
  ✔ remove algorithm after algorithms name @done(24-02-19 17:21)
  ✔ Miner fix parametric types (isconcretetype) @done(24-02-19 17:21)
  ☐ remove setlocalthreshold/setglobalthreshold, add measures, getmeasure, getlocalmeasure, getglobalmeasure
  ☐ write a v0.2 documentation, including hands on section

Experiments:
  ☐ maybe, in `runcomparison` function, `◐` measure should depend from the `union support` of the rule in each class.
  #= Explanation. Consider the followin row in the generated matrix
  ┌────────────────────────────────────────────────────────┬───────┬──────────┬───────────────────────────┬───────────────────────────┬───────────────────────────┬───────────────────────────┬───────────────────────────┬────────────────────────────┐
  │                                                   Rule │     ◐ │    1 - 𝑆 │            I have command │                 All clear │                 Not clear │              Spread wings │                Fold wings │                 Lock wings │
  ├────────────────────────────────────────────────────────┼───────┼──────────┼───────────────────────────┼───────────────────────────┼───────────────────────────┼───────────────────────────┼───────────────────────────┼────────────────────────────┤
  │                   [min[V5] ≥ -0.5] => [[D]max[V6] ≥ 0] │ 0.237 │    0.241 │         confidence: 0.586 │         confidence: 0.571 │         confidence: 0.429 │        confidence: 0.0357 │         confidence: 0.148 │            confidence: 0.0 │
  │                                                        │       │          │ antecedent support: 0.967 │ antecedent support: 0.467 │ antecedent support: 0.467 │ antecedent support: 0.933 │   antecedent support: 0.9 │  antecedent support: 0.933 │
  │                                                        │       │          │   consequent support: 0.8 │   consequent support: 0.6 │ consequent support: 0.367 │   consequent support: 0.7 │ consequent support: 0.533 │  consequent support: 0.133 │
  │                                                        │       │          │      union support: 0.567 │      union support: 0.267 │        union support: 0.2 │     union support: 0.0333 │      union support: 0.133 │         union support: 0.0 │
  ├────────────────────────────────────────────────────────┼───────┼──────────┼───────────────────────────┼───────────────────────────┼───────────────────────────┼───────────────────────────┼───────────────────────────┼────────────────────────────┤
  measure `◐` is computed as the mean confidence of the rule, on each class but the first (I have command).
  The first class is ignored since the rule was extracted from here.
  The mean could be weighted.
  `Not clear` confidence is 0.43 but it's union support is not so high.
  =#